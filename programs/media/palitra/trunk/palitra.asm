;#___________________________________________________________________________________________________
;****************************************************************************************************|
; Program Palitra (c) Sergei Steshin (Akyltist)                                                      |
;----------------------------------------------------------------------------------------------------|
;; compiler:     FASM 1.69.31                                                                        |
;; version:      0.2.0                                                                               |
;; last update:  15/09/2012                                                                          |
;; e-mail:       dr.steshin@gmail.com                                                                |
;.....................................................................................................
;; History:                                                                                          |
;; 0.1.0 - Первая версия программы                                                                   |
;; 0.2.0 - Исправлено попадание в сетку, берется ближайший по диагонали пиксель.                     |
;;       - Добавлены ползунки, для регулирования rgb составляющих цвета и вывод этих составляющих.   |
;;       - Убран вывод цвета в бинарном виде (пока за не надобностью и не актуальностью).            |
;;       - Мелкая косметика.                                                                         |
;.....................................................................................................
;; All rights reserved.                                                                              |
;;                                                                                                   |
;; Redistribution and use in source and binary forms, with or without modification, are permitted    |
;; provided that the following conditions are met:                                                   |
;;       * Redistributions of source code must retain the above copyright notice, this list of       |
;;         conditions and the following disclaimer.                                                  |
;;       * Redistributions in binary form must reproduce the above copyright notice, this list of    |
;;         conditions and the following disclaimer in the documentation and/or other materials       |
;;         provided with the distribution.                                                           |
;;       * Neither the name of the <organization> nor the names of its contributors may be used to   |
;;         endorse or promote products derived from this software without specific prior written     |
;;         permission.                                                                               |
;;                                                                                                   |
;; THIS SOFTWARE IS PROVIDED BY Sergei Steshin ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,      |
;; INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A        |
;; PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY DIRECT, |
;; INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED    |
;; TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS       |
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT          |
;; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  |
;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                                      |
;....................................................................................................|


;#___________________________________________________________________________________________________
;****************************************************************************************************|
; ЗАГОЛОВОК ИСПОЛНЯЕМОГО ФАЙЛА ПРИЛОЖЕНИЯ ДЛЯ КОЛИБРИ ОС                                             |
;----------------------------------------------------------------------------------------------------/
  use32
  org	 0x0

  db	 'MENUET01'
  dd	 0x01
  dd	 START
  dd	 I_END
  dd	 0x1000
  dd	 0x1000
  dd	 0x0
  dd	 0x0

include 'macros.inc'

START:
;#___________________________________________________________________________________________________
;****************************************************************************************************|
; ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ - ОБРАБОТКА СОБЫТИЙ                                                        |
;----------------------------------------------------------------------------------------------------/
red:
    call draw_window			  ; вызываем перерисовку окна приложения
still:
    mcall   10				  ; функция 10 - ждать события
    cmp     eax,1			  ; перерисовать окно ?
    je	    red 			  ; если да - на метку red
    cmp     eax,2			  ; нажата клавиша ?
    je	    key 			  ; если да - на key
    cmp     eax,3			  ; нажата кнопка ?
    je	    button			  ; если да - на button
    jmp     still			  ; если другое событие - в начало цикла
;end_still


key:					  ; нажата клавиша на клавиатуре
    mcall   2				  ; функция 2 - считать код символа (в ah) (тут в принципе не нужна)
    jmp     still			  ; вернуться к началу цикла
;end_key

button:
    mcall   17				  ; 17 - получить идентификатор нажатой кнопки
    cmp     ah, 1			  ; если нажата кнопка с номером 1,
    jz	    bexit			  ; выходим
    cmp     ah, 7
    jne     color_button
    call    mouse_get
    jmp     still
  color_button:
    push    eax
    call    mouse_local 		  ; получил локальные координаты
    mov     ebx,129
    mov     ecx,[mouse_y]
    sub     ebx,ecx
    mov     ecx,3
    imul    ecx,ebx

    ;push    ecx


    pop     eax
  red_button:
    cmp     ah, 8
    jne     green_button
    mov     [cred],cl
    call    set_spectr
    jmp     still
  green_button:
    cmp     ah, 9
    jne     blue_button
    mov     [cgreen],cl
    call    set_spectr
    jmp     still
  blue_button:
    cmp     ah, 10
    jne     still
    mov     [cblue],cl
    call    set_spectr
    jmp     still
  bexit:
    mcall -1				  ; иначе конец программы
;end_button

;#___________________________________________________________________________________________________
;****************************************************************************************************|
; ГЛАВНЫЙ МОДУЛЬ ОТРИСОВКИ ОКНА И ЭЛЕМЕНТОВ ПРИЛОЖЕНИЯ                                               |
;----------------------------------------------------------------------------------------------------/
draw_window:
    mov     eax,12			  ; функция 12: означает, что будет рисоваться окно
    mov     ebx,1			  ; 1,начало рисования
    int     0x40			  ; Прерывание

    mov     eax,48			  ; Функция 48 - стили отображения окон
    mov     ebx,3			  ; Подфункция 3 - получить стандартные цвета окон.
    mov     ecx,sc			  ; Указатель на буфер размером edx байт, под структуру
    mov     edx,sizeof.system_colors	  ; Размер таблицы цветов (должен быть 40 байт)
    int     0x40			  ; Прерывание

    mov     eax,48			  ; Функция 48 - стили отображения окон.
    mov     ebx,4			  ; Подфункция 4 - возвращает eax = высота скина.
    int     0x40			  ; Прерывание
    mov     ecx,eax			  ; Запоминаем высоту скина

    xor     eax,eax			  ; Очищаем eax (mov eax,0) (Функция 0)
    mov     ebx,200 shl 16+325		  ; [координата по оси x]*65536 + [размер по оси x]
    add     ecx,200 shl 16+168		  ; Высота скина + [координата по y]*65536 + [размер по y]
    mov     edx,[sc.work]		  ; Видимо стиль окна по дефолту
    or	    edx,0x34000000		  ; Или окно со скином фиксированных размеров
    mov     edi,title			  ; Заголовок окна
    int     0x40			  ; Прерывание

    call    draw_palitra		  ; РИСУЕМ ПАЛИТРУ
    call    draw_result 		  ; РИСУЕМ РЕЗУЛЬТАТ

    mov     eax,8			  ; Функция 8 - определить/удалить кнопку
    mov     ebx,89 shl 16+222		  ; Начальные координаты по х [к-та x]*65536 + [размер]
    mov     ecx,9 shl 16+147		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    mov     edx,0x60000007		  ; Начальное ID кнопок - 0xXYnnnnnn
    int     0x40

    mov     ebx,10 shl 16+8		  ; Начальные координаты по х [к-та x]*65536 + [размер]
    mov     edx,0x60000008		  ; ID = 8
    mov     ecx,45 shl 16+85		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    int     0x40			  ; Рисуем невидимую кнопку под слайдером red
    add     ebx,29 shl 16		  ; Добавляем
    inc     edx 			  ; ID = 9
    int     0x40			  ; Рисуем невидимую кнопку под слайдером green
    add     ebx,29 shl 16		  ; Добавляем
    inc     edx 			  ; ID = 10
    int     0x40			  ; Рисуем невидимую кнопку под слайдером blue

    mov     eax,12			  ; функция 12: означает, что будет рисоваться окно
    mov     ebx,2			  ; 1,начало рисования
    int     0x40			  ; Прерывание

    ret 				  ; Возвращаем управление


;#___________________________________________________________________________________________________
;****************************************************************************************************|
; БЛОК ВСПОМОГАТЕЛЬНЫХ ПРОЦЕДУР И ФУНКЦИЙ ПРИЛОЖЕНИЯ                                                 |
;----------------------------------------------------------------------------------------------------/

mouse_global:
    ;.................................................................................................
    ; Получаем координаты мыши
    ;.................................................................................................
    mov     eax,37			  ; Функция 37 - работа с мышью
    mov     ebx,0			  ; нам нужны глобальные координаты
    int     0x40			  ; eax = x*65536 + y, (x,y)=координаты курсора мыши
    mov     ecx,eax			  ;
    shr     ecx,16			  ; ecx = x+1
    movzx   edx,ax			  ; edx = y+1
    dec     ecx 			  ; ecx = x
    dec     edx 			  ; edx = y
    mov     [mouse_x],ecx		  ; mouse_x = x
    mov     [mouse_y],edx		  ; mouse_y = y
    ret 				  ; Возвращаем управление
;end_mouse_global

mouse_local:
    ;.................................................................................................
    ; Получаем координаты мыши относительно окна
    ;.................................................................................................
    mov     eax,37			  ; Функция 37 - работа с мышью
    mov     ebx,1			  ; нам нужны глобальные координаты
    int     0x40			  ; eax = x*65536 + y, (x,y)=координаты курсора мыши
    mov     ecx,eax			  ;
    shr     ecx,16			  ; ecx = x+1
    movzx   edx,ax			  ; edx = y+1
    dec     ecx 			  ; ecx = x
    dec     edx 			  ; edx = y
    mov     [mouse_x],ecx		  ; mouse_x = x
    mov     [mouse_y],edx		  ; mouse_y = y
    ret 				  ; Возвращаем управление
;end_mouse_local

desktop_get:
    ;.................................................................................................
    ; Определяем ширину экрана
    ;.................................................................................................
    mov     eax,14			  ; Определяем ширину экрана (eax = [xsize]*65536 + [ysize])
    int     0x40			  ; xsize = размер по горизонтали - 1
    mov     ebx,eax			  ;
    shr     ebx,16			  ; ebx = xsize-1
    ;movzx   edx,ax                       ;; edx = ysize-1 (лишний код)
    inc     ebx 			  ; ebx = xsize
    ;inc     edx                          ;; edx = ysize (лишний код)
    mov     [desctop_w],ebx
    ret
;end_desktop_get

mouse_get:
    mov     esi,2			  ; КОСТЫЛЬ: флаг для избежания зацикливания
    call    mouse_global
    call    desktop_get
    re_mouse_loop:			  ; КОСТЫЛЬ: метка для возврата если попали в сетку
      mov     ebx,[desctop_w]
      imul    ebx,[mouse_y]		  ; ebx = y*xsize
      add     ebx,[mouse_x]		  ; ebx = y*xsize+x

      ;.................................................................................................
      ; Берем цвет с палитры в переменную
      ;.................................................................................................
      mov     eax,35			  ; Функция взятия цвета
      ;mov     ebx,ecx                    ;; ebx = y*xsize+x (лишний код)
      int     0x40			  ; Получаем цвет в eax
      cmp     eax,[sc.work]		  ; Сравниваем с фоном приложения
      je      mouse_err 		  ; Если это он - то ничего не делаем
      cmp     eax,0x222222		  ; Сравниваем с цветом сетки
      je      mouse_err 		  ; Если это он - то ничего не делаем
      jmp     mouse_set 		  ; КОСТЫЛЬ: прыгаем чтобы не брать цвет сетки
    mouse_err:				  ; КОСТЫЛЬ: если попали в сетку или фон
      inc     [mouse_y] 		  ; КОСТЫЛЬ: смещаем по диагонали сначала по х
      inc     [mouse_x] 		  ; КОСТЫЛЬ: смещаем по диагонали потом по у
      dec     esi			  ; КОСТЫЛЬ: Уменьшаем флаг
      cmp     esi,0			  ; КОСТЫЛЬ: Сравниваем с нулем
    jz	      mouse_exit		  ; КОСТЫЛЬ: Если ноль то сделали всё что могли
    jmp    re_mouse_loop		  ; КОСТЫЛЬ: Если не ноль то попробуем взять соселний пиксель
    mouse_set:
    mov     [color],eax 		  ; Иначе запоминаем новый цвет
    call    draw_result 		  ; Выводим результат
    mouse_exit:
    ret 				  ; Возвращаем управление
;end_mouse_get----------------------------------------------------------------------------------------

draw_palitra:
    ;.................................................................................................
    ; Отрисовка фона под кнопки
    ;.................................................................................................
    mov     eax,13			  ; Функция 13 - нарисовать прямоугольник
    mov     edx,0x222222		  ; цвет
    mov     ecx,9 shl 16+73		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    mov     esi,2			  ; Счетчик линий подложек
    re_draw:
    mov     ebx,89 shl 16+73		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    mov     edi,3			  ; Счетчик количества подложек
    for_fon_loop:
      int     0x40			  ; Прерывание
      add     ebx,75 shl 16		  ; Смещаем положение линии по х
      dec     edi			  ; Уменьшаем счетчик кнопок
      cmp     edi,0			  ; Сравниваем с нулем
    jnz     for_fon_loop		  ; Если не ноль то в начало цикла
    dec     esi 			  ; Уменьшаем его
    cmp     esi,0			  ; Сравниваем с нулем
    mov     ecx,84 shl 16+73		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    jnz     re_draw			  ; Если не ноль то в начало цикла

    ;.................................................................................................
    ; Отрисовка кнопок по циклу
    ;.................................................................................................
    mov     eax,13			  ; Функция 13 - нарисовать прямоугольник
    mov     edx,0x0FFFFFFF		  ; цвет
    mov     esi,6			  ; Счетчик количества абзацев (#4,8)
    mov     ebx,78 shl 16+8		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    for_abz:
      ;;push    esi                       ; Сохраняем значение счетчика линий в стек
      cmp     esi,3
      jne     x2_line
      mov     ebx,78 shl 16+8
      x2_line:
      add     ebx,3 shl 16		  ; Смещаем положение линии по x
      mov     edi,8			  ; Счетчик количества кнопок в строке
      for_stolbik:
	push	edi			  ; Сохраняем значение счетчика линий в стек
	mov	edi,8			  ; Счетчик количества кнопок в строке
	mov	ecx,  1 shl 16+8	  ; Начальные координаты по y [к-та y]*65536 + [размер]
	cmp	esi,3
	jg	y2_line 		  ; Если больше 4 то игнорим
	mov	ecx,76 shl 16+8
	y2_line:
	add	ebx,9 shl 16		  ; Смещаем положение линии по x
	for_loop:
	  add	  ecx,9 shl 16		  ; Смещаем положение линии по y
	  int	  0x40			  ; Прерывание
	  sub	  edx,32 shl 16
	  dec	  edi			  ; Уменьшаем счетчик кнопок
	  cmp	  edi,0 		  ; Сравниваем с нулем
	  jnz	  for_loop		  ; Если не ноль то в начало цикла
      sub     edx,32 shl 8
      pop     edi			  ; Иначе восстанавливаем счетчик линий
      dec     edi			  ; Уменьшаем его
      cmp     edi,0			  ; Сравниваем с нулем
      jnz     for_stolbik		  ; Если не ноль то в начало цикла
    sub     edx,48			  ; (#64,32)
    ;;pop     esi                         ; Иначе восстанавливаем счетчик линий
    dec     esi 			  ; Уменьшаем его
    cmp     esi,0			  ; Сравниваем с нулем
    jnz     for_abz			  ; Если не ноль то в начало цикла
    ret 				  ; Возвращаем управление
;end_draw_palitra-------------------------------------------------------------------------------------

draw_result:
    ;.................................................................................................
    ; Отрисовка результата цвета в hex
    ;.................................................................................................
    mov     eax,13			  ; Функция 13 - нарисовать прямоугольник
    mov     edx,0x222222		  ; цвет-обводки
    mov     ebx,4 shl 16+15		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    mov     ecx,9 shl 16+15		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    int     0x40			  ; Прерывание (ос рисует прямоугольник)
    mov     ebx,23 shl 16+62		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    int     0x40			  ; Прерывание (ос рисует прямоугольник)

    mov     edx,[color] 		  ; цвет
    mov     ebx,5 shl 16+13		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    mov     ecx,10 shl 16+13		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    int     0x40			  ; Прерывание (ос рисует прямоугольник)
    mov     edx,0xFFFFFF		  ; цвет-фона
    mov     ebx,24 shl 16+60		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    int     0x40			  ; Прерывание (ос рисует прямоугольник)

    mov     eax,47			  ; Функция 47 - вывод числа в окно
    mov     ecx,[color] 		  ; число (при bl=0) или указатель (при bl=1)
    mov     esi,0x0			  ; 0xX0RRGGBB
    mov     ebx,256+8 shl 16		  ; параметры преобразования числа в текст (HEX)
    mov     edx,34 shl 16+13		  ; [координата по оси x]*65536 + [координата по оси y]
    int     0x40			  ; Прерывание - выводим результат в окно (HEX)

    mov     eax,4			  ; функция 4: написать текст в окне
    mov     ebx,27*65536+13		  ; [x начальный] *65536 + [y начальный]
    mov     ecx,0x0			  ; цвет текста RRGGBB
    mov     edx,hex			  ; рисуем '#'
    mov     esi,1			  ; длина текста в байтах
    int     0x40

    ;.................................................................................................
    ; Отрисовка полей для r g b значений
    ;.................................................................................................
    call    get_spectr
    mov     eax,13			  ; Функция 13 - нарисовать прямоугольник
    mov     edx,0x222222		  ; цвет-обводки
    mov     ebx,4 shl 16+23		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    mov     ecx,142 shl 16+15		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    int     0x40
    mov     ebx,33 shl 16+23		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    int     0x40
    mov     ebx,62 shl 16+23		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    int     0x40
    mov     edx,0xFFFFFF		  ; цвет-обводки
    mov     ebx,5 shl 16+21		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    mov     ecx,143 shl 16+13		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    int     0x40
    mov     ebx,34 shl 16+21		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    int     0x40
    mov     ebx,63 shl 16+21		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    int     0x40

    ;.................................................................................................
    ; Отрисовка r g b значений
    ;.................................................................................................
    movzx   eax,[cred]			  ; красный
    mov     ebx,7*65536+146		  ; [x начальный] *65536 + [y начальный]
    call    draw_value			  ; выводим результат

    movzx   eax,[cgreen]		  ; зеленый
    mov     ebx,36*65536+146		  ; [x начальный] *65536 + [y начальный]
    call    draw_value			  ; выводим результат

    movzx   eax,[cblue] 		  ; синий
    mov     ebx,65*65536+146		  ; [x начальный] *65536 + [y начальный]
    call    draw_value			  ; выводим результат

    ;.................................................................................................
    ; Обнуляем фон
    ;.................................................................................................
    mov     eax,13			  ; Функция 13 - нарисовать прямоугольник
    mov     edx,[sc.work]		  ; цвет-обводки
    mov     ebx,8 shl 16+66		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    mov     ecx,40 shl 16+87		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    int     0x40

    ;mov     eax,13                        ; Функция 13 - нарисовать прямоугольник
    ;mov     edx,0x222222                  ; цвет-обводки
    ;mov     ebx,4 shl 16+23               ; Начальные координаты по x [к-та x]*65536 + [размер]
    ;mov     ecx,30 shl 16+105             ; Начальные координаты по y [к-та y]*65536 + [размер]
    ;int     0x40
    ;add     ebx,29 shl 16                 ; Начальные координаты по x [к-та y]*65536 + [размер]
    ;int     0x40
    ;add     ebx,29 shl 16                 ; Начальные координаты по x [к-та y]*65536 + [размер]
    ;int     0x40

    mov     eax,13			  ; Функция 13 - нарисовать прямоугольник
    mov     edx,[sc.work]		  ; цвет-обводки
    mov     ebx,5 shl 16+21		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    mov     ecx,31 shl 16+103		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    int     0x40
    add     ebx,29 shl 16		  ; Начальные координаты по x [к-та y]*65536 + [размер]
    int     0x40
    add     ebx,29 shl 16		  ; Начальные координаты по x [к-та y]*65536 + [размер]
    int     0x40

    ;.................................................................................................
    ; Выводим буквы r g b
    ;.................................................................................................
    mov     eax,4			  ; 4 - вывести строку текста в окно
    mov     ebx,12 shl 16+34		  ; [координата по оси x]*65536 + [координата по оси y]
    mov     ecx,0x0			  ; 0xX0RRGGBB (RR, GG, BB задают цвет текста)
    mov     edx,cname			  ; указатель на начало строки
    mov     esi,2			  ; выводить esi символов
    newline:				  ; цикл
      int     0x40			    ; Прерывание
      add     ebx,29 shl 16		    ; Добавляем
      add     edx,2			    ; Добавляем
      cmp     [edx],byte 'x'		    ; Сравнение с байтом х
    jne    newline			  ; Если не нуль или не равно

    ;.................................................................................................
    ; Отрисовка слайдеров
    ;.................................................................................................
    mov     eax,13			  ; Функция 13 - нарисовать прямоугольник
    mov     edx,0x222222		  ; цвет-обводки
    mov     ebx,12 shl 16+4		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    mov     ecx,45 shl 16+85		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    int     0x40
    add     ebx,29 shl 16		  ; Начальные координаты по x [к-та y]*65536 + [размер]
    int     0x40
    add     ebx,29 shl 16		  ; Начальные координаты по x [к-та y]*65536 + [размер]
    int     0x40

    mov     edx,0xFA0919		  ; цвет-обводки
    mov     ebx,13 shl 16+2		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    mov     ecx,46 shl 16+83		  ; Начальные координаты по y [к-та y]*65536 + [размер]
    int     0x40
    mov     edx,0x08CE19		  ; цвет-обводки
    add     ebx,29 shl 16		  ; Начальные координаты по x [к-та y]*65536 + [размер]
    int     0x40
    mov     edx,0x0909FF		  ; цвет-обводки
    add     ebx,29 shl 16		  ; Начальные координаты по x [к-та y]*65536 + [размер]
    int     0x40

    ;.................................................................................................
    ; Отрисовка ползунков
    ;.................................................................................................
    mov     edx,0x0			  ; цвет-ползунков
    mov     ebx,10 shl 16+8		  ; Начальные координаты по x [к-та x]*65536 + [размер]
    movzx   eax,[cred]			  ; берем значение цвета
    call    draw_slider
    add     ebx,29 shl 16
    movzx   eax,[cgreen]		  ; берем значение цвета
    call    draw_slider
    add     ebx,29 shl 16
    movzx   eax,[cblue] 		  ; берем значение цвета
    call    draw_slider

    ret 				  ; Возвращаем управление
;end_draw_result

draw_slider:
    xor     ecx,ecx
    mov     cl,0x3			  ; будем делить его на 3 так как ползунки длинной 85 пикселей
    div     cl				  ; делим - целое в al остаток в ah
    mov     cl,128			  ; нижняя точка ползунка
    sub     cl,al			  ; cl=cl-al
    shl     ecx,16
    add     ecx,4			  ; задаем начальное положение
    mov     eax,13			  ; Функция 13 - нарисовать прямоугольник
    int     0x40
    ret 				  ; Возвращаем управление

;end_slider

draw_value:
    ;.................................................................................................
    ; Вывод числа из строки в указанной области
    ;.................................................................................................
    push    ebx 			  ; сохраняем присланные координаты
    mov     ebx,10			  ; устанавливаем основание системы счисления
    mov     edi,buff			  ; указатель на строку буфера
    call    int2ascii			  ; конвертируем число и ложим как строку в буфер + esi длина
    mov     eax,4			  ; функция 4: написать текст в окне
    pop     ebx 			  ; достаем из стека присланные координаты
    mov     ecx,0x0			  ; цвет текста RRGGBB
    mov     edx,buff			  ; указатель на начало текста
    int     0x40
    ret 				  ; Возвращаем управление
;end_draw_value

hex_digit:
    ;.................................................................................................
    ; Преобразование в ASCII (вне зависимости от системы счисления)
    ;.................................................................................................
    cmp    dl,10			  ; в dl ожидается число от 0 до 15
    jb	   .less			  ; если dl<10 то переходим
    add    dl,'A'-10			  ; 10->A 11->B 12->C ...
    ret 				  ; Возвращаем управление
    .less:
    or	   dl,'0'			  ; Если система счисления 10-я и менее
    ret 				  ; Возвращаем управление
;end_hex_digit

int2ascii:
    ;.................................................................................................
    ; Преобразование числа в строку
    ;.................................................................................................
    ; eax - 32-х значное число
    ; ebx - основание системы счисления
    ; edi - указатель на строку буфера
    ; Возвращает заполненный буфер и esi - длина строки
    ;pushad
    xor     esi,esi			  ; зануляем счетчик символов
    convert_loop:
    xor     edx,edx			  ; зануляем регистр под остаток
    div     ebx 			  ; eax/ebx - остаток в edx
    call    hex_digit			  ; преобразуем символ
    push    edx 			  ; ложим в стек
    inc     esi 			  ; увеличиваем счетчик
    test    eax,eax			  ; если еще можно делить
    jnz     convert_loop		  ; то делием еще
    cld 				  ; ОБЯЗАТЕЛЬНО сбрасываем флаг направления DF (запись вперёд)
    write_loop: 			  ; иначе
    pop     eax 			  ; достаем из стека в еах
    stosb				  ; записываем в буфер по адресу ES:(E)DI
    dec     esi 			  ; уменьшаем счетчик
    test    esi,esi			  ; если есть что доставать из стека
    jnz     write_loop			  ; то достаём
    mov     byte [edi],0		  ; иначе дописыываем нулевой байт
    ;popad                                 ; восстанавливаем значения регистров
    ; код ниже не имеет ничего общего к функции, просто возвращает еще длинну полученной строки
    mov     edi,buff			  ; указатель на начало текста
    call    str_len
    mov     esi,eax
    ret 				  ; и возвращаем управление
;end_int2ascii

get_spectr:
    ;.................................................................................................
    ; возвращает r,g,b состовляющие цвета
    ;.................................................................................................
    ; get blue
    mov     ecx,[color]
    movzx   eax,cl
    mov     [cblue],al
    ; get red
    mov     eax,ecx
    xor     ax,ax
    shr     eax,16
    mov     [cred],al
    ; get green
    shl      ecx,16
    shr      ecx,24
    mov      [cgreen],cl
    ret 				  ; и возвращаем управление
;end_get_spectr

set_spectr:
    ;.................................................................................................
    ; устанавливает из r,g,b цвет
    ;.................................................................................................
    ; get blue
    movzx   eax,[cred]
    shl     eax,8
    mov     al,[cgreen]
    shl     eax,8
    mov     al,[cblue]
    mov     [color],eax
    call    draw_result 		  ; Выводим результат
    ret 				  ; и возвращаем управление
;end_get_spectr

str_len:
    ;.................................................................................................
    ; определяет длину строки (вход->EDI ZS offset ; выход->EAX ZS length)
    ;.................................................................................................
	push ecx
	push esi
	push edi

	cld
	xor   al, al
	mov ecx, 0FFFFFFFFh
	mov esi, edi
	repne scasb
	sub edi, esi
	mov eax, edi
	dec eax

	pop edi
	pop esi
	pop ecx

	ret
;end_str_len
;#___________________________________________________________________________________________________
;****************************************************************************************************|
; БЛОК ПЕРЕМЕННЫХ И КОНСТАНТ                                                                         |
;----------------------------------------------------------------------------------------------------/

    color	dd 00000000h		  ; хранит значение выбранного цвета
    mouse_x	dd 0			  ; хранит глобальную х координату мыши
    mouse_y	dd 0			  ; хранит глобальную у координату мыши
    desctop_w	dd 0			  ; хранит ширину экрана
    sc		system_colors		  ; хранит структуру системных цветов скина
    title	db 'Palitra v0.2',0	  ; хранит имя программы
    hex 	db '#',0		  ; для вывода решётки как текста
    cname	db 'R G B x'		  ; хранит разряды цветов (red,green,blue) x-метка конца
    cred	db 0			  ; храним красный спекрт
    cgreen	db 0			  ; храним зеленый спектр
    cblue	db 0			  ; храним синий спектр
    buff	db '000',0
I_END:


