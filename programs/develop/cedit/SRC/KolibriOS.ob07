(*
    Copyright 2021, 2022 Anton Krotov

    This file is part of CEdit.

    CEdit is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CEdit is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CEdit. If not, see <http://www.gnu.org/licenses/>.
*)

MODULE KolibriOS;

IMPORT
    KOSAPI, SYSTEM, U := Utils;

CONST
    fontWidth* = 8;
    fontHeight* = 16;

VAR

	colors*: RECORD
		rsrvd,
		taskbar,
		dark*,
		light*,
		window_title*,
		work*,
		button*,
		button_text*,
		work_text*,
		line*: INTEGER
	END;


PROCEDURE CreateWindow* (x, y, w, h, color, style, hcolor, hstyle: INTEGER; htext: ARRAY OF CHAR);
BEGIN
    KOSAPI.sysfunc6(0, x*65536 + w, y*65536 + h, color + LSL(style, 24), hcolor + LSL(hstyle, 24), SYSTEM.ADR(htext[0]))
END CreateWindow;


PROCEDURE BeginDraw*;
BEGIN
    KOSAPI.sysfunc2(12, 1)
END BeginDraw;


PROCEDURE EndDraw*;
BEGIN
    KOSAPI.sysfunc2(12, 2)
END EndDraw;


PROCEDURE EventTimeout* (t: INTEGER): INTEGER;
    RETURN KOSAPI.sysfunc2(23, t)
END EventTimeout;


PROCEDURE ThreadInfo (offsa, offsb: INTEGER; VAR a, b: INTEGER);
VAR
    buffer: ARRAY 1024 OF BYTE;
BEGIN
    KOSAPI.sysfunc3(9, SYSTEM.ADR(buffer[0]), -1);
    SYSTEM.GET32(SYSTEM.ADR(buffer[0]) + offsa, a);
    SYSTEM.GET32(SYSTEM.ADR(buffer[0]) + offsb, b);
END ThreadInfo;


PROCEDURE WinSize* (VAR width, height: INTEGER);
BEGIN
    ThreadInfo(42, 46, width, height)
END WinSize;


PROCEDURE WinPos* (VAR x, y: INTEGER);
BEGIN
    ThreadInfo(34, 38, x, y)
END WinPos;


PROCEDURE ClientSize* (VAR width, height: INTEGER);
BEGIN
    ThreadInfo(62, 66, width, height)
END ClientSize;


PROCEDURE ClientPos* (VAR x, y: INTEGER);
BEGIN
    ThreadInfo(54, 58, x, y)
END ClientPos;


PROCEDURE ScreenSize* (VAR width, height: INTEGER);
VAR
    eax, ebx: INTEGER;
    right, left, top, bottom: INTEGER;
BEGIN
    eax := KOSAPI.sysfunc22(48, 5, ebx);
    left := LSR(eax, 16);
    right := eax MOD 65536;
    top := LSR(ebx, 16);
    bottom := ebx MOD 65536;
    width := right - left + 1;
    height := bottom - top + 1
END ScreenSize;


PROCEDURE ThreadID* (): INTEGER;
VAR
    id: INTEGER;
BEGIN
    ThreadInfo(30, 30, id, id)
    RETURN id
END ThreadID;


PROCEDURE RolledUp* (): BOOLEAN;
VAR
    buffer: ARRAY 1024 OF BYTE;
BEGIN
    KOSAPI.sysfunc3(9, SYSTEM.ADR(buffer[0]), -1)
    RETURN ODD(LSR(buffer[70], 2))
END RolledUp;


PROCEDURE SetWinSize* (width, height: INTEGER);
BEGIN
    KOSAPI.sysfunc5(67, -1, -1, width, height)
END SetWinSize;


PROCEDURE DrawText* (x, y, color: INTEGER; text: ARRAY OF WCHAR);
BEGIN
    KOSAPI.sysfunc6(4, x*65536 + y, color + LSL(0A0H, 24), SYSTEM.ADR(text[0]), 0, 0)
END DrawText;


PROCEDURE DrawText69* (x, y, color: INTEGER; text: ARRAY OF CHAR);
BEGIN
    KOSAPI.sysfunc6(4, x*65536 + y, color + LSL(080H, 24), SYSTEM.ADR(text[0]), 0, 0)
END DrawText69;


PROCEDURE DrawText866* (x, y, color: INTEGER; text: ARRAY OF CHAR);
BEGIN
    KOSAPI.sysfunc6(4, x*65536 + y, color + LSL(0D0H, 24), SYSTEM.ADR(text[0]), 0, colors.work)
END DrawText866;


PROCEDURE DrawText866bk* (x, y, color, bkColor: INTEGER; text: ARRAY OF CHAR);
BEGIN
    KOSAPI.sysfunc6(4, x*65536 + y, color + LSL(0D0H, 24), SYSTEM.ADR(text[0]), 0, bkColor)
END DrawText866bk;


PROCEDURE MousePos* (VAR x, y: INTEGER);
VAR
    res: INTEGER;
BEGIN
    res := KOSAPI.sysfunc2(37, 0);
    y := res MOD 65536;
    x := res DIV 65536
END MousePos;


PROCEDURE CreateButton* (id, Left, Top, Width, Height, Color: INTEGER; Caption: ARRAY OF WCHAR);
VAR
    x, y: INTEGER;
BEGIN
    KOSAPI.sysfunc5(8, LSL(Left, 16) + Width, LSL(Top, 16) + Height, id, Color);
    x := Left + (Width - fontWidth * LENGTH(Caption)) DIV 2;
    y := Top + (Height - fontHeight) DIV 2 + 1;
    DrawText(x, y, colors.button_text, Caption)
END CreateButton;


PROCEDURE DeleteButton* (id: INTEGER);
BEGIN
    KOSAPI.sysfunc5(8, 0, 0, id + 80000000H, 0)
END DeleteButton;


PROCEDURE GetTickCount* (): INTEGER;
    RETURN KOSAPI.sysfunc2(26, 9)
END GetTickCount;


PROCEDURE Pause* (time: INTEGER);
BEGIN
    KOSAPI.sysfunc2(5, time)
END Pause;


PROCEDURE ButtonCode* (VAR middle: BOOLEAN): INTEGER;
VAR
    res: INTEGER;
BEGIN
    middle := FALSE;
    res := KOSAPI.sysfunc1(17);
    IF res MOD 256 = 0 THEN
        res := LSR(res, 8)
    ELSIF res MOD 256 = 4 THEN
        res := LSR(res, 8);
        middle := TRUE
    ELSE
        res := 0
    END
    RETURN res
END ButtonCode;


PROCEDURE Exit*;
BEGIN
    KOSAPI.sysfunc1(-1)
END Exit;


PROCEDURE ExitID* (tid: INTEGER);
BEGIN
    KOSAPI.sysfunc3(18, 18, tid)
END ExitID;


PROCEDURE CreateThread* (proc: INTEGER; stack: ARRAY OF INTEGER): INTEGER;
VAR
	tid: INTEGER;
BEGIN
    tid := KOSAPI.sysfunc4(51, 1, proc, SYSTEM.ADR(stack[LEN(stack) - 2]));
    IF tid = -1 THEN
    	tid := 0
    END
    RETURN tid
END CreateThread;


PROCEDURE Run* (program, param: ARRAY OF CHAR);
TYPE

    info_struct = RECORD
        subfunc : INTEGER;
        flags   : INTEGER;
        param   : INTEGER;
        rsrvd1  : INTEGER;
        rsrvd2  : INTEGER;
        fname   : ARRAY 1024 OF CHAR
    END;

VAR
    info: info_struct;

BEGIN
    info.subfunc := 7;
    info.flags   := 0;
    info.param   := SYSTEM.ADR(param[0]);
    info.rsrvd1  := 0;
    info.rsrvd2  := 0;
    COPY(program, info.fname);
    KOSAPI.sysfunc2(70, SYSTEM.ADR(info))
END Run;


PROCEDURE SetCurFolder* (folder: ARRAY OF CHAR);
BEGIN
	KOSAPI.sysfunc3(30, 1, SYSTEM.ADR(folder[0]));
END SetCurFolder;


PROCEDURE DrawRect* (x, y, width, height, color: INTEGER);
BEGIN
    KOSAPI.sysfunc4(13, x*65536 + width, y*65536 + height, color)
END DrawRect;


PROCEDURE DrawLine* (x1, y1, x2, y2: INTEGER; color: INTEGER);
BEGIN
    KOSAPI.sysfunc4(38, x1*65536 + x2, y1*65536 + y2, color)
END DrawLine;


PROCEDURE DrawImage* (data, sizeX, sizeY, x, y: INTEGER);
BEGIN
    KOSAPI.sysfunc4(7, data, sizeX*65536 + sizeY, x*65536 + y)
END DrawImage;


PROCEDURE SetEventsMask* (mask: SET);
BEGIN
    KOSAPI.sysfunc2(40, ORD(mask))
END SetEventsMask;


PROCEDURE SkinHeight* (): INTEGER;
    RETURN KOSAPI.sysfunc2(48, 4)
END SkinHeight;


PROCEDURE GetKey* (): INTEGER;
    RETURN KOSAPI.sysfunc1(2)
END GetKey;


PROCEDURE MouseState* (): SET;
    RETURN BITS(KOSAPI.sysfunc2(37, 3))
END MouseState;


PROCEDURE Scroll* (): INTEGER;
    RETURN ASR(LSL(KOSAPI.sysfunc2(37, 7), 16), 16)
END Scroll;


PROCEDURE GetControlKeys* (): SET;
    RETURN BITS(KOSAPI.sysfunc2(66, 3))
END GetControlKeys;


PROCEDURE GetSystemColors*;
BEGIN
    KOSAPI.sysfunc4(48, 3, SYSTEM.ADR(colors), 40)
END GetSystemColors;


PROCEDURE getKBState* (VAR shift, ctrl: BOOLEAN);
VAR
    kbState: SET;
BEGIN
    kbState := GetControlKeys();
    shift := {0, 1} * kbState # {};
    ctrl := {2, 3} * kbState # {};
END getKBState;


PROCEDURE mouse* (VAR msState: SET; VAR x, y: INTEGER);
VAR
    mouseX, mouseY,
    cliX, cliY,
    winX, winY: INTEGER;
BEGIN
	msState := MouseState();
    MousePos(mouseX, mouseY);
    WinPos(winX, winY);
    ClientPos(cliX, cliY);
    x := mouseX - winX - cliX;
    y := mouseY - winY - cliY
END mouse;


PROCEDURE SetCaption* (text: ARRAY OF CHAR);
BEGIN
	KOSAPI.sysfunc4(71, 2, SYSTEM.ADR(text[0]), 0)
END SetCaption;


PROCEDURE CBCount* (): INTEGER;
	RETURN KOSAPI.sysfunc2(54, 0)
END CBCount;


PROCEDURE CBRead* (slot: INTEGER): INTEGER;
	RETURN KOSAPI.sysfunc3(54, 1, slot)
END CBRead;


PROCEDURE CBWrite* (size, ptr: INTEGER);
BEGIN
	KOSAPI.sysfunc4(54, 2, size, ptr)
END CBWrite;


PROCEDURE CBDelSlot*;
BEGIN
	KOSAPI.sysfunc2(54, 3)
END CBDelSlot;


PROCEDURE GetThreadSlot* (tid: INTEGER): INTEGER;
	RETURN KOSAPI.sysfunc3(18, 21, tid)
END GetThreadSlot;


PROCEDURE PutPixel* (x, y, color: INTEGER);
BEGIN
	KOSAPI.sysfunc5(1, x, y, color, 0)
END PutPixel;


PROCEDURE SetIPC* (buffer: ARRAY OF INTEGER);
BEGIN
	KOSAPI.sysfunc4(60, 1, SYSTEM.ADR(buffer[0]), LEN(buffer)*SYSTEM.SIZE(INTEGER))
END SetIPC;


PROCEDURE SendIPC* (pid, ptr, size: INTEGER);
BEGIN
	KOSAPI.sysfunc5(60, 2, pid, ptr, size)
END SendIPC;


PROCEDURE docpack* (VAR param: ARRAY OF CHAR; VAR text_ptr, text_size: INTEGER);
VAR
	i, size, ptr, ptr2: INTEGER;
	s: ARRAY 32 OF WCHAR;
BEGIN
	ptr2 := 0;
	U.reverse8(param);
	param[LENGTH(param) - 1] := 0X;
	U.reverse8(param);
	i := 0;
	WHILE param[i] # 0X DO
		s[i] := WCHR(ORD(param[i]));
		INC(i)
	END;
	IF U.str2int(s, size) THEN
		INC(size, 20);
		ptr := KOSAPI.malloc(size);
		IF ptr # 0 THEN
			SYSTEM.PUT32(ptr, 0);
			SYSTEM.PUT32(ptr + 4, 8);
			KOSAPI.sysfunc4(60, 1, ptr, size);
			SetEventsMask({6});
			IF EventTimeout(200) = 7 THEN
				SYSTEM.PUT32(ptr, 1);
				SYSTEM.GET(ptr + 12, size);
				ptr2 := KOSAPI.malloc(size);
				IF ptr2 # 0 THEN
					SYSTEM.MOVE(ptr + 16, ptr2, size)
		        END
			END;
			ptr := KOSAPI.free(ptr)
		END
	END;
	text_ptr := ptr2;
	text_size := size
END docpack;


BEGIN
	GetSystemColors
END KolibriOS.