EDITBOX использует макрос macroc.inc в корне директории, также использует файл настроек при
компиляции кода, struct.inc в котором нужно указать правильный тип процессора для вашей
системы!! 


Последняя модификация 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;Структурное описание возможности компонента и моделей его использования.
;;;;;;;;;;;;;;;;;;;;;;;;;;;
  Напишите в исходном коде своей программы use_edit_box,
это вставит необходимые процедуры в код вашей программы.
  Процедуры:
   edit_box.draw - полная перерисовка;
   edit_box.key - обработка клавиатуры;
   edit_box.mouse - обработка мыши;
   edit_box.focus - установка фокуса;
   edit_box.blur - его размывание;
   edit_box.get_n - получить количество прорисовываемых символов.
  При вызове любых из этих процедур в регистре edi следует
оставить указатель на структуру.
  Пример структуры:
some_edit edit_box 100,10,30,0x00ffffff,0,0x00aaaaaa,0,255,some_edit_text
длина, высота, верх, цвет фона, цвет рамки, если выбран,
цвет рамки, если не выбран, максимальное количество символов,
указатель на буфер, где будут хранится символы. Буфер должен
оканчиваться нулем, например если максимальное количество 255:
  some_edit_text:
       rb      256 ;255+1
  Пример вызова процедуры:
       mov     edi,some_edit
       call    edit_box.draw
  При вызове процедуры edit_box.key код клавиши должен
находится в ah, то есть перед вызовом этой процедуры надо вызвать
 2-ую сисемную функцию, например:
       mov     eax,2
       int     0x40
       mov     edi,some_edit1
       call    edit_box.key
       mov     edi,some_edit2
       call    edit_box.key
  Перед вызовом обработчика мыши следует проверить, является ли окно
активным.
  Если щелчок мыши был пройзведен за пределами edit box
фокус теряется.
:::::::::::::::::::::::::
;;;Макросы, и передаваемые им параметры
;;;;;;;;;;;;;;;;;;;;;;;;;
***********
use_edit_box
данный макрос вставляет общий код editbox 
procinfo - указатель на информационную структуру 9 функции - обязательный параметр

Если вы используете при прорисовке окна 
        mcall   0,(50*65536+390),(30*65536+200),0xb3AABBCC,0x805080DD,hed
то 0xb3AABBCC - третий бит - который говорит что координаты отчитывать от клиентской области, вам нужно указать обязательно два этих параметра 
В других случаях передавать эти параметры не нужно
scr_h - не обязательный параметр  обычно 22 
scr_w - не обязательный параметр  обычно 5 
***********
mouse_edit_boxes 
код обработки мышки, вставляется обычно после обработки всех предыдущих событий
Передаваемые параметры
editboxes - указатель на информационную структуру боксов
editboxes_end - конец информационной структуры боксов

Как под вариант существует макрос
mouse_edit_box - он используется если выводится один бокс
Передаваемый параметр
editboxes - указатель на информационную структуру боксов
Больше никаких параметров передавать не нужно.
**********
key_edit_boxes - макрос обработки клавиш боксами, вставляется после того как происходит обработка события что нажата клавиша
Передаваемые параметры
editboxes - указатель на информационную структуру боксов
editboxes_end - конец информационной структуры боксов

Как под вариант существует макрос
key_edit_box - он используется если выводится один бокс
Передаваемый параметр
editboxes - указатель на информационную структуру боксов
Больше никаких параметров передавать не нужно.
**********
draw_edit_boxes - макрос для вывода боксов используется в выводе окна
Передаваемые параметры
editboxes - указатель на информационную структуру боксов
editboxes_end - конец информационной структуры боксов
use_f9 и procinfo - при передаче этого параметра - при перерисовки боксов будет исползована фунция 
mcall   9,procinfo,-1
которая получает данные о окне и складывает параметры по адресу  procinfo- его то же обязательно нужно передавать!!!!
Если в программе уже используется эта функция, то не нужно указывать данные параметр!!!! 

Как под вариант существует макрос
draw_edit_box - он используется если выводится один бокс
Передаваемый параметр
editboxes - указатель на информационную структуру боксов
use_f9 и procinfo - при передаче этого параметра - при перерисовки боксов будет использована функция 
mcall   9,procinfo,-1
которая получает данные о окне и складывает параметры по адресу  procinfo- его то же обязательно нужно передавать!!!!
Если в программе уже используется эта функция, то не нужно указывать данные параметр!!!! 
Больше никаких параметров передавать не нужно.
**********
default_box - макрос который приводит основные данные макроса по дефолту т.е. Снимает битовую матрицу выделения
Специально для KFM :)) Нужно добавить этот код при обработчике yes or no при копировании. Если будет вести себя неадекватно - необходимо раскомментировать строки в данном макросе






Q:
Возникла пара проблем: 
1) Длина максимально набираемого текста ничем не ограничена, в результате при превышении размера буфера затираются данные, которые идут после буфера или код, если он там расположен. 
2) Положение элемента фиксировано, хотелось бы работать с динамически вычисляемыми значениями. Например, если размер окна изменился, а элемент должен располагаться по центру окна всегда.

A:
1) Длина набираемого текста ограничена, вот смотри: 
edit2 edit_box 250,5,30,0xffffff,0,0,0,308,hed,ed_focus,53 - это пример инициализации editbox 
Итак, по порядку: 
Это макрос инициализации структуры 
struc edit_box width,left,top,color,focus_border_color,blur_border_color,text_color,max,text,flags,size 
{ 
.width dd width 
.left dd left 
.top dd top 
.color dd color 
.focus_border_color dd focus_border_color 
.blur_border_color dd blur_border_color 
.text_color dd text_color 
.max dd max 
.text dd text 
.flags dw flags+0 
.size dd size+0 
.pos dd 0 - где будет находиться курсор 
.offset dd 0 
.cl_curs_x dd 0 
.cl_curs_y dd 0 
.shift dd 0 
.shift_old dd 0 
} 
250 - это длинна editbox width 
5 - отступ от левого края left 
30 - отступ с верха top 
0xffffff - цвет внутри editbox 
0x6a9480 - цвет при выделении мышкой или по shift
0 - focus_border_color цвет рамки editbox, когда в фокусе т.е. активен editbox 
0 - blur_border_color цвет рамки editbox, когда в не фокусе т.е. не активен editbox 
0 - text_color цвет текста editbox. 
308 - max максимальное кол-во текста, которое можно ввести (ответ на твой вопрос, обрати внимание на то, что это значение должно быть меньше на 2, чем размер буфера!! Иначе у тебя будут затерты 2 байта следующие после буфера!) 
hed - tex указатель на начало буфера 
ed_focus - флаг(и0 в данном случае установить фокус этому Editbox'у - flags 
53 - текущее значение размера size. его необходимо указывать, если тебе нужно уже отображать существующий текст. Или можно еще сделать так, ты указываешь, буфер с текстом, но тут ничего не пишешь, или 0, тогда, если человек начинает вводить свой, существующий текст уже будет автоматом затерт. 
53 - положение курсора - говорим, что бы он находился в конце строчки на последним символе, больше это значение быть не должно, т.к. иначе глюки :)))
<DATA> - тут расположен сам буфер, + текст. 
hed db 'EDITBOX optimization and retype <Lrz> date 09.03.2007',0 ; итого 54 символа 
rb 256 ; 256+54 =310 у меня указан размер 308 - 2 байта на системные нужды (по идее должно хватать одного, но где - то есть косяк в коде) 

2) Изменять положение при изменении размеров окна. Вообще это не задача editbox, но это достаточно просто сделать, 
.width dd width 
.left dd left 
.top dd top 
Вот часть структуры. 

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
;DATA данные 
editboxes:
edit1 edit_box 168,5,10,0xffffff,0x6a9480,0,0,0,99,ed_buffer.2,ed_figure_only
edit2 edit_box 250,5,30,0xffffff,0x6a9480,0,0xAABBCC,0,308,hed,ed_focus,53,53
edit3 edit_box 35,5,50,0xffffff,0x6a9480,0,0,0,9,ed_buffer.3,ed_figure_only
edit4 edit_box 16,5,70,0xffffff,0x6a9480,0,0,0,1,ed_buffer.4,ed_figure_only
editboxes_end:


А это пример инициализации 
Итак получаем 
lea eax, editboxes - в еах указатель на данные боксов. 
Далее вносим по адресу 
mov dword [eax], новое значение width 
mov dword [eax+4], новое значение left 
mov dword [eax+8], новое значение top 

Это все для первого editbox 
для второго 
add eax,ed_struc_size 
; это размерность в байтах записи длинны одного editbox 
И снова 
mov dword [eax], новое значение width 
mov dword [eax+4], новое значение left 
mov dword [eax+8], новое значение top 
Это уже для второго editbox 

И так далее ))). 
Надеюсь, я для тебя прояснил общий алгоритм изменения
