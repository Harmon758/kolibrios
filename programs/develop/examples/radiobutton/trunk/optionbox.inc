;компонент OptionBox (Основан на Checkbox)
;Огромная благодарность Maxxxx32, Diamond, Heavyiron, и другим программистам, и их программам, без
;которых я не смог бы написать этот компонент. 
;16.02.2007 
;<Lrz>  - Теплов Алексей  www.lrz.land.ru

macro use_option_box
{
op_text_margin=4     ;расстояние от прямоугольника чек бокса до надписи 
op_size=10           ;размер квадрата чек бокса 
op_left equ [edi]    ;координата начала рисования по х
op_top equ [edi+2]   ;координата начала рисования по у
op_border_color equ [edi+4] ;цвет рамки optionbox
op_text_color equ [edi+8]  ;цвет текста
op_text_ptr equ [edi+12]    ;указатель на начало текстовой строки 
op_text_length equ [edi+16] ;длина надписи (2^64 такой длины может быть текст)
op_optibox_gr	equ [edi+18]
option_box:
.draw:
pusha   ;сохраним все регистры
	mov	eax,38     	;рисование линии
	movzx	ebx,word op_left	;положение по х
	mov	ecx,ebx		;сохраним в регистре cx значение bx  1 микрооперация
	;push	bx  ;3 - микрооперации  используя стек можно выиграть в размере, используя регистры - в скорости
	shl	ebx,16		;сдвинем на 16 разрядов в лево (умножим на 65536)
	;pop	bx  ;2 - микрооперации  на данный момент сформирована [координата начала по оси x]*65536 + [координата начала по оси x]
	mov	bx,cx		;восстановим значение bx
	movzx	ecx,word op_top	;загрузим в cx значение y
	mov	esi,ecx		;сохраним значение регистра cx в регистр указатель si				
	;push	cx
	shl	ecx,16		; сдвинем на 16 разрядов в лево (умножим на 65536)	mov	cx,si		;восстановим значение регистра cx
	mov 	cx,si		;восстановим значение регистра cx
	;pop	cx    	;[координата начала по оси y]*65536 + [координата начала по оси y]
	;push	cx       
	add	ecx,op_size ;[координата начала по оси y]*65536 + [координата конца по оси y]
	mov	edx,dword op_border_color ;Цвет линии
	int	0x40   ;рисование вертикальной левой линии квадрата (прямоугольника)
;
	mov	ebp,ebx	;сохраним регистр bx в регистре указателя базы
	;push	bx   ;втолкнуть в bx [координата начала по оси х]*65536 + [координата начала по оси x]
	add	ebx,op_size      ;[координата начала + длина стороны по оси х]
	ror	ebx,16          ;[координата начала + дина стороны по оси х]*65536
	add	ebx,op_size      ;[координата начала+длина стороны по оси х]*65536 + [координата начала+длина стороны по оси x]
	int	0x40
	
	mov	bx,bp		;восстановим значение регистра bx
	;pop	bx
	mov	cx,si		;сохраним значение регистра cx в регистр указатель
	;pop	cx
	int	0x40
	add	ecx,op_size	;добавим размер стороны 
	mov	esi,ecx		;сохраним значение регистра cx в регистр указатель si
	;push	cx
	shl	ecx,16
	mov	cx,si
	;pop	cx
	int	0x40            ;нарисовали прямоугольник

	mov	eax,13          ;закрашиваем его. Функция 13 - нарисовать полосу
	movzx	ebx,word op_left	;загрузить в bx, положение по х
	add	ebx,1		;сдвинем на 1 т.е. прибавим 1 иначе затрется рамка
	shl	ebx,16		;сдвинем на 16 разрядов в лево (умножим на 65536)
	mov	bx,op_size	;прибавим длину стороны прямоугольника
	sub	ebx,1		;вычтем 1 т.к. иначе затрется рамка
	mov	bp,bx		;сохраним регистр bx в регистре указателя базы
	;push	bx
	movzx	ecx,word op_top	;загрузим координаты по y
	add	ecx,1		;сдвинем на 1 т.е. прибавим 1 иначе затрется рамка
	shl	ecx,16		;сдвинем на 16 разрядов в лево (умножим на 65536)
	mov	cx,bp		;восстановим значение регистра cx
	;pop	cx
	mov	edx,dword [sc.work]	;загрузим цвет полосы
	int	0x40            ;закрасили 

        mov	eax,dword op_optibox_gr
	mov	dword eax,[eax]
        cmp	eax,edi
	jne	@f
	call	.draw_op  ;нарисовать включенный чек бокс
;----------------------------
;расчет куда будет произведен вывод текста
;----------------------------
@@:	movzx	ebx,word op_left	;загрузить значение х для чек бокса
	add	ebx,(op_size+op_text_margin) ;добавить размер стороны и расстояние на котором начнется вывод текста
	shl	ebx,16		;сдвинем на 16 разрядов в лево (умножим на 65536)
	mov	bx,op_top	;загрузим значение по y
	add	ebx,(op_size-9+2)	;добавим значение длины стороны -9+2
	mov	ecx,op_text_color	;загрузим цвет надписи
	
	mov	edx,op_text_ptr		;укажем адрес от куда нужно выводить строку
	movzx 	esi,word op_text_length ;Загрузим длину надписи в esi
	;внесем в eax значение вывода надписи на канву
	mov	eax,4
	int	0x40          	;Вывод 
popa				;восстановить значения регистров из стека
ret				;выйдем из процедуры

.clear_op:			;очистка чек бокса
	mov	edx,dword [sc.work]	;цвет внутри чек бокса
	jmp	@f		;безусловный прыжок на нижнюю метку @@

.draw_op:            ;нарисовать включенный чек бокс
	mov	edx,op_border_color	;загрузить цвет
@@:
	movzx	ebx,word op_left	;загрузить координату по х
	add	ebx,(op_size/3)	;добавить (сторона прямоугольника/3)
	shl	ebx,16		;сдвинем на 16 разрядов в лево (умножим на 65536)
	mov	bx,(op_size/2)	;загрузить (сторона прямоугольника/2)
	mov	bp,bx		;сохраним регистр bx в регистре указателя базы
	;push	bx
	movzx	ecx,word op_top	;загрузить координату по у
	mov	eax,13		;в eax - значения функции для вывода полосы т.е. по сути прямоугольника, который отображает включенный компонент чек бокс
	add	ecx,(op_size/3)	;добавить (сторона прямоугольника/3)
	shl	ecx,16		;сдвинем на 16 разрядов в лево (умножим на 65536)
	mov	cx,bp		;загрузим значения регистра указателя базы в cx
	;pop	cx
	int	0x40		;вывод
ret				;выйти из процедуры

.mouse:                 ;обработка мыши 
pusha
	mov	eax,37   	;будем что то делать если у нас что - нить нажато
	mov	ebx,2		;внести в регистр значение 2
	int	0x40		;проверка не нажал ли пользователь кнопку мышки
	test	eax,eax    ;проверка если у нас в eax=0, то установим флаг и выйдем
	jnz	@f         ;перейти на нижнюю метку @@
	popa			;если ничего не произошло, то восстановим значения регистров из стека
	ret                     ;выход
@@:
	movzx	esi,word op_text_length ;загрузить кол-во символов в текстовой строке
	;Умножение на 6 Быстрое умножение можно воспользоваться любым мз методов, но на старых Процессорах (386,486,P1)быстрее будет с инструкцией Lea
	;lea	esi,[eax*2+eax]
	;shl	eax,1
	imul	esi,6               ; или можно и так умножить на 6
	xor	ebx,ebx
        add	esi,op_text_margin   ;добавить 3 - расстояние от чек бокса до надписи
	
	mov	eax,37		;получим координаты мышки 
	inc	ebx		;добавить 1
	int	0x40                ;получить координаты курсора относительно окна 

	movzx	ebx,word op_top           ;загрузить в bx значение координаты у
	cmp	ax,bx               ;сравнить с с координатой курсора
	jl	.mouse_end          ;SF <> OF если меньше 
	add	ebx,op_size          ;добавить размер 
	cmp	ax,bx               ;сравнить
	jg	.mouse_end          ;ZF = 0 и SF = OF если больше 
	
	shr	eax,16              ;разделим на 65536 или просто сдвинем биты на 16 значений
	movzx	ebx,word op_left          ;произведем аналогичное сравнение
	cmp	ax,bx		     ;сравнить регистры
	jl	.mouse_end	     ;если меньше
	add	ebx,op_size	     ;добавить длину стороны прямоугольника
	add	ebx,esi		     ;Учесть в значении по х еще и длину надписи к чекбоксу
	cmp	ax,bx		     ;стравнить регистры
	jg	.mouse_end	     ;если больше 
	mov	eax,dword op_optibox_gr
        mov	[eax],edi

.mouse_end:
popa				  ;восстановить регистры из стека
ret				  ;выйти
}

struc option_box left,top,border_color,text_color,text,text_length,point_gr,flags
{	;структура параметров для чек бокса
.left: dw left	;+0	;положение по х
.top: dw top	;+2	;положение по у
.border_color: dd border_color ;+8	цвет рамки 
.text_color: dd text_color     ;+12	цвет текста надписи
.text: dd text	     ;+16		адрес в коде программы где расположен текстр
.text_length: dw text_length ; +20	длина текста
.option_group: dd point_gr	;указатель на размещение edi - идентификатора optibox
}
op_struc_size=22			;общая структура 24 байт
op_flag_en=10b
macro draw_option_boxes start,end	;рисовать чек боксы
{
	mov	edi,start			;Указатель на начало данных чек боксов т.е. на начало данных первого чекбокса
	mov	ecx,((end-start)/op_struc_size) ;Количество чек боксов
@@:
	call	option_box.draw                  ;Отобразить чек бокс
	add	edi,op_struc_size               ;Указатель на последующие чек боксы  т.е. +28
	loop	@b	;прыгнуть если в ecx/cx значение не 0 на верхнюю @@
}
macro mouse_option_boxes start,end	;установка чек боксов, в зависимости от события
{
	mov	edi,start		; Указатель на начало данных чек боксов т.е. на начало данных первого чекбокса
	mov	ecx,((end-start)/op_struc_size)	;Количество чек боксов
@@:
	call	option_box.mouse		;проверка мышки и обработка событий
	add	edi,op_struc_size	;Указатель на последующие чек боксы
	loop	@b	;прыгнуть если в ecx/cx значение не 0 на верхнюю @@

       	mov	edi,start		; Указатель на начало данных чек боксов т.е. на начало данных первого чекбокса
	mov	ecx,((end-start)/op_struc_size)	;Количество чек боксов

.home:
	mov	eax,[edi+18]	;op_optibox_gr
        mov	dword eax,[eax]

        pusha

	cmp	eax,edi
	jne	@f
	
	call	option_box.draw_op
	jmp	.nxtm
@@:     call	option_box.clear_op

.nxtm:  popa
	add	edi,op_struc_size               ;Указатель на последующие чек боксы  т.е. +28
        loop 	.home

}