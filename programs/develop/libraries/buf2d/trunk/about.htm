<html>
<head>
<title>библиотека для работы с 2d буферами</title>
<meta http-equiv="content-type" content="text/html; charset=WINDOWS-1251">
<style>
body
{
  font-size: 15px;
  font-family: "Bookman Old Style";
  color: black;
  text-align: justify;
}
h1 { color: green; font-size: 23px; }
h2 { color: green; font-size: 21px; }
h3 { color: green; font-size: 19px; }
h4 { color: #803f00; font-size: 17px; }
i { color: #0099cc; }
b { color: #0099cc; }
p {
  text-indent: 1em;
  margin-top: 3px;
  margin-bottom: 2px;
  margin-left: 0px;
  margin-right: 0px;
}
ol, ul, dl{
  margin-top: 3px;
  margin-bottom: 2px;
}
pre
{
  padding: 2px;
  padding-left: 20px;
  margin-top: 5px;
  margin-bottom: 5px;
  margin-left: 0px;
  margin-right: 0px;
  font-family: "Courier New";
  font-size: 15px;
  color: #004000;
  background-color: #ffd0ff;
}
table { font-size: 15px; }
</style>
</head>

<body>

<h1>Оглавление</h1>
<ul>
<li>Вступление</li>
<li><a href="#format_buf">Форматы буферов</a></li>
<li><a href="#fun">Функции</a><br>
<ul>
<li><a href="#f_init">lib_init</a></li>
<li><a href="#f_b_create">buf2d_create</a></li>
<li><a href="#f_v_brush_c">buf2d_vox_brush_create</a></li>
</ul>
</li>
<li><a href="#const">Константы</a></li>
<li><a href="#tabl_e">Таблица экспорта</a></li>
<li><a href="#hist">История</a></li>
</ul>

<h1>Вступление</h1>
<p>Документация к свободной библиотеке <b>buf2d.asm</b>, для <b>ОС Колибри</b>.
 Эта библиотека создана для работы с 2d изображениями.
 С ее помощью можно создавать буфера с изображениями в памяти, и при необходимости выводить их на экран.
 Изображения можно накладывать одно на другое, поддерживается работа с прозрачными изображениями.
 Есть функции рисования линий, кривых Безье, прямоугольников, окружностей.
 Также есть функции для рисований воксельной графики.</p>

<p>Последнее обновление библиотеки 12.06.12.</p>

<h1><a name="format_buf">Форматы буферов</a></h1>
<p>Поддерживается 3 формата буферов.
 Каждая функция при работе с буферами может быть расчитана на работу с определенными форматами изображений.</p>

<h4>8 бит</h4>
<p>Сожержит альфа канал <b>a</b> (прозрачность) изображения. На экран не выводится. Используется для созданя 32-битных буферов.</p>
<h4>24 бит</h4>
<p>Данный буфер содержит изображение в формате <b>rgb</b>. Может выводится на экран.</p>
<h4>32 бит</h4>
<p>Содержит прозрачное изображение в формате <b>rgba</b>. На экран не выводится. Используется для наложения изображений.</p>

<h1><a name="fun">Функции</a></h1>

<p>Почти все функции 1-м параметром принимают указатель на структуру буфера,
 из которой могут использоваться параметры, нужные для работы конкретной функции.
 Пример структуры буфера изображения:</p>
<pre>align 4
buf_0:
	dd    0 ;+ 0 указатель на буфер изображения
	dw  100 ;+ 4 отступ слева
	dw   10 ;+ 6 отступ справа
	dd  150 ;+ 8 ширина
	dd  100 ;+12 высота
	dd 0x80 ;+16 фоновый цвет
	db   24 ;+20 бит на пиксель</pre>

<h4><a name="f_init">lib_init</a></h4>
<p>Эта функция получает указатели на функции работы с памятью, вызыватся должна при загрузке библиотеки. Можете использовать макрос <b>@use_library_mem</b>, для ее автоматической настройки.</p>

<h4><a name="f_b_create">buf2d_create</a></h4>
<p>Создает буфер и чистит его фоновым цветом. Пример:</p>
<pre>stdcall [buf2d_create], buf_0</pre>
<p>где buf_0 - структура буфера.</p>
<p>Параметры для создания буфера берутся из структуры.</p>

<h4>buf2d_create_f_img</h4>
<p>Создает буфер на основе изображения в формате <b>rgb</b>.</p>

<h4>buf2d_clear</h4>
<p>Чистит буфер указаным цветом. Пример:</p>
<pre>buf2d_color equ dword[edi+16] ;цвет фона буфера
mov edi,buf_0
stdcall [buf2d_clear], edi, buf2d_color ;очищаем экран фоновым цветом</pre>
<p>где buf_0 - структура буфера.</p>

<h4>buf2d_draw</h4>
<p>Рисует буфер на экране (работает через системную ф. 7). Рисуются только буфера с глубиной цвета 24 бита.</p>

<h4>buf2d_delete</h4>
<p>Освобождает память занятую изображением буфера.</p>

<h4>buf2d_resize</h4>
<p>Изменяет размеры буфера. Пока поддерживаются буфера с глубиной цвета 24 бита. Пример:</p>
<pre>stdcall [buf2d_resize], buf_0, 0,300 ;изменяем высоту буфера</pre>
<p>где buf_0 - структура буфера в котором будет рисоваться линия; 0 - новая ширина буфера (0 означает не изменять размер); 300 - новая высота буфера.</p>

<h4>buf2d_line</h4>
<p>Рисует в буфере линию с заданным цветом и координатами. Пример:</p>
<pre>stdcall [buf2d_line], buf_0, 30,10, 110,70, 0xffff00 ;рисуем линию</pre>
<p>где buf_0 - структура буфера в котором будет рисоваться линия; 30, 10, 110, 70 - координаты линии; 0xffff00 - цвет линии.</p>
<p>Для рисования сглаженной линии используйте <b>buf2d_line_sm</b>.</p>

<h4>buf2d_line_sm</h4>
<p>Рисует в буфере линию принимает такиже параметры как и функция <b>buf2d_line</b>. Данная функция рисует сглаженную линию более красивую чем <b>buf2d_line</b>, но работает медленнее неё за счет вычисления смешанных цветов фона и самой линии.</p>

<h4>buf2d_rect_by_size</h4>
<p>Рисует прямоугольную рамку, по двум координатам, 2-я координата задана по размеру. Если размеры отрицательные рамка рисуется в обратном направлении.</p>
<pre>stdcall [buf2d_rect_by_size], buf_0, 10,10,150,100, 0x8080</pre>
<p>где buf_0 - структура буфера в котором будет рисоваться прямоугольник; 10, 10 - координаты левого верхнего угла (при отрицательных размерах координата правого нижнего); 150, 100 - размер прямоугольника; 0x8080 - цвет линии.</p>

<h4>buf2d_filled_rect_by_size</h4>
<p>Рисует закрашенный прямоугольник, по двум координатам, 2-я координата задана по размеру. Если размер задать 1*1, то будет нарисована точка размером в 1 пиксель, т.е. размер прямоугольника в пикселях будет равен указанному. Если размеры отрицательные прямоугольник рисуется в обратном направлении.</p>
<pre>stdcall [buf2d_rect_by_size], buf_0, 10,10,150,100, 0x8080</pre>
<p>где buf_0 - структура буфера в котором будет рисоваться прямоугольник; 10, 10 - координаты левого верхнего угла (при отрицательных размерах координата правого нижнего); 150, 100 - размер прямоугольника; 0x8080 - цвет прямоуголика.</p>

<h4>buf2d_circle</h4>
<p>Рисует в буфере окружность с заданным цветом и радиусом. Пример:</p>
<pre>stdcall [buf2d_circle], buf_0, 25, 70, 15, 0xff0000</pre>
<p>где buf_0 - структура буфера в котором будет рисоваться окружность; 25, 70 - координаты центра; 15 - радиус; 0xff0000 - цвет.</p>

<h4>buf2d_img_hdiv2</h4>
<p>Сжимает изображение в буфере по высоте в 2 раза, при этом размер самого буфера не уменьшается.</p>

<h4>buf2d_img_wdiv2</h4>
<p>Сжимает изображение в буфере по ширине в 2 раза, при этом размер самого буфера не уменьшается.</p>

<h4>buf2d_conv_24_to_8</h4>
<p>Преобразование буфера из 24-битного в 8-битный.
 При преобразовании указывается какой цвет берать: 0-синий, 1-зеленый, 2-красный.
 Остальные цвета при преобразовании теряются.</p>

<h4>buf2d_conv_24_to_32</h4>
<p>Преобразование буфера из 24-битного в 32-битный.
 При преобразовании указывается также 8-битный буфер, который будет использован для создания альфа канала. Пример:</p>
<pre>stdcall [buf2d_conv_24_to_32],buf_a,buf_b ;делаем буфер rgba 32бит</pre>
<p>До выполнения функции буфер buf_a должен быть 24 битным, а буфер buf_b - 8 битным.
 После выполнения функции буфер buf_a станет 32 битным, буфер buf_b не изменится.</p>

<h4>buf2d_bit_blt</h4>
<p>Рисует в буфере изображение из другого буфера в указанных координатах. Буфер в котором рисут (приемник) должен быть 24 битным, а тот который рисуется (источник) 24 или 32 битным. Если буфер источник 32 битный, то его прозрачность при рисовании не учитывается, для учета прозрачности используется функция <i>buf2d_bit_blt_transp</i>. Пример:</p>
<pre>stdcall [buf2d_bit_blt], buf_0, 50,30, buf_1 ;прорисовка среднего скина</pre>
<p>где buf_0 - структура буфера в котором будет рисоваться изображение (приемник);
  buf_1 - структура буфера с рисуемым изображением (источник);
  50,30 - координаты для вывода изображения, определяют положение рисуемой картинки в buf_0.</p>

<h4>buf2d_bit_blt_transp</h4>
<p>Рисует в буфере изображение из другого буфера в указанных координатах, при этом учитывается прозрачность.
 Буфер который будет нарисован должен быть 32 битным, а тот в котором рисуют 24 битным.</p>

<h4>buf2d_bit_blt_alpha</h4>
<p>Рисует в буфере изображение из другого буфера в указанных координатах, при этом учитывается прозрачность.
 Буфер который будет нарисован должен быть 8 битным, а тот в котором рисуют 24 битным.</p>

<h4>buf2d_curve_bezier</h4>
<p>Рисует по трем точкам отрезок кривой безье.</p>
<pre>stdcall [buf2d_curve_bezier], buf_0, (10 shl 16)+20,(110 shl 16)+10,(50 shl 16)+90, dword 0xff</pre>
<p>где buf_0 - структура буфера в котором будет рисоваться кривая;
  (10 shl 16)+20,(110 shl 16)+10,(50 shl 16)+90 - координаты точек (10,20), (110,10), (50,90);
  0xff - цвет прямой.</p>

<h4>buf2d_convert_text_matrix</h4>
<p>Преобразует матрицу с текстом размером 16*16 в размер 1*256. Необходимо для создания матрицы для рисования текста. Перед использованием данной функции предполагается что есть изображение с полным набором символов размером 16 столбцов на 16 строк, из которого предварительно был создан 8 битный буфер.</p>
<pre>stdcall [buf2d_create_f_img], buf_1,[image_data] ;создаем буфер 24 бит на основе данных изображения
stdcall [buf2d_conv_24_to_8], buf_1,1 ;делаем буфер прозрачности 8 бит
stdcall [buf2d_convert_text_matrix], buf_1</pre>
<p>где buf_1 - структура буфера для формирования текстовой матрицы;
  image_data - данные изображения текстовой матрицы в формате rgb, размером 16*16 символов.</p>

<h4>buf2d_draw_text</h4>
<p>Рисует текст в буфере, используя матрицу с текстом размером 1*256 символов. Пример:</p>
<pre>stdcall [buf2d_draw_text], buf_0, buf_1,some_text,20,10,0x4040ff ;рисуем строку с текстом</pre>
<p>где buf_0 - структура буфера в котором будет рисоваться текст;
  buf_1 - структура буфера с текстовой матрицей в формате 8 бит, размером 1*256 символов;
  some_text - текст, который будет выведен в буфер buf_0.</p>

<h4>buf2d_crop_color</h4>
<p>Обрезание буфера, по указанному цвету. Функция используется для уменьшения памяти, занимаемой буфером. Отрезаются крайние части буфера имеющие одинаковый цвет. Пример:</p>
<pre>stdcall [buf2d_crop_color], buf_0,0xffffff,BUF2D_OPT_CROP_TOP+BUF2D_OPT_CROP_BOTTOM</pre>
<p>где buf_0 - структура буфера который будет обрезан;
  0xffffff - цвет по которому будет обрезаться буфер;
  BUF2D_OPT_CROP_TOP и BUF2D_OPT_CROP_BOTTOM - константы, указывающие с каких сторон обрезать буфер.</p>

<h4>buf2d_offset_h</h4>
<p>Сдвиг изображения в буфере по высоте вверх или вниз.</p>

<h4>buf2d_flood_fill</h4>
<p>Функция для рекурсивной заливки выбранным цветом. Имеется два варианта заливки. Пример:</p>
<pre>stdcall [buf2d_flood_fill], buf_0, 100,200, 0, 0xff,0xff0000</pre>
<p>где buf_0 - структура буфера;
  100,200 - координаты точки, с которой начнется заливка;
  0 - параметр, определяет алгоритм заливки (может быть 0 или 1);
  0xff - цвет заливки;</p>
  0xff0000 - зависит от значения 4-го параметра, 1) если 0 - цвет до которого будет заливаться область; 2) если 1 - цвет области которая будет заливатся;</p>

<h4>buf2d_set_pixel</h4>
<p>Функция ставит точку, принимает координаты и цвет.</p>
<pre>stdcall [buf2d_set_pixel], buf_0, 100,150, 0xff0000</pre>
<p>где buf_0 - структура буфера;</p>
<p>100,150 - координаты точки;</p>
<p>0xff0000 - цвет точки.</p>

<h4>buf2d_get_pixel</h4>
<p>Функция записывает цвет точки в регистр eax, принимает координаты.</p>
<pre>stdcall [buf2d_get_pixel], buf_0, 100,150</pre>
<p>где buf_0 - структура буфера;</p>
<p>100,150 - координаты точки;</p>
<p>eax - цвет точки (для 8 и 24 битных буферов не используемые старшие биты в eax равны 0) или значение -1 в случае ошибки.</p>

<h4><a name="f_v_brush_c">buf2d_vox_brush_create</a></h4>
<p>Создание воксельной кисти.</p>

<h4>buf2d_vox_brush_delete</h4>
<p>Удаление воксельной кисти.</p>

<h4>buf2d_vox_obj_get_img_w_3g</h4>
<p>Возврашает ширину воксельного изображения с 3-мя гранями (которое рисуется функцией <b>buf2d_vox_obj_draw_3g</b>), принимает указатель на кисть и масштаб.</p>

<h4>buf2d_vox_obj_get_img_h_3g</h4>
<p>Возврашает высоту воксельного изображения с 3-мя гранями (которое рисуется функцией <b>buf2d_vox_obj_draw_3g</b>), принимает указатель на кисть и масштаб.</p>

<h4>buf2d_vox_obj_draw_3g</h4>
<p>Рисование воксельного объекта с 3-мя гранями.</p>

<h4>buf2d_vox_obj_draw_3g_scaled</h4>
<p>Рисование части воксельного объекта.</p>

<h4>buf2d_vox_obj_draw_3g_shadows</h4>
<p>Функция рисующая тени для изображений нарисованных с помощью функции <b>buf2d_vox_obj_draw_3g</b> или <b>buf2d_vox_obj_draw_3g_scaled</b>.</p>

<h4>buf2d_vox_obj_draw_pl</h4>
<p>Функция рисующая срез воксельного обьекта.</p>

<h4>buf2d_vox_obj_draw_pl_scaled</h4>
<p>Функция рисующая срез части воксельного обьекта.</p>

<h1><a name="const">Константы</a></h1>
<h4>BUF2D_OPT_CROP_TOP equ 1</h4>
<p>Константа для функции buf2d_crop_color, обозначает обрезку буфера сверху</p>
<h4>BUF2D_OPT_CROP_LEFT equ 2</h4>
<p>Константа для функции buf2d_crop_color, обозначает обрезку буфера слева</p>
<h4>BUF2D_OPT_CROP_BOTTOM equ 4</h4>
<p>Константа для функции buf2d_crop_color, обозначает обрезку буфера снизу</p>
<h4>BUF2D_OPT_CROP_RIGHT equ 8</h4>
<p>Константа для функции buf2d_crop_color, обозначает обрезку буфера справа</p>

<h1><a name="tabl_e">Таблица экспорта</a></h1>
<p>Пример таблицы экспорта, расчитанной на использование макроса <b>@use_library_mem</b>:</p>
<pre>align 4
import_buf2d_lib:
	dd sz_lib_init
	buf2d_create dd sz_buf2d_create
	buf2d_create_f_img dd sz_buf2d_create_f_img
	buf2d_clear dd sz_buf2d_clear
	buf2d_draw dd sz_buf2d_draw
	buf2d_delete dd sz_buf2d_delete
	buf2d_resize dd sz_buf2d_resize
	buf2d_line dd sz_buf2d_line
	buf2d_line_sm dd sz_buf2d_line_sm
	buf2d_rect_by_size dd sz_buf2d_rect_by_size
	buf2d_filled_rect_by_size dd sz_buf2d_filled_rect_by_size
	buf2d_circle dd sz_buf2d_circle
	buf2d_img_hdiv2 dd sz_buf2d_img_hdiv2
	buf2d_img_wdiv2 dd sz_buf2d_img_wdiv2
	buf2d_conv_24_to_8 dd sz_buf2d_conv_24_to_8
	buf2d_conv_24_to_32 dd sz_buf2d_conv_24_to_32
	buf2d_bit_blt dd sz_buf2d_bit_blt
	buf2d_bit_blt_transp dd sz_buf2d_bit_blt_transp
	buf2d_bit_blt_alpha dd sz_buf2d_bit_blt_alpha
	buf2d_curve_bezier dd sz_buf2d_curve_bezier
	buf2d_convert_text_matrix dd sz_buf2d_convert_text_matrix
	buf2d_draw_text dd sz_buf2d_draw_text
	buf2d_crop_color dd sz_buf2d_crop_color
	buf2d_offset_h dd sz_buf2d_offset_h
	buf2d_flood_fill dd sz_buf2d_flood_fill
	buf2d_set_pixel dd sz_buf2d_set_pixel
	buf2d_get_pixel dd sz_buf2d_get_pixel

	;воксельные функции:
	buf2d_vox_brush_create dd sz_buf2d_vox_brush_create
	buf2d_vox_brush_delete dd sz_buf2d_vox_brush_delete
	buf2d_vox_obj_get_img_w_3g dd sz_buf2d_vox_obj_get_img_w_3g
	buf2d_vox_obj_get_img_h_3g dd sz_buf2d_vox_obj_get_img_h_3g
	buf2d_vox_obj_draw_3g dd sz_buf2d_vox_obj_draw_3g
	buf2d_vox_obj_draw_3g_scaled dd sz_buf2d_vox_obj_draw_3g_scaled
	buf2d_vox_obj_draw_3g_shadows dd sz_buf2d_vox_obj_draw_3g_shadows
	buf2d_vox_obj_draw_pl dd sz_buf2d_vox_obj_draw_pl
	buf2d_vox_obj_draw_pl_scaled dd sz_buf2d_vox_obj_draw_pl_scaled

	dd 0,0
	sz_lib_init db 'lib_init',0
	sz_buf2d_create db 'buf2d_create',0
	sz_buf2d_create_f_img db 'buf2d_create_f_img',0
	sz_buf2d_clear db 'buf2d_clear',0
	sz_buf2d_draw db 'buf2d_draw',0
	sz_buf2d_delete db 'buf2d_delete',0
	sz_buf2d_resize db 'buf2d_resize',0
	sz_buf2d_line db 'buf2d_line',0
	sz_buf2d_line_sm db 'buf2d_line_sm',0
	sz_buf2d_rect_by_size db 'buf2d_rect_by_size',0
	sz_buf2d_filled_rect_by_size db 'buf2d_filled_rect_by_size',0
	sz_buf2d_circle db 'buf2d_circle',0
	sz_buf2d_img_hdiv2 db 'buf2d_img_hdiv2',0
	sz_buf2d_img_wdiv2 db 'buf2d_img_wdiv2',0
	sz_buf2d_conv_24_to_8 db 'buf2d_conv_24_to_8',0
	sz_buf2d_conv_24_to_32 db 'buf2d_conv_24_to_32',0
	sz_buf2d_bit_blt db 'buf2d_bit_blt',0
	sz_buf2d_bit_blt_transp db 'buf2d_bit_blt_transp',0
	sz_buf2d_bit_blt_alpha db 'buf2d_bit_blt_alpha',0
	sz_buf2d_curve_bezier db 'buf2d_curve_bezier',0
	sz_buf2d_convert_text_matrix db 'buf2d_convert_text_matrix',0
	sz_buf2d_draw_text db 'buf2d_draw_text',0
	sz_buf2d_crop_color db 'buf2d_crop_color',0
	sz_buf2d_offset_h db 'buf2d_offset_h',0
	sz_buf2d_flood_fill db 'buf2d_flood_fill',0
	sz_buf2d_set_pixel db 'buf2d_set_pixel',0
	sz_buf2d_get_pixel db 'buf2d_get_pixel',0

	;воксельные функции:
	sz_buf2d_vox_brush_create db 'buf2d_vox_brush_create',0
	sz_buf2d_vox_brush_delete db 'buf2d_vox_brush_delete',0
	sz_buf2d_vox_obj_get_img_w_3g db 'buf2d_vox_obj_get_img_w_3g',0
	sz_buf2d_vox_obj_get_img_h_3g db 'buf2d_vox_obj_get_img_h_3g',0
	sz_buf2d_vox_obj_draw_3g db 'buf2d_vox_obj_draw_3g',0
	sz_buf2d_vox_obj_draw_3g_scaled db 'buf2d_vox_obj_draw_3g_scaled',0
	sz_buf2d_vox_obj_draw_3g_shadows db 'buf2d_vox_obj_draw_3g_shadows',0
	sz_buf2d_vox_obj_draw_pl db 'buf2d_vox_obj_draw_pl',0
	sz_buf2d_vox_obj_draw_pl_scaled db 'buf2d_vox_obj_draw_pl_scaled',0</pre>

<h1><a name="hist">История</a></h1>
<p>02.07.10 - самая первая версия библиотеки, 2 примера использования.</p>
<p>06.07.10 - расширены возможности функции buf2d_bit_blt, теперь она может рисовать 32 битные буферы. Добавлены 2 новые функции: buf2d_bit_blt_alpha и buf2d_cruve_bezier. Небольшие изменения в функции buf2d_line.</p>
<p>16.07.10 - исправлено по 2 ошибки в функциях buf2d_img_hdiv2 и buf2d_img_wdiv2, которые могли проявляться при определенных условиях (если размер изображения был кратен 4Кб и др.). Добавлены 2 функции для вывода текста в буфер buf2d_convert_text_matrix и buf2d_draw_text.</p>
<p>19.07.10 - добавлена функция рисования окружности buf2d_circle;
 изменен формат буфера - для ширины и высоты используются 4-х байтные числа вместо 2-х байтных.</p>
<p>29.07.10 - добавлены функции buf2d_crop_color и buf2d_offset_h;
 исправления в функции buf2d_delete.</p>
<p>30.09.10 - добавлена функция buf2d_rect_by_size.</p>
<p>04.10.10 - добавлена функция buf2d_filled_rect_by_size, доработана функция buf_bit_blt_alpha.</p>
<p>07.10.10 - доработана функция buf_bit_blt (при попытке нарисовать изображение за пределами правого края буфера приложение вызвавшее функцию падало).</p>
<p>11.10.10 - исправлено задание цветов в некоторых функциях, красный и синий цвета поменял местами. Теперь цвета совпадают с сисемными функциями.</p>
<p>02.11.10 - добавлена функция buf2d_flood_fill.</p>
<p>22.12.10 - изменено имя функции buf2d_cruve_bezier на buf2d_curve_bezier.</p>
<p>25.03.11 - добавлена функция для рисования точки buf2d_set_pixel.</p>
<p>30.08.11 - добавлена функция изменения размеров буфера buf2d_resize.</p>
<p>13.09.11 - оптимизирована работа функций buf2d_filled_rect_by_size buf2d_rect_by_size, добавлены примеры использования библиотеки.</p>
<p>22.09.11 - добавлена функция buf2d_line_sm для рисования сглаженной линии.</p>
<p>20.02.12 - функции buf2d_filled_rect_by_size и buf2d_rect_by_size могут принимать отрицательные размеры для прямоугольников, в функции buf2d_line горизонтальная линия рисуется на 1 пиксель длинее (раньше не дорисовывало), некоторые функции могут рисовать в 8 битных буферах.</p>
<p>23.02.12 - функция buf2d_bit_blt_alpha может принимать отрицательные координаты в позиции копируемого буфера, небольшие доработки в buf2d_bit_blt_transp</p>
<p>11.05.12 - добавлена функция для взятия цвета точки buf2d_get_pixel, доработки в buf2d_set_pixel.</p>
<p>12.06.12 - добавлены функции для рисования воксельной графики.</p>
</body>
</html>