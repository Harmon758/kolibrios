Index: libavcodec/utils.c
===================================================================
--- libavcodec/utils.c	(revision 25603)
+++ libavcodec/utils.c	(working copy)
@@ -1071,27 +1071,33 @@
  * and opened file name in **filename. */
 int av_tempfile(char *prefix, char **filename) {
     int fd=-1;
-#if !HAVE_MKSTEMP
-    *filename = tempnam(".", prefix);
-#else
+//#if !defined(HAVE_MKSTEMP)
+//    *filename = tempnam(".", prefix);
+//#else
     size_t len = strlen(prefix) + 12; /* room for "/tmp/" and "XXXXXX\0" */
     *filename = av_malloc(len);
-#endif
+//#endif
     /* -----common section-----*/
     if (*filename == NULL) {
         av_log(NULL, AV_LOG_ERROR, "ff_tempfile: Cannot allocate file name\n");
         return -1;
     }
-#if !HAVE_MKSTEMP
+//#if !defined(HAVE_MKSTEMP)
+//    fd = open(*filename, O_RDWR | O_BINARY | O_CREAT, 0444);
+//#else
+
+//    snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
+//    fd = mkstemp(*filename);
+//    if (fd < 0) {
+//        snprintf(*filename, len, "./%sXXXXXX", prefix);
+//        fd = mkstemp(*filename);
+//   }
+
+
+    snprintf(*filename, len, "%sXXXXXX", prefix);
     fd = open(*filename, O_RDWR | O_BINARY | O_CREAT, 0444);
-#else
-    snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
-    fd = mkstemp(*filename);
-    if (fd < 0) {
-        snprintf(*filename, len, "./%sXXXXXX", prefix);
-        fd = mkstemp(*filename);
-    }
-#endif
+
+//#endif
     /* -----common section-----*/
     if (fd < 0) {
         av_log(NULL, AV_LOG_ERROR, "ff_tempfile: Cannot open temporary file %s\n", *filename);
Index: libavcodec/vorbis.c
===================================================================
--- libavcodec/vorbis.c	(revision 25603)
+++ libavcodec/vorbis.c	(working copy)
@@ -23,6 +23,7 @@
 #undef V_DEBUG
 //#define V_DEBUG
 
+#include <math.h>
 #define ALT_BITSTREAM_READER_LE
 #include "avcodec.h"
 #include "get_bits.h"
Index: libavformat/avio.c
===================================================================
--- libavformat/avio.c	(revision 25603)
+++ libavformat/avio.c	(working copy)
@@ -174,7 +174,7 @@
             if (fast_retries)
                 fast_retries--;
             else
-                usleep(1000);
+                /*usleep(1000)*/;
         } else if (ret < 1)
             return ret < 0 ? ret : len;
         if (ret)
Index: libswscale/swscale.c
===================================================================
--- libswscale/swscale.c	(revision 25603)
+++ libswscale/swscale.c	(working copy)
@@ -1834,7 +1834,7 @@
  * swscale wrapper, so we don't need to export the SwsContext.
  * Assumes planar YUV to be in YUV order instead of YVU.
  */
-int sws_scale(SwsContext *c, const uint8_t* const src[], const int srcStride[], int srcSliceY,
+int sws_scale(SwsContext *c, uint8_t* src[], const int srcStride[], int srcSliceY,
               int srcSliceH, uint8_t* const dst[], const int dstStride[])
 {
     int i;
Index: libswscale/swscale.h
===================================================================
--- libswscale/swscale.h	(revision 25603)
+++ libswscale/swscale.h	(working copy)
@@ -192,7 +192,7 @@
  *                  the destination image
  * @return          the height of the output slice
  */
-int sws_scale(struct SwsContext *context, const uint8_t* const srcSlice[], const int srcStride[],
+int sws_scale(struct SwsContext *context, uint8_t* srcSlice[], const int srcStride[],
               int srcSliceY, int srcSliceH, uint8_t* const dst[], const int dstStride[]);
 #if LIBSWSCALE_VERSION_MAJOR < 1
 /**
Index: libswscale/utils.c
===================================================================
--- libswscale/utils.c	(revision 25603)
+++ libswscale/utils.c	(working copy)
@@ -24,6 +24,8 @@
 #include <math.h>
 #include <stdio.h>
 #include "config.h"
+#undef HAVE_VIRTUALALLOC
+#define HAVE_VIRTUALALLOC 0
 #include <assert.h>
 #if HAVE_SYS_MMAN_H
 #include <sys/mman.h>
