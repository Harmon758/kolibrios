#startaddress 0
#code32 TRUE

char   os_name[8]   = {'M','E','N','U','E','T','0','1'};
dword  os_version   = 0x00000001;
dword  start_addr   = #main;
dword  final_addr   = #stop+32;
dword  alloc_mem    = #stop+0x100;
dword  x86esp_reg   = #stop+0x100;
dword  I_Param      = 0x0;
dword  I_Icon       = 0x0;
dword    skin_width;

//Events
#define evMouse 6
#define evButton  3
#define evKey     2
#define evReDraw  1
#define evNet   8

//Button options
#define BT_DEL          0x80000000
#define BT_HIDE         0x40000000
#define BT_NOFRAME      0x20000000

#define OLD                     -1
#define true            1
#define false           0

struct FileInfo{
 dword read, firstBlock, qnBlockRead, retPtr, Work;
 byte  filedir;
};
//-------------------------------------------------------------------------
struct system_colors{
        dword frame,grab,grab_button,grab_button_text,grab_text,work,work_button,work_button_text,work_text,work_graph;
        void get();
};
void system_colors::get()
{
        EAX = 48;
        EBX = 3;
        ECX = #frame;
        EDX = 40;
        $int    0x40
}


int vert;
struct mouse{
 dword x,y,lkm,pkm;
 void get();
};

void mouse::get()
{
        EAX = 37;
        EBX = 1;
        $int    0x40
        $mov    ebx, eax
        $shr    eax, 16
        $and    ebx,0x0000FFFF
        x = EAX;
        y = EBX;
        EAX = 37;
        EBX = 2;
        $int    0x40
        $mov    ebx, eax
        $and    eax, 0x00000001
        $shr    ebx, 1
        $and    ebx, 0x00000001
        lkm = EAX;
        pkm = EBX;
        EAX = 37; //Є®«сбЁЄ®
        EBX = 7;
        $int    0x40
        $mov    ebx, eax
        $shr    eax, 16
        $and    ebx,0x0000FFFF
        //hor = EAX;
        vert = EBX;
}


//---------------------------------------------------------------------------
struct f70{
        dword   func;
        dword   param1;
        dword   param2;
        dword   param3;
        dword   param4;
        char    rezerv;
        dword   name;
};
//---------------------------------------------------------------------------
struct BDVK{
        dword   attr;
        byte    type_name;
        byte    rez1, rez2, rez3;
        dword   timecreate;
        dword   datecreate;
        dword   timelastaccess;
        dword   datelastaccess;
        dword   timelastedit;
        dword   datelastedit;
        dword   sizelo;
        dword   sizehi;
        char    name[518];
};
//---------------------------------------------------------------------------
struct proc_info{
        dword   use_cpu;
        word    pos_in_stack,num_slot,rezerv1;
        char    name[11];
        char    rezerv2;
        dword   adress,use_memory,ID,left,top,width,height;
        word    status_slot,rezerv3;
        dword   work_left,work_top,work_width,work_height;
        char    status_window;
        void    getme();
};

void proc_info::getme()
{
        EAX = 9;
        EBX = #use_cpu;
        ECX = -1;
        $int    0x40
}
//-------------------------------------------------------------------------------

/*
 ЋваЁб®ўЄ  ®Є­ 
  {x_start|y_start}, {x_size|y_size}, color_back, color_title, color_frames

 DrawWindow(
             EBX = [x_start][x_size]
             ECX = [y_start][y_size]
             EDX, ESI, EDI = [00RRGGBB]
           )
*/

inline fastcall void DrawWindow(dword EBX, ECX, EDX, ESI, EDI){
#speed
 EAX = 0;               // function 0 : define and draw window
 $int 0x40
#codesize
}

inline fastcall void DrawButton(dword EBX, ECX, EDX, ESI){
 EAX = 8;
 $int 0x40
}

inline fastcall dword WaitEvent(){
 EAX = 10;              // wait here for event
 $int 0x40
}

inline fastcall void ExitProcess(){
 EAX = -1;              // close this program
 $int 0x40
}

/*
02 = GET KEY

     ret: al 0 successful -> ah = key
          al 1 no key in buffer
*/
inline fastcall word GetKey(){
 EAX = 2;              // just read this key from buffer
 $int  0x40
// EAX = EAX >> 8;
}

/*
17 = GET PRESSED BUTTON ID

     ret: al 0 successful -> ah = id number
          al 1 no key in buffer
*/
inline fastcall word GetButtonID(){
 EAX = 17;            // Get ID
 $int  0x40
 EAX = EAX >> 8;
}

/*
04 = WRITE TEXT TO WINDOW

     ebx [x start]*65536 + [y start]
     ecx text color 0x00RRGGBB
     edx pointer to text beginning
     esi text length
     ret: nothing changed
*/
inline fastcall void WriteTextXY(dword EBX, ECX, EDX, ESI){
#speed 
 EAX = 4;
 $int 0x40;
#codesize
}

/*
13 = DRAW BAR

     ebx [x start]*65536 + [x size]
     ecx [y start]*65536 + [y size]
     edx color 0x00RRGGBB
     ret: nothing changed
*/
inline fastcall void kos_DrawBar(dword EBX, ECX, EDX){
#speed
 EAX = 13;
 $int 0x40
#codesize
}

/* function EBX=5 (GetBackgroun) ECX[]->EDX[], length ESI
inline fastcall void GetBackground(dword ECX, EDX, ESI){
#speed
 EAX = 39;
 EBX = 5;
 $int 0x40
#codesize
}*/

//CODED by Veliant
/*eax = 38 - номер функции 
ebx = [координата начала по оси x]*65536 + [координата конца по оси x] 
ecx = [координата начала по оси y]*65536 + [координата конца по оси y] 
edx = 0x00RRGGBB - цвет
edx = 0x01xxxxxx - рисовать инверснvй отрезок (младшие 24 бита игнорируітся) */
inline fastcall void DrawLine(dword EBX, ECX, EDX){
 EAX = 38;
 $int 0x40
}

inline fastcall void DrawTitle(dword ECX)
{
        EAX = 71;
        EBX = 1;
        $int 0x40;
}

inline fastcall dword GetSkinWidth()
{
        EAX = 48;
        EBX = 4;
        $int 0x40
}

inline fastcall void ChangeSkin(){
        EAX = 48;
        EBX = 8;
        ECX = #file_path;
        $int 0x40
}

inline fastcall dword GetScreenWidth()
{
        EAX = 14;
        EBX = 4;
        $int 0x40
        $shr eax, 16
        $and eax,0x0000FFFF
}

inline fastcall void DeleteButton(dword EDX)
{
        EAX = 8;
        EDX = EDX + BT_DEL;
        $int 0x40;
}

inline fastcall dword LoadLibrary(dword ECX)
{
        $mov eax, 68 
        $mov ebx, 19
        $int  0x40
}

inline fastcall dword strlen(dword EDI)
{
#speed
        ECX=0;
        EAX=0;
        ECX--;
        $REPNE $SCASB
        EAX=EAX-2-ECX;
#codesize
}

//-1 - ­Ґ а ў­л
// 0 - ­Ґ а ў­л
inline fastcall dword strcmp(dword ESI,EDI)
{
        dword strcmp_i,ret=-1,len1,len2,sovpadenij=0,str1,str2;
        str1=ESI;
        str2=EDI;
        len1=strlen(str1);
        len2=strlen(str2);
        IF (len1==len2)
        {
                FOR (strcmp_i=0;strcmp_i<len1;strcmp_i++)
                {
                        EAX = str1+strcmp_i;
                        EAX = ESBYTE[EAX];
                        EBX = str2+strcmp_i;
                        EBX = ESBYTE[EBX];
                        IF (EAX==EBX) sovpadenij++;
                }
                IF (sovpadenij==len1) ret=0;
        } ELSE ret=-1;
        EAX = ret;
}

inline fastcall dword upcase(dword ESI)
{
        dword str, i;
        str = ESI;
        for (i=0;i<strlen(str);i++)
        {
                EAX = str+i;
                EDX = ESBYTE[EAX];
                IF (EDX>=97) && (EDX<=122) ESBYTE[str+i] = DL - 32;     //a-z
                IF (EDX>=160) && (EDX<=175) ESBYTE[str+i] = DL - 32;    //а-п
                IF (EDX>=224) && (EDX<=239) ESBYTE[str+i] = DL - 80;    //р-я
                IF (EDX == 241) ESBYTE[EAX] = 240;                                      //ї
        }
        EAX = str;
        //EAX = ESDWORD[EAX];
        //if (EAX != 0x5249443C) $int 3;
}

inline fastcall dword lowcase(dword ESI)
{
        dword str=ESI, i;
        FOR (i=0;i<strlen(str);i++)
        {
                EAX = str+i;
                EDX = ESBYTE[EAX];
                IF (EDX>=65) && (EDX<=90) ESBYTE[str+i] = DL + 32;      //a-z
                IF (EDX>=128) && (EDX<=143) ESBYTE[str+i] = DL + 32;    //а-п
                IF (EDX>=144) && (EDX<=159) ESBYTE[str+i] = DL + 80;    //р-я
                IF (EDX == 240) ESBYTE[EAX] = 241;                                      //ї
        }
        EAX = str;
        //EAX = ESDWORD[EAX];
        //if (EAX != 0x5249443C) $int 3;
}

inline fastcall void dostowin (dword ESI) 
{
        dword stroka,dlina;
        stroka = ESI;
        while (BL=ESBYTE[ESI])
        {
                IF (BL>128)
                        IF (BL>=240) ESBYTE[ESI] = BL - 16;
                        ELSE ESBYTE[ESI] = BL - 64;
                ESI++;
        }
}

void WindowRedrawStatus(dword i)
{
        EAX = 12;              // function 12:tell os about windowdraw
        EBX = i;               // 1, start of draw
        $int 0x40
}

void DefineAndDrawWindow(dword x,y,sizeX,sizeY,byte mainAreaType,dword mainAreaColour,byte headerType,dword headerColour,borderColour)
{
        dword arg1, arg2, arg3, arg4;
        //
        arg1 = x << 16 + sizeX;
        arg2 = y << 16 + sizeY;
        arg3 = mainAreaType << 24 | mainAreaColour;
        arg4 = headerType << 24 | headerColour;
        //
        $mov eax, 0
        $mov ebx, arg1
        $mov ecx, arg2
        $mov edx, arg3
        $mov esi, arg4
        $mov edi, borderColour
        $int 0x40
}

void DefineButton(dword x,y,w,h,id,color)
{
        DrawButton(x<<16+w, skin_width+y<<16+h, id, color);
}

void WriteText(dword x,y,byte fontType, dword color, text, len)
{
        EBX = x<<16+skin_width+y;
        ECX = fontType<<24+color;
        EDX = text;
        ESI = len;
        EAX = 4;
        $int 0x40;
}

inline fastcall void PutPixel(dword EBX,ECX,EDX) //Coded by Leency :D
{
  EAX=1;
  $int 0x40
}

void DrawBar(dword x,y,w,h,color)
{
        kos_DrawBar(x<<16+w,skin_width+y<<16+h,color);
}

void DrawRegion(dword x,y,width,height,color1)
{
        DrawBar(x,y,width,1,color1); //полоса гор сверху
        DrawBar(x,y+height,width,1,color1); //полоса гор снизу
        DrawBar(x,y,1,height,color1); //полоса верт слева
        DrawBar(x+width,y,1,height+1,color1); //полоса верт справа
}

void DrawFlatButton(dword x,y,width,height,id,color,text)
{
        DrawRegion(x,y,width,height,0x94AECE);
        DrawBar(x+1,y+1,width-1,1,0xFFFFFF); //полоса гор белая
        DrawBar(x+1,y+height-1,width-2,1,0xC7C7C7); //тень верт
        DrawBar(x+1,y+1,1,height-1,0xFFFFFF); //полоса верт белая
        DrawBar(x+width-1,y+2,1,height-2,0xC7C7C7); //тень верт
        DrawBar(x+2,y+2,width-3,height-3,color); //заливка
        IF (id<>0)      DefineButton(x,y,width,height,id+BT_HIDE,0xEFEBEF); //определяем кнопку
        WriteText(-strlen(text)*6+width/2+x+1,height/2-3+y,0x80,0,text,strlen(text));
}


void PutImage(dword buf,w,h,x,y)
{
        int i,r,g,b;
        EDI=buf;
        EAX = 7;
        EBX = buf;
        ECX = w<<16+h;
        EDX = x<<16+y+skin_width;
        $int 0x40
}


void copystr(dword s,d)
{
        $mov esi,s
        $mov edi,d
        $cld
l1:
        $lodsb
        $stosb
        $test al,al
        $jnz l1
}


int     pos,razr,backup,j=0,chislo;
char    buffer[11]="";
inline fastcall dword IntToStr(dword ESI)
{
        chislo=ESI;
        ECX=12;
        $push edi
        $mov edi,#buffer
        $xor al,al
        $cld
        $rep $stosb
        pos=razr=backup=j=0;
        if (chislo<0)
        {
                buffer[pos]='-';
                chislo=-1*chislo;
                pos++;
        }
        backup=chislo;
        do
        {
                backup=backup/10;
                razr++;
        }
        while (backup!=0);
        razr--;
        FOR (j=razr+pos;j>pos-1;j--)
        {
                backup=chislo/10;
                backup=backup*10;
                buffer[j]=chislo-backup+48;
                chislo=chislo/10;
        }
        //return #buffer;
        $pop edi;
        EAX = #buffer;
}


inline fastcall dword MoveSize(dword EBX,ECX,EDX,ESI)
{
        EAX = 67;
        $int 0x40
}


f70     CopyFile_f;
BDVK CopyFile_atr;
inline fastcall dword CopyFile(dword EBX,ECX)
{
        dword s, d, bufer=0;
        s = EBX;
        d = ECX;

        CopyFile_f.func = 5;
        CopyFile_f.param1 = 0;
        CopyFile_f.param2 = 0;
        CopyFile_f.param3 = 0;
        CopyFile_f.param4 = #CopyFile_atr;
        CopyFile_f.rezerv = 0;
        CopyFile_f.name = s;
        $mov    eax, 70
        $mov    ebx, #CopyFile_f
        $int    0x40
        
        if (EAX == 0)
        {       
                bufer = malloc(CopyFile_atr.sizelo);    
                CopyFile_f.func = 0;
                CopyFile_f.param1 = 0;
                CopyFile_f.param2 = 0;
                CopyFile_f.param3 = CopyFile_atr.sizelo;
                CopyFile_f.param4 = bufer;
                CopyFile_f.rezerv = 0;
                CopyFile_f.name = s;
                $mov    eax, 70
                $mov    ebx, #CopyFile_f
                $int    0x40
        
                IF (EAX == 0)
                {
                        CopyFile_f.func = 2;
                        CopyFile_f.param1 = 0;
                        CopyFile_f.param2 = 0;
                        CopyFile_f.param3 = CopyFile_atr.sizelo;
                        CopyFile_f.param4 = bufer;
                        CopyFile_f.rezerv = 0;
                        CopyFile_f.name = d;
                        $mov    eax, 70
                        $mov    ebx, #CopyFile_f
                        $int    0x40
                }
        }

}
