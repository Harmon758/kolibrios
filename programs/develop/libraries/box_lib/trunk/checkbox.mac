;файл создан 13.02.2009 <Lrz> На код применена GPL2 лицензия
;Макрос для системной библиотеки box_lib.obj
;Checkbox

macro use_checkbox_draw
{
check_box_draw:
;ch_struc_size=24
ch_left equ [edi]    ;координата начала рисования по х
ch_top equ [edi+2]   ;координата начала рисования по у
ch_text_margin equ [edi+4]      ;=4 расстояние от прямоугольника чек бокса до надписи 
ch_size equ [edi+8]             ;12 размер квадрата чек бокса 
ch_color equ [edi+12]
ch_border_color equ [edi+16] ; or [edi+4] ;цвет рамки checkbox ее можно задать самостоятельно
ch_text_color equ   [edi+20];[edi+4]  ;цвет текста
ch_text_ptr equ [edi+24]    ;указатель на начало текстовой строки 
ch_text_length equ [edi+28]
ch_flags equ [edi+32]       ;флаги 

       pusha   ;сохраним все регистры
       mov     edi,dword [esp+36]
       mov eax,13 
       movzx ebx,word ch_left 
       shl ebx,16 
       add ebx,ch_size 
       mov ecx,ch_top 
       shl ecx,16 
       add ecx,dword ch_size 
       mov edx,dword ch_border_color 
       mcall ;рисуем рамку 

       mov edx,dword ch_color 
       add ebx,1 shl 16 - 2 
       add ecx,1 shl 16 - 2 
       mcall ;закрашиваем внутренности чекбокса 

       test dword ch_flags,2  ;достать значение бита из переменной и поместить в  флаг CF 
       jz   @f                ;в если CF=1, то выполним следующую процедуру иначе перейти на нижнюю @@
       call check_box_draw_ch  ;нарисовать включенный чек бокс
@@:
;----------------------------
;расчет куда будет произведен вывод текста
;----------------------------
        movzx ebx,word ch_left        ;загрузить значение х для чек бокса
        add   ebx,dword ch_size
        add   ebx,dword ch_text_margin;добавить размер стороны и расстояние на котором начнется вывод текста
        shl   ebx,16                ;сдвинем на 16 разрядов в лево (умножим на 65536)
        mov   bx,word ch_top        ;загрузим значение по y
        add   ebx,ch_size
        mov   ecx,dword ch_text_color        ;загрузим цвет надписи + flags
        sub   ebx,7        ;добавим значение длины стороны -9+2
        
        mov   edx,dword ch_text_ptr                ;укажем адрес от куда нужно выводить строку
        mov   esi,dword ch_text_length
        ;внесем в eax значение вывода надписи на канву
        mov   eax,4
        mcall                  ;Вывод 
popa                              ;восстановить значения регистров из стека
ret 4                             ;выйдем из процедуры

check_box_clear_ch:                        ;очистка чек бокса
        mov   edx,dword ch_color   ;цвет внутри чек бокса
        jmp   @f             ;безусловный прыжок на нижнюю метку @@
check_box_draw_ch:            ;нарисовать включенный чек бокс
        mov   edx,dword ch_border_color        ;загрузить цвет
@@:
        movzx ebx,word ch_left  ;загрузить координату по х
        mov   eax,dword ch_size
        mov   bp,ax
        shr   eax,2
        push  ax
 
        push  ax
        add   ebx,eax           
        shl   ebx,16            ;сдвинем на 16 разрядов в лево (умножим на 65536)
        pop   ax
        lea   eax,[eax*2]
        sub   bp,ax             ;сохраним регистр bx в регистре указателя базы
        mov   bx,bp

        movzx ecx,word ch_top ;загрузить координату по у
        pop   ax
        add   cx,ax         
        shl   ecx,16          ;сдвинем на 16 разрядов в лево (умножим на 65536)
        mov   cx,bp           ;загрузим значения регистра указателя базы в cx
        mov   eax,13          ;в eax - значения функции для вывода полосы т.е. по сути прямоугольника, который отображает включенный компонент чек бокс
        mcall            ;вывод
ret                                ;выйти из процедуры
}


macro use_checkbox_mouse
{

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Обработчик mouse
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
check_box_mouse:      ;обработка мыши 
pusha
        mov     edi,dword [esp+36]
        mov     eax,37           ;будем что то делать если у нас что - нить нажато
        mov     ebx,2            ;внести в регистр значение 2
        mcall             ;проверка не нажал ли пользователь кнопку мышки
        test    eax,eax   ;проверка если у нас в eax=0, то установим флаг и выйдем
        jnz     @f         ;перейти на нижнюю метку @@
        btr     dword ch_flags,2  ;извлечение значения заданного бита в флаг cf и изменение его значения на нулевое. 
        jmp     check_box_mouse_end
        
@@:
        bts  dword ch_flags,2   ;проверка флага т.е. перенос в cf значение бита и установка бита в состояние включено
        jc   check_box_mouse_end         ;если CF=1 то перейти  в конец т.е. это выход
        mov  esi,dword ch_text_length ;загрузить кол-во символов в текстовой строке
        ;Умножение на 6 Быстрое умножение можно воспользоваться любым мз методов, но на старых Процессорах (386,486,P1)быстрее будет с инструкцией Lea
        ;lea esi,[eax*2+eax]
        ;shl eax,1
        imul esi,6             ; или можно и так умножить на 6
        add  esi,dword ch_text_margin ;добавить 3 - расстояние от чек бокса до надписи

        mov  eax,37             ;получим координаты мышки 
        mov  ebx,1              ;добавить 1
        mcall               ;получить координаты курсора относительно окна 
        
        movzx ebx,word ch_top  ;загрузить в bx значение координаты у
        cmp   ax,bx              ;сравнить с с координатой курсора
        jl   check_box_mouse_end          ;SF <> OF если меньше 
        add   ebx,dword ch_size        ;добавить размер 
        cmp   ax,bx              ;сравнить
        jg   check_box_mouse_end          ;ZF = 0 и SF = OF если больше 
             
        shr   eax,16              ;разделим на 65536 или просто сдвинем биты на 16 значений
        movzx ebx,word ch_left  ;произведем аналогичное сравнение
        cmp   ax,bx            ;сравнить регистры
        jl   check_box_mouse_end        ;если меньше
        add   ebx,dword ch_size      ;добавить длину стороны прямоугольника
        add   ebx,esi          ;Учесть в значении по х еще и длину надписи к чекбоксу
        cmp   ax,bx            ;стравнить регистры
        jg   check_box_mouse_end        ;если больше 

        bts  dword ch_flags,1  ;извлечение значения заданного бита в флаг cf и изменение его значения на 1. 
        jc   @f                ;CF=1 то перейти на нижнюю @@
        
        call check_box_draw_ch        ;отобразить включенный чек бокс
;        mov   dword [esp+24],1 ;дальнейшая проверка чек боксов бесмыслена, по этому в стек, где располагается ecx поместитм 0 
        jmp  check_box_mouse_end       ;выйти 
@@:
        btr   word ch_flags,1  ;извлечение значения заданного бита в флаг cf и изменение его значения на нулевое. 
        call check_box_clear_ch         ;выключить чек бокс т.е. на месте закрашенного прямоугольника отобразить цвет фона.
check_box_mouse_end:
popa                                ;восстановить регистры из стека
ret  4                              ;выйти
}