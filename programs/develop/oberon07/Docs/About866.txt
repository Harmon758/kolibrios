	Компилятор языка программирования Oberon-07/11 для i386
		Windows/Linux/KolibriOS.
------------------------------------------------------------------------------

	Состав программы

1.	Compiler.kex (KolibriOS) - исполняемый файл компилятора.
	Вход - текстовые файлы модулей с расширением ".ob07", кодировка ANSI
	или UTF-8 с BOM-сигнатурой.
	Выход - исполняемый файл формата PE, ELF или MENUET01/MS COFF.
	Параметры:
	1) имя главного модуля
	2) тип приложения и платформа
		"con" - Windows console
		"gui" - Windows GUI
		"dll" - Windows DLL
		"elf" - Linux
		"kos" - KolibriOS
		"obj" - KolibriOS DLL
	3) размер стэка в мегабайтах, необязательный параметр, по умолчанию -
	1 Мб, для ELF игнорируется. Если 2-й параметр = "obj" (KolibriOS DLL),
	то 3-й параметр задается шестнадцатиричным числом
	(0x00000001 .. 0xffffffff) и определяет версию программы,
	по умолчанию - 0x00010000 (v1.0).
	Например:
		"C:\oberon-07\example.ob07" con 1
		"C:\oberon-07\example.ob07" obj 0x00020005 (* v2.5 *)
	В случае успешной компиляции, компилятор передает код завершения 0,
	иначе 1. При работе компилятора в KolibriOS, код завершения не
	передается. Сообщения компилятора выводятся на консоль (Windows,
	KolibriOS), в терминал (Linux).
2.	Папка Lib - библиотека модулей
3.	Папка Source - исходный код компилятора

------------------------------------------------------------------------------
	Отличия от оригинала

1.	Расширен псевдомодуль SYSTEM
2.	Разрешен символ "_" в идентификаторах
3.	Добавлены системные флаги
4.	Оператор CASE реализован в соответствии с синтаксисом и семантикой
	данного оператора в языке Oberon (Revision 1.10.90)
5.	Расширен набор стандартных процедур
6.	Семантика охраны/проверки типа уточнена для нулевого указателя
7.	Семантика DIV и MOD уточнена для отрицательных чисел
8.	Добавлены однострочные комментарии (начинаются с пары символов "//")
9.	Разрешен экспорт переменных типов ARRAY и RECORD (только для чтения)

------------------------------------------------------------------------------
	Особенности реализации

1.	Основные типы

	  Тип		   Диапазон значений		   Размер, байт

	INTEGER       -2147483648 .. 2147483647 		4
	REAL	      1.40E-45 .. 3.34E+38			4
	LONGREAL      4.94E-324 .. 1.70E+308			8
	CHAR	      символ ASCII (0X .. 0FFX) 		1
	BOOLEAN       FALSE, TRUE				1
	SET	      множество из целых чисел {0 .. 31}	4

2.	Максимальная длина идентификаторов - 255 символов
3.	Максимальная длина строковых констант - 255 символов
4.	Максимальная длина строк исходного кода - 511 символов
5.	Максимальная размерность открытых массивов - 5
6.	Максимальное количество объявленных типов-записей - 2047
7.	Процедура NEW заполняет нулями выделенный блок памяти
8.	Глобальные и локальные переменные инициализируются нулями
9.	В отличие от многих Oberon-реализаций, сборщик мусора и динамическая
	модульность отсутствуют

------------------------------------------------------------------------------
	Псевдомодуль SYSTEM

  Псевдомодуль SYSTEM содержит низкоуровневые и небезопасные процедуры,
ошибки при использовании процедур псевдомодуля SYSTEM могут привести к
повреждению данных времени выполнения и аварийному завершению программы.

	PROCEDURE ADR(v: любой тип): INTEGER
		v - переменная, процедура или строковая константа;
		возвращает адрес v

	PROCEDURE SIZE(T): INTEGER
		возвращает размер типа T

	PROCEDURE TYPEID(T): INTEGER
		T - тип-запись или тип-указатель,
		возвращает номер типа в таблице типов-записей

	PROCEDURE INF(T): T
		T - REAL или LONGREAL,
		возвращает специальное вещественное значение "бесконечность"

	PROCEDURE GET(a: INTEGER;
			VAR v: любой основной тип, PROCEDURE, POINTER)
		v := Память[a]

	PROCEDURE PUT(a: INTEGER; x: любой основной тип, PROCEDURE, POINTER)
		Память[a] := x

	PROCEDURE MOVE(Source, Dest, n: INTEGER)
		Копирует n байт памяти из Source в Dest,
		области Source и Dest не должны перекрываться

	PROCEDURE CODE(s: ARRAY OF CHAR)
		Вставка машинного кода
		s - строковая константа шестнадцатиричных цифр
		количество цифр должно быть четным
		например: SYSTEM.CODE("B801000000") (* mov eax, 1 *)

  Также в модуле SYSTEM определен тип CARD16 (2 байта). Для типа CARD16 не
допускаются никакие явные операции, за исключением присваивания.
Преобразования CARD16 -> INTEGER и INTEGER -> CARD16 могут быть реализованы
так:

	PROCEDURE Card16ToInt(w: SYSTEM.CARD16): INTEGER;
	VAR i: INTEGER;
	BEGIN
	  SYSTEM.PUT(SYSTEM.ADR(i), w)
	  RETURN i
	END Card16ToInt;

	PROCEDURE IntToCard16(i: INTEGER): SYSTEM.CARD16;
	VAR w: SYSTEM.CARD16;
	BEGIN
	  SYSTEM.GET(SYSTEM.ADR(i), w)
	  RETURN w
	END IntToCard16;

  Функции псевдомодуля SYSTEM нельзя использовать в константных выражениях.

------------------------------------------------------------------------------
	Системные флаги

  При объявлении процедурных типов и глобальных процедур, после ключевого
слова PROCEDURE может быть указан флаг соглашения вызова: [stdcall], [cdecl]
или [winapi]. Например:

	PROCEDURE [cdecl] MyProc(x, y, z: INTEGER): INTEGER;

  Если указан флаг [winapi], то принимается соглашение stdcall и
процедуру-функцию можно вызвать как собственно процедуру, вне выражения.
Флаг [winapi] доступен только для платформы Windows.
  При объявлении типов-записей, после ключевого слова RECORD может быть
указан флаг [noalign] или [union]. Флаг [noalign] означает отсутствие
выравнивания полей записи, а флаг [union] означает, что смещения всех полей
записи равны нулю, при этом размер записи равен размеру наибольшего поля.
Записи RECORD [union] ... END соответствуют объединениям (union) в языке C.
Записи с системными флагами не могут иметь базового типа и не могут быть
базовыми типами для других записей.
  Для использования системных флагов, требуется импортировать SYSTEM.

------------------------------------------------------------------------------
	Оператор CASE

  Синтаксис оператора CASE:

	CaseStatement =
		CASE Expression OF Сase {"|" Сase}
			[ELSE StatementSequence] END.
	Case = [CaseLabelList ":" StatementSequence].
	CaseLabelList = CaseLabels {"," CaseLabels}.
	CaseLabels = ConstExpression [".." ConstExpression].

  Например:

	CASE x OF
	|-1:	DoSomething1
	| 1:	DoSomething2
	| 0:	DoSomething3
	ELSE
		DoSomething4
	END

  В метках вариантов можно использовать константные выражения, ветка ELSE
необязательна. Если не выполнен ни один вариант и ELSE отсутствует, то
программа прерывается с ошибкой времени выполнения.

------------------------------------------------------------------------------
	Проверка и охрана типа нулевого указателя

  Оригинальное сообщение о языке не определяет поведение программы при
выполнении охраны p(T) и проверки типа p IS T при p = NIL. Во многих
Oberon-реализациях выполнение такой операции приводит к ошибке времени
выполнения. В данной реализации охрана типа нулевого указателя не приводит к
ошибке, а проверка типа дает результат FALSE. В ряде случаев это позволяет
значительно сократить частоту применения охраны типа.

------------------------------------------------------------------------------
	Дополнительные стандартные процедуры

	DISPOSE(VAR v: любой_указатель)
		Освобождает память, выделенную процедурой NEW для
		динамической переменной v^, и присваивает переменной v
		значение NIL.

	LSR(x, n: INTEGER): INTEGER
		Логический сдвиг x на n бит вправо.

	BITS(x: INTEGER): SET
		Интерпретирует x как значение типа SET.
		Выполняется на этапе компиляции.

	LENGTH(s: ARRAY OF CHAR): INTEGER
		Длина 0X-завершенной строки s, без учета символа 0X.
		Если символ 0X отсутствует, функция возвращает длину
		массива s.

------------------------------------------------------------------------------
	DIV и MOD

	 x	   y	  x DIV y   x MOD y

	 5	   3	     1	       2
	-5	   3	    -2	       1
	 5	  -3	    -2	      -1
	-5	  -3	     1	      -2

------------------------------------------------------------------------------
	Скрытые параметры процедур

  Некоторые процедуры могут иметь скрытые параметры, они отсутствуют в списке
формальных параметров, но учитываются компилятором при трансляции вызовов.
Это возможно в следующих случаях:

1.	Процедура имеет формальный параметр открытый массив:
		PROCEDURE Proc(x: ARRAY OF ARRAY OF LONGREAL);
	Вызов транслируется так:
		Proc(SYSTEM.ADR(x), LEN(x), LEN(x[0])
2.	Процедура имеет формальный параметр-переменную типа RECORD:
		PROCEDURE Proc(VAR x: Rec);
	Вызов транслируется так:
		Proc(SYSTEM.TYPEID(Rec), SYSTEM.ADR(x))
3.	Процедура является вложенной, глубина вложения k,
	для глобальных процедур k = 0:
		PROCEDURE Proc(p1, ..., pn);
	Вызов транслируется так:
		Proc(base(k - 1), base(k - 2), ..., base(0), p1, ..., pn),
	где base(m) - адрес базы кадра стэка охватывающей процедуры глубины
	вложения m (используется для доступа к локальным переменным
	охватывающей процедуры)

------------------------------------------------------------------------------
	Модуль RTL

  Все программы неявно используют модуль RTL. Компилятор транслирует
некоторые операции (проверка и охрана типа, сравнение строк, сообщения об
ошибках времени выполнения и др.) как вызовы процедур этого модуля. Не
следует явно вызывать эти процедуры, за исключением процедуры SetClose:

	PROCEDURE SetClose(proc: PROC), где TYPE PROC = PROCEDURE

SetClose назначает процедуру proc (без параметров) вызываемой при выгрузке
dll-библиотеки (Windows), если приложение компилируется как Windows DLL. Для
прочих типов приложений и платформ вызов процедуры SetClose не влияет на
поведение программы.
  Сообщения об ошибках времени выполнения выводятся в диалоговых окнах
(Windows), в терминал (Linux), на доску отладки (KolibriOS).

------------------------------------------------------------------------------
	Модуль API

  Существуют три реализации модуля API: для Windows, Linux и KolibriOS. Как и
модуль RTL, модуль API не предназначен для прямого использования. Он
обеспечивает кроссплатформенность компилятора.

------------------------------------------------------------------------------
	Генерация исполняемых файлов DLL

  Разрешается экспортировать только процедуры. Для этого, процедура должна
находиться в главном модуле программы, и ее имя должно быть отмечено символом
экспорта ("*"). KolibriOS DLL всегда экспортируют идентификаторы "version"
(версия программы) и "lib_init" - адрес процедуры инициализации DLL:

	PROCEDURE [stdcall] lib_init(): INTEGER

Эта процедура должна быть вызвана перед использованием DLL.
Процедура всегда возвращает 1.
  В настоящее время генерация DLL для Linux не реализована.

==============================================================================
==============================================================================

	Библиотека (KolibriOS)

------------------------------------------------------------------------------
MODULE Out - консольный вывод

	PROCEDURE Open
		формально открывает консольный вывод

	PROCEDURE Int(x, width: INTEGER)
		вывод целого числа x;
		width - количество знакомест, используемых для вывода

	PROCEDURE Real(x: LONGREAL; width: INTEGER)
		вывод вещественного числа x в плавающем формате;
		width - количество знакомест, используемых для вывода

	PROCEDURE Char(x: CHAR)
		вывод символа x

	PROCEDURE FixReal(x: LONGREAL; width, p: INTEGER)
		вывод вещественного числа x в фиксированном формате;
		width - количество знакомест, используемых для вывода;
		p - количество знаков после десятичной точки

	PROCEDURE Ln
		переход на следующую строку

	PROCEDURE String(s: ARRAY OF CHAR)
		вывод строки s

------------------------------------------------------------------------------
MODULE In - консольный ввод

	VAR Done: BOOLEAN
		принимает значение TRUE в случае успешного выполнения
		операции ввода, иначе FALSE

	PROCEDURE Open
		формально открывает консольный ввод,
		также присваивает переменной Done значение TRUE

	PROCEDURE Int(VAR x: INTEGER)
		ввод числа типа INTEGER

	PROCEDURE Char(VAR x: CHAR)
		ввод символа

	PROCEDURE Real(VAR x: REAL)
		ввод числа типа REAL

	PROCEDURE LongReal(VAR x: LONGREAL)
		ввод числа типа LONGREAL

	PROCEDURE String(VAR s: ARRAY OF CHAR)
		ввод строки

	PROCEDURE Ln
		ожидание нажатия ENTER

------------------------------------------------------------------------------
MODULE Console - дополнительные процедуры консольного вывода

	CONST

	Следующие константы определяют цвет консольного вывода

		Black = 0      Blue = 1 	  Green = 2
		Cyan = 3       Red = 4		  Magenta = 5
		Brown = 6      LightGray = 7	  DarkGray = 8
		LightBlue = 9  LightGreen = 10	  LightCyan = 11
		LightRed = 12  LightMagenta = 13  Yellow = 14
		White = 15

	PROCEDURE Cls
		очистка окна консоли

	PROCEDURE SetColor(FColor, BColor: INTEGER)
		установка цвета консольного вывода: FColor - цвет текста,
		BColor - цвет фона, возможные значения - вышеперечисленные
		константы

	PROCEDURE SetCursor(x, y: INTEGER)
		установка курсора консоли в позицию (x, y)

	PROCEDURE GetCursor(VAR x, y: INTEGER)
		записывает в параметры текущие координаты курсора консоли

	PROCEDURE GetCursorX(): INTEGER
		возвращает текущую x-координату курсора консоли

	PROCEDURE GetCursorY(): INTEGER
		возвращает текущую y-координату курсора консоли

------------------------------------------------------------------------------
MODULE ConsoleLib - обертка библиотеки console.obj

------------------------------------------------------------------------------
MODULE Math - математические функции

	CONST

		pi = 3.141592653589793D+00
		e  = 2.718281828459045D+00

	VAR

		Inf, nInf: LONGREAL
			положительная и отрицательная бесконечность

	PROCEDURE IsNan(x: LONGREAL): BOOLEAN
		возвращает TRUE, если x - не число

	PROCEDURE IsInf(x: LONGREAL): BOOLEAN
		возвращает TRUE, если x - бесконечность

	PROCEDURE sqrt(x: LONGREAL): LONGREAL
		квадратный корень x

	PROCEDURE exp(x: LONGREAL): LONGREAL
		экспонента x

	PROCEDURE ln(x: LONGREAL): LONGREAL
		натуральный логарифм x

	PROCEDURE sin(x: LONGREAL): LONGREAL
		синус x

	PROCEDURE cos(x: LONGREAL): LONGREAL
		косинус x

	PROCEDURE tan(x: LONGREAL): LONGREAL
		тангенс x

	PROCEDURE arcsin(x: LONGREAL): LONGREAL
		арксинус x

	PROCEDURE arccos(x: LONGREAL): LONGREAL
		арккосинус x

	PROCEDURE arctan(x: LONGREAL): LONGREAL
		арктангенс x

	PROCEDURE arctan2(y, x: LONGREAL): LONGREAL
		арктангенс y/x

	PROCEDURE power(base, exponent: LONGREAL): LONGREAL
		возведение числа base в степень exponent

	PROCEDURE log(base, x: LONGREAL): LONGREAL
		логарифм x по основанию base

	PROCEDURE sinh(x: LONGREAL): LONGREAL
		гиперболический синус x

	PROCEDURE cosh(x: LONGREAL): LONGREAL
		гиперболический косинус x

	PROCEDURE tanh(x: LONGREAL): LONGREAL
		гиперболический тангенс x

	PROCEDURE arcsinh(x: LONGREAL): LONGREAL
		обратный гиперболический синус x

	PROCEDURE arccosh(x: LONGREAL): LONGREAL
		обратный гиперболический косинус x

	PROCEDURE arctanh(x: LONGREAL): LONGREAL
		обратный гиперболический тангенс x

	PROCEDURE round(x: LONGREAL): LONGREAL
		округление x до ближайшего целого

	PROCEDURE frac(x: LONGREAL): LONGREAL;
		дробная часть числа x

	PROCEDURE floor(x: LONGREAL): LONGREAL
		наибольшее целое число (представление как LONGREAL),
		не больше x: floor(1.2) = 1.0

	PROCEDURE ceil(x: LONGREAL): LONGREAL
		наименьшее целое число (представление как LONGREAL),
		не меньше x: ceil(1.2) = 2.0

	PROCEDURE sgn(x: LONGREAL): INTEGER
		если x > 0 возвращает 1
		если x < 0 возвращает -1
		если x = 0 возвращает 0

------------------------------------------------------------------------------
MODULE Debug - вывод на доску отладки
	Интерфейс как модуль Out

	PROCEDURE Open
		открывает доску отладки

------------------------------------------------------------------------------
MODULE File - работа с файловой системой

	TYPE

		FNAME = ARRAY 520 OF CHAR

		FS = POINTER TO rFS

		rFS = RECORD (* информационная структура файла *)
			subfunc, pos, hpos, bytes, buffer: INTEGER;
			name: FNAME
		END

		FD = POINTER TO rFD

		rFD = RECORD (* структура блока данных входа каталога *)
			attr: INTEGER;
			ntyp: CHAR;
			reserved: ARRAY 3 OF CHAR;
			time_create, date_create,
			time_access, date_access,
			time_modif,  date_modif,
			size, hsize: INTEGER;
			name: FNAME
		END

	CONST

		SEEK_BEG = 0
		SEEK_CUR = 1
		SEEK_END = 2

	PROCEDURE Load(FName: ARRAY OF CHAR; VAR size: INTEGER): INTEGER;
		Загружает в память файл с именем FName, записывает в параметр
		size размер файла, возвращает адрес загруженного файла
		или 0 (ошибка). При необходимости, распаковывает
		файл (kunpack).

	PROCEDURE GetFileInfo(FName: ARRAY OF CHAR; VAR Info: rFD): BOOLEAN
		Записывает структуру блока данных входа каталога для файла
		или папки с именем FName в параметр Info.
		При ошибке возвращает FALSE.

	PROCEDURE Exists(FName: ARRAY OF CHAR): BOOLEAN
		возвращает TRUE, если файл с именем FName существует

	PROCEDURE Close(VAR F: FS)
		освобождает память, выделенную для информационной структуры
		файла F и присваивает F значение NIL

	PROCEDURE Open(FName: ARRAY OF CHAR): FS
		возвращает указатель на информационную структуру файла с
		именем FName, при ошибке возвращает NIL

	PROCEDURE Delete(FName: ARRAY OF CHAR): BOOLEAN
		удаляет файл с именем FName, при ошибке возвращает FALSE

	PROCEDURE Seek(F: FS; Offset, Origin: INTEGER): INTEGER
		устанавливает позицию чтения-записи файла F на Offset,
		относительно Origin = (SEEK_BEG - начало файла,
		SEEK_CUR - текущая позиция, SEEK_END - конец файла),
		возвращает позицию относительно начала файла, например:
			Seek(F, 0, SEEK_END)
		устанавливает позицию на конец файла и возвращает длину
		файла; при ошибке возвращает -1

	PROCEDURE Read(F: FS; Buffer, Count: INTEGER): INTEGER
		Читает данные из файла в память. F - указатель на
		информационную структуру файла, Buffer - адрес области
		памяти, Count - количество байт, которое требуется прочитать
		из файла; возвращает количество байт, которое было прочитано
		и соответствующим образом изменяет позицию чтения/записи в
		информационной структуре F.

	PROCEDURE Write(F: FS; Buffer, Count: INTEGER): INTEGER
		Записывает данные из памяти в файл. F - указатель на
		информационную структуру файла, Buffer - адрес области
		памяти, Count - количество байт, которое требуется записать
		в файл; возвращает количество байт, которое было записано и
		соответствующим образом изменяет позицию чтения/записи в
		информационной структуре F.

	PROCEDURE Create(FName: ARRAY OF CHAR): FS
		создает новый файл с именем FName (полное имя), возвращает
		указатель на информационную структуру файла,
		при ошибке возвращает NIL

	PROCEDURE CreateDir(DirName: ARRAY OF CHAR): BOOLEAN
		создает папку с именем DirName, все промежуточные папки
		должны существовать, при ошибке возвращает FALSE

	PROCEDURE DeleteDir(DirName: ARRAY OF CHAR): BOOLEAN
		удаляет пустую папку с именем DirName,
		при ошибке возвращает FALSE

	PROCEDURE DirExists(DirName: ARRAY OF CHAR): BOOLEAN
		возвращает TRUE, если папка с именем DirName существует

------------------------------------------------------------------------------
MODULE Read - чтение основных типов данных из файла F

	Процедуры возвращают TRUE в случае успешной операции чтения и
	соответствующим образом изменяют позицию чтения/записи в
	информационной структуре F

	PROCEDURE Char(F: File.FS; VAR x: CHAR): BOOLEAN

	PROCEDURE Int(F: File.FS; VAR x: INTEGER): BOOLEAN

	PROCEDURE Real(F: File.FS; VAR x: REAL): BOOLEAN

	PROCEDURE LongReal(F: File.FS; VAR x: LONGREAL): BOOLEAN

	PROCEDURE Boolean(F: File.FS; VAR x: BOOLEAN): BOOLEAN

	PROCEDURE Set(F: File.FS; VAR x: SET): BOOLEAN

	PROCEDURE Card16(F: File.FS; VAR x: SYSTEM.CARD16): BOOLEAN

------------------------------------------------------------------------------
MODULE Write - запись основных типов данных в файл F

	Процедуры возвращают TRUE в случае успешной операции записи и
	соответствующим образом изменяют позицию чтения/записи в
	информационной структуре F

	PROCEDURE Char(F: File.FS; x: CHAR): BOOLEAN

	PROCEDURE Int(F: File.FS; x: INTEGER): BOOLEAN

	PROCEDURE Real(F: File.FS; x: REAL): BOOLEAN

	PROCEDURE LongReal(F: File.FS; x: LONGREAL): BOOLEAN

	PROCEDURE Boolean(F: File.FS; x: BOOLEAN): BOOLEAN

	PROCEDURE Set(F: File.FS; x: SET): BOOLEAN

	PROCEDURE Card16(F: File.FS; x: SYSTEM.CARD16): BOOLEAN

------------------------------------------------------------------------------
MODULE DateTime - дата, время

	CONST ERR = -7.0D5

	PROCEDURE Now(VAR Year, Month, Day, Hour, Min, Sec: INTEGER)
		записывает в параметры компоненты текущей системной даты и
		времени

	PROCEDURE Encode(Year, Month, Day, Hour, Min, Sec: INTEGER): LONGREAL
		возвращает дату, полученную из компонентов
		Year, Month, Day, Hour, Min, Sec;
		при ошибке возвращает константу ERR = -7.0D5

	PROCEDURE Decode(Date: LONGREAL; VAR Year, Month, Day,
				Hour, Min, Sec: INTEGER): BOOLEAN
		извлекает компоненты
		Year, Month, Day, Hour, Min, Sec из даты Date;
		при ошибке возвращает FALSE

------------------------------------------------------------------------------
MODULE Args - параметры программы

	VAR argc: INTEGER
		количество параметров программы, включая имя
		исполняемого файла

	PROCEDURE GetArg(n: INTEGER; VAR s: ARRAY OF CHAR)
		записывает в строку s n-й параметр программы,
		нумерация параметров от 0 до argc - 1,
		нулевой параметр -- имя исполняемого файла

------------------------------------------------------------------------------
MODULE KOSAPI

	PROCEDURE sysfunc1(arg1: INTEGER): INTEGER
	PROCEDURE sysfunc2(arg1, arg2: INTEGER): INTEGER
	...
	PROCEDURE sysfunc7(arg1, arg2, ..., arg7: INTEGER): INTEGER
		Обертки для функций API ядра KolibriOS.
		arg1 .. arg7 соответствуют регистрам
			eax, ebx, ecx, edx, esi, edi, ebp;
		возвращают значение регистра eax после системного вызова.

	PROCEDURE sysfunc22(arg1, arg2: INTEGER; VAR res2: INTEGER): INTEGER
		Обертка для функций API ядра KolibriOS.
		arg1 - регистр eax, arg2 - регистр ebx,
		res2 - значение регистра ebx после системного вызова;
		возвращает значение регистра eax после системного вызова.

	PROCEDURE malloc(size: INTEGER): INTEGER
		Выделяет блок памяти.
		size - размер блока в байтах,
		возвращает адрес выделенного блока

	PROCEDURE free(ptr: INTEGER): INTEGER
		Освобождает ранее выделенный блок памяти с адресом ptr,
		возвращает 0

	PROCEDURE realloc(ptr, size: INTEGER): INTEGER
		Перераспределяет блок памяти,
		ptr - адрес ранее выделенного блока,
		size - новый размер,
		возвращает указатель на перераспределенный блок,
		0 при ошибке

	PROCEDURE GetCommandLine(): INTEGER
		Возвращает адрес строки параметров

	PROCEDURE GetName(): INTEGER
		Возвращает адрес строки с именем программы

	PROCEDURE LoadLib(name: ARRAY OF CHAR): INTEGER
		Загружает DLL с полным именем name. Возвращает адрес таблицы
		экспорта. При ошибке возвращает 0.

	PROCEDURE GetProcAdr(name: ARRAY OF CHAR; lib: INTEGER): INTEGER
		name - имя процедуры
		lib - адрес таблицы экспорта DLL
		Возвращает адрес процедуры. При ошибке возвращает 0.

------------------------------------------------------------------------------
MODULE ColorDlg - работа с диалогом "Color Dialog"

	TYPE

		Dialog = POINTER TO RECORD (* структура диалога *)
		    status: INTEGER   (* состояние диалога:
					 0 - пользователь нажал Cancel
					 1 - пользователь нажал OK
					 2 - диалог открыт	     *)

		    color:  INTEGER   (* выбранный цвет *)
		END

	PROCEDURE Create(draw_window: DRAW_WINDOW): Dialog
		создать диалог
		draw_window - процедура перерисовки основного окна
		(TYPE DRAW_WINDOW = PROCEDURE);
		процедура возвращает указатель на структуру диалога

	PROCEDURE Show(cd: Dialog)
		показать диалог
		cd - указатель на структуру диалога, который был создан ранее
		процедурой Create

	PROCEDURE Destroy(VAR cd: Dialog)
		уничтожить диалог
		cd - указатель на структуру диалога

------------------------------------------------------------------------------
MODULE OpenDlg - работа с диалогом "Open Dialog"

	TYPE

		Dialog = POINTER TO RECORD (* структура диалога *)
		    status:   INTEGER  (* состояние диалога:
					  0 - пользователь нажал Cancel
					  1 - пользователь нажал OK
					  2 - диалог открыт	      *)

		    FileName: ARRAY 4096 OF CHAR (* имя выбранного файла *)
		    FilePath: ARRAY 4096 OF CHAR (* полное имя выбранного
						    файла		 *)
		END

	PROCEDURE Create(draw_window: DRAW_WINDOW; type: INTEGER; def_path,
			filter: ARRAY OF CHAR): Dialog
		создать диалог
		draw_window - процедура перерисовки основного окна
			(TYPE DRAW_WINDOW = PROCEDURE)
		type -	тип диалога
			0 - открыть
			1 - сохранить
			2 - выбрать папку
		def_path - путь по умолчанию, папка def_path будет открыта
			при первом запуске диалога
		filter - в строке записано перечисление расширений файлов,
			которые будут показаны в диалоговом окне, расширения
			разделяются символом "|", например: "ASM|TXT|INI"
		процедура возвращает указатель на структуру диалога

	PROCEDURE Show(od: Dialog; Width, Height: INTEGER)
		показать диалог
		od - указатель на структуру диалога, который был создан ранее
		     процедурой Create
		Width и Height - ширина и высота диалогового окна

	PROCEDURE Destroy(VAR od: Dialog)
		уничтожить диалог
		od - указатель на структуру диалога

------------------------------------------------------------------------------
MODULE kfonts - работа с kf-шрифтами

	CONST

		bold		=   1
		italic		=   2
		underline	=   4
		strike_through	=   8
		smoothing	=  16
		bpp32		=  32

	TYPE

		TFont = POINTER TO TFont_desc (* указатель на шрифт *)

	PROCEDURE LoadFont(file_name: ARRAY OF CHAR): TFont
		загрузить шрифт из файла
		file_name   имя kf-файла
		рез-т:	    указатель на шрифт/NIL (ошибка)

	PROCEDURE SetSize(Font: TFont; font_size: INTEGER): BOOLEAN
		установить размер шрифта
		Font	    указатель на шрифт
		font_size   размер шрифта
		рез-т:	    TRUE/FALSE (ошибка)

	PROCEDURE Enabled(Font: TFont; font_size: INTEGER): BOOLEAN
		проверить, есть ли шрифт, заданного размера
		Font	    указатель на шрифт
		font_size   размер шрифта
		рез-т:	    TRUE/FALSE (шрифта нет)

	PROCEDURE Destroy(VAR Font: TFont)
		выгрузить шрифт, освободить динамическую память
		Font	    указатель на шрифт
		Присваивает переменной Font значение NIL

	PROCEDURE TextHeight(Font: TFont): INTEGER
		получить высоту строки текста
		Font	    указатель на шрифт
		рез-т:	    высота строки текста в пикселях

	PROCEDURE TextWidth(Font: TFont;
		    str, length, params: INTEGER): INTEGER
		получить ширину строки текста
		Font	    указатель на шрифт
		str	    адрес строки текста в кодировке Win-1251
		length	    количество символов в строке или -1, если строка
			    завершается нулем
		params	    параметры-флаги см. ниже
		рез-т:	    ширина строки текста в пикселях

	PROCEDURE TextOut(Font: TFont;
		    canvas, x, y, str, length, color, params: INTEGER)
		вывести текст в буфер
		для вывода буфера в окно, использовать ф.65 или
		ф.7 (если буфер 24-битный)
		Font	    указатель на шрифт
		canvas	    адрес графического буфера
			    структура буфера:
			      Xsize	  dd
			      Ysize	  dd
			      picture	  rb  Xsize * Ysize * 4 (32 бита)
					      или Xsize * Ysize * 3 (24 бита)
		x, y	    координаты текста относительно левого верхнего
			    угла буфера
		str	    адрес строки текста в кодировке Win-1251
		length	    количество символов в строке или -1, если строка
			    завершается нулем
		color	    цвет текста 0x00RRGGBB
		params	    параметры-флаги:
			       1   жирный
			       2   курсив
			       4   подчеркнутый
			       8   перечеркнутый
			      16   применить сглаживание
			      32   вывод в 32-битный буфер
			    возможно использование флагов в любых сочетаниях
------------------------------------------------------------------------------
MODULE RasterWorks - обертка библиотеки Rasterworks.obj
------------------------------------------------------------------------------
MODULE libimg - обертка библиотеки libimg.obj
------------------------------------------------------------------------------