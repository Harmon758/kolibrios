/*
   Memory Blocks for KolibriOS v1.01
             L&V Edition

	Идея и дизайн: Leency
	Реализовано: Veliant и Leency
          Compile with C--
		       2008
*/

#pragma option J0
#pragma option LST
#pragma option OC
#pragma option 4
#pragma option A
#include "kolibri.h--"
#include "random.h--"
#include "mbgraph.h--"

#define strok 6		//количество блоков по вертикали
#define stolbcov 10	//количество блоков по горизонтали

#define header "Memory Blocks L&V Edition"

char button_r 	= "Ќ®ў п ЁЈа (F2)"; //Новая игра
char tcount_r 	= " ‘зҐв:"; //Счёт
char lg_r			= "RU";

char button_e = "New  game (F2)";
char tcount_e = "Count:";
char lg_e			= "EN";

#define button	"Ќ®ў п ЁЈа (F2)"
#define tcount	" ‘зҐв:"


int lang = 0;

byte bitstat[60] = 0;
byte bitpict[60] = 0;
dword butonsx[60] = 0;
dword butonsy[60] = 0;
dword i, k, x, id, count = 0;
dword firstbit, secondbit;

void main()
{
	int z=1;
	int off;
	FOR (i = 0; i < 30; i++)
	{
		do
			off = random(60);
		while (bitpict[off] != 0);
		bitpict[off] = z;
		do
			off = random(60);
		while (bitpict[off] != 0);
		bitpict[off] = z;
		z++;
	}
	skin_width = GetSkinWidth();
	firstbit = secondbit = 0x0BAD;
	Draw_Window();
	loop()
	{
		switch (WaitEvent())
		{
			CASE evButton:
				id = GetButtonID();
				switch (id)
				{
					CASE 1:
						ExitProcess();
						break;
					CASE 5:
						init();
						break;
					CASE 6:
						SWITCH (lang)
						{
							CASE 0:
								copystr(#button_e, button);
								copystr(#tcount_e, tcount);
								lang = 1;
								break;
							CASE 1:
								copystr(#button_r, button);
								copystr(#tcount_r, tcount);
								lang = 0;
								break;
						}
						Draw_Panel();
						break;
					default:
						if (bitstat[id-100] == 0)
						{
							if (firstbit <> 0x0BAD)
							{
								if (secondbit <> 0x0BAD)
								{
									IF (bitpict[firstbit-100] == bitpict[secondbit-100])
									{
										bitstat[firstbit-100] = 2;
										bitstat[secondbit-100] = 2;
									}
									ELSE
									{
										bitstat[firstbit-100] = 0;
										bitstat[secondbit-100] = 0;
									}
									ReDraw_Game_Button(firstbit - 100);
									ReDraw_Game_Button(secondbit - 100);
									secondbit = 0x0BAD;
									firstbit = id;
									bitstat[id-100] = 1;
									ReDraw_Game_Button(id - 100);
									count++;
								}
								ELSE
								{
									IF (firstbit<>id)
									{
										secondbit = id;
										bitstat[id-100] = 1;
										ReDraw_Game_Button(id - 100);
										count++;
									}
								}
							}
							ELSE
							{
								firstbit = id;
								bitstat[id-100] = 1;
								ReDraw_Game_Button(id - 100);
								count++;
							}
						}
						Draw_Count();
						break;
				}
				break;
			case evKey:
				SWITCH (GetKey())
				{
					CASE 51:
						init();		//Нажата F2
						break;
				}
				break;
			case evReDraw:
				Draw_Window();
				break;
		}
	}
	ExitProcess();
}

void Draw_Window()
{
	begin_paint();
	DefineAndDrawWindow(100, 100, 434, 290 + skin_width + 1, 0x04, 0x00C0C0C0, 0, 0, 0);
	DrawTitle(header);
	Draw_Panel();
	Draw_Game_Pole();

	end_paint();
}

void init()
{
	int off, z;
	z=1;
	$mov	edi, #bitstat
	$mov	ecx, 60
	$xor	al, al
	$rep	$stosb			//стираем старые данные о нажатых кнопках

	$mov	edi, #bitpict
	$mov	ecx, 60
	$xor	al, al
	$rep	$stosb			//стираем старые данные о картинках

	count = 0;
	firstbit = secondbit = 0x0BAD;
	FOR (i = 0; i < 30; i++)
	{
		do
			off = random(60);
		while (bitpict[off] != 0);
		bitpict[off] = z;
		do
			off = random(60);
		while (bitpict[off] != 0);
		bitpict[off] = z;
		z++;
	}
	Draw_Game_Pole();
	Draw_Panel();
}

void ReDraw_Game_Button(int id)
{
	int off;
	DefineButton(0, 0, 0, 0, 100 + id + BT_DEL, 0);									//удаляем старую
	DefineButton(butonsx[id], butonsy[id], 38, 38, 100 + id + BT_HIDE, 0xEFEBEF);	//делаем новую
	switch (bitstat[id])
	{
		CASE 0:
			Draw_Block(butonsx[id], butonsy[id]);
			break;
		CASE 1:
			Draw_Pressed_Block(butonsx[id], butonsy[id]);
			PutImage(bitpict[id]-1*32*32*3+#data,32,32,butonsx[id]+3,butonsy[id]+3);
			break;
		case 2:
			Draw_Open_Block(butonsx[id], butonsy[id]);
			PutImage(bitpict[id]-1*32*32*3+#data,32,32,butonsx[id]+3,butonsy[id]+3);
			break;
	}
	//WriteText(butonsx[id] + 10, butonsy[id] + 10, 0x80, 0x000000, IntToStr(bitpict[id]), 0);
}

void Draw_Game_Pole()
{
	FOR (k = 0; k < stolbcov; k++)
	{
		FOR (i = 0; i < strok; i++)
		{
			butonsx[k*strok+i] = k * 42 + 4 + 5;		//сохраняем координаты чтоб не считать в дальнейшем
			butonsy[k*strok+i] = i * 42 + 4;
			ReDraw_Game_Button(k*strok + i);		//рисуем поле
		}
	}
}

void Draw_Block(dword x, y)
{
	DrawRegion(x, y, 38, 38, 0x0094AECE);//рамка
	DrawLine(x + 1*65536 + x + 37, y + skin_width + 1*65536 + y + skin_width + 1, 0x00FFFFFF);//белые линии
	DrawLine(x + 1*65536 + x + 1, y + skin_width + 1*65536 + y + skin_width + 36, 0x00FFFFFF);
	DrawLine(x + 1*65536 + x + 37, y + skin_width + 37*65536 + y + skin_width + 37, 0x00DEDEDE);//серые линии
	DrawLine(x + 37*65536 + x + 37, y + skin_width + 2*65536 + y + skin_width + 36, 0x00DEDEDE);
	DrawBar(x + 2, y + 2, 35, 35, 0x00BDC7D6);//фон
}

void Draw_Open_Block(dword x, y)
{
	DrawRegion(x,   y,   38, 38, 0x0094AECE);//рамка
	DrawBar(x + 1, y + 1, 37, 37, 0x00EFEBEF);//фон
}

void Draw_Pressed_Block(dword x, y)
{
	DrawRegion(x,   y,   38, 38, 0x0094AECE);//рамка
	DrawRegion(x + 1, y + 1, 36, 36, 0x0094DB00);//рамка зеленая
	DrawRegion(x + 2, y + 2, 34, 34, 0x0094DB00);//рамка зеленая
	DrawBar(x + 3, y + 3, 33, 33, 0x00EFEBEF);//фон
}

void Draw_Panel()
{
	DrawBar(5, 255, 425, 32, 0x00EBE7DB);//фон панели
	DrawLine(5*65536 + 429, 255 + skin_width*65536 + 255 + skin_width, 0x0094AECE);//линии
	DrawLine(5*65536 + 429, 256 + skin_width*65536 + 256 + skin_width, 0x00FFFFFF);//линии

	//Кнопка
	DrawFlatButton(4 + 5, 260, 107, 23, 5, 0x00EFEBEF);//новая игра
	DrawFlatButton(210 + 5, 260, 23, 23, 6, 0x00EFEBEF);//язык
	//надпись на кнопке
	WriteText(22, 268, 0x80, 0x000000, button, 0);
	//надпись "Счет"
	WriteText(150, 268, 0x80, 0x000000, tcount, 0);
	IF (lang==0) 
		WriteText(221, 268, 0x80, 0x000000, #lg_e, 0);
	ELSE
		WriteText(221, 268, 0x80, 0x000000, #lg_r, 0);
	Draw_Count();

	//прямоугольники справа
	DrawBar(395 + 10, 260 + 5, 2, 2, 0x00BDCBDE);
	DrawBar(393 + 10, 265 + 5, 6, 6, 0x00BDCBDE);
	DrawBar(401 + 10, 270 + 5, 6, 6, 0x00BDCBDE);
	DrawBar(402 + 10, 257 + 5, 9, 8, 0x00D6D7CE);
}

void Draw_Count()
{
	EDI = 0x00EBE7DB;  //цвет панели
	WriteText(190, 268, 0xC0, 0x000000, IntToStr(count), 0);
}

stop:
