//#startaddress 0
#code32 TRUE

char   os_name[8]   = {'M','E','N','U','E','T','0','1'};
dword  os_version   = 0x00000001;
dword  start_addr   = #main;
dword  final_addr   = #stop+32;
dword  alloc_mem    = 0x00100000;
dword  x86esp_reg   = 0x0007fff0;
dword  I_Param      = 0x0;
dword  I_Icon       = 0x0;
dword			skin_width;

// KeyCode constant
#define UP_KEY     130+48
#define DOWN_KEY   129+48
#define LEFT_KEY   128+48
#define RIGHT_KEY  131+48
#define RETURN_KEY 13

// Color constant
#define clWhite 0x00ffffff
#define clBlack 0x00000000
#define clRed   0x00ff0000
#define clGreen 0x0000ff00
#define clBlue  0x000000ff

#define evButton  3
#define evKey     2
#define evReDraw  1
#define evNet	  8

#define BT_DEL		0x80000000
#define BT_HIDE		0x40000000
#define BT_NOFRAME	0x20000000

#define OLD			-1

struct FileInfo{
 dword read, firstBlock, qnBlockRead, retPtr, Work;
 byte  filedir;
};
//-------------------------------------------------------------------------
struct system_colors{
	dword frame,grab,grab_button,grab_button_text,grab_text,work,work_button,work_button_text,work_text,work_graph;
	void get();
};
void system_colors::get()
{
	EAX = 48;
	EBX = 3;
	ECX = #frame;
	EDX = 40;
	$int	0x40
}

struct mouse
{
 dword x,y,lkm,pkm;
 void get();
};

void mouse::get()
{
	EAX = 37;
	EBX = 1;
	$int	0x40
	$mov	ebx, eax
	$shr	eax, 16
	$and	ebx,0x0000FFFF
	x = EAX;
	y = EBX;
	EAX = 37;
	EBX = 2;
	$int	0x40
	$mov	ebx, eax
	$and	eax, 0x00000001
	$shr	ebx, 1
	$and	ebx, 0x00000001
	lkm = EAX;
	pkm = EBX;
	
}
//---------------------------------------------------------------------------
struct f70{
	dword	func;
	dword	param1;
	dword	param2;
	dword	param3;
	dword	param4;
	char	rezerv;
	dword	name;
};
//---------------------------------------------------------------------------
struct BDVK{
	dword	attr;
	byte	type_name;
	byte	rez1, rez2, rez3;
	dword	timecreate;
	dword	datecreate;
	dword	timelastaccess;
	dword	datelastaccess;
	dword	timelastedit;
	dword	datelastedit;
	dword	sizelo;
	dword	sizehi;
	char	name[518];
};
//---------------------------------------------------------------------------
struct proc_info{
	dword	use_cpu;
	word	pos_in_stack,num_slot,rezerv1;
	char	name[11];
	char	rezerv2;
	dword	adress,use_memory,ID,left,top,width,height;
	word	status_slot,rezerv3;
	dword	work_left,work_top,work_width,work_height;
	char	status_window;
	void	getme();
};

void proc_info::getme()
{
	EAX = 9;
	EBX = #use_cpu;
	ECX = -1;
	$int	0x40
}
//-------------------------------------------------------------------------------

inline fastcall void begin_paint(){
#speed
 EAX = 12;              // function 12:tell os about windowdraw
 EBX = 1;               // 1, start of draw
 $int 0x40
#codesize
}

inline fastcall void end_paint(){
#speed
 EAX = 12;              // function 12:tell os about windowdraw
 EBX = 2;               // 1, start of draw
 $int 0x40
#codesize
}

/*
 ЋваЁб®ўЄ  ®Є­ 
  {x_start|y_start}, {x_size|y_size}, color_back, color_title, color_frames

 DrawWindow(
             EBX = [x_start][x_size]
             ECX = [y_start][y_size]
             EDX, ESI, EDI = [00RRGGBB]
           )
*/

inline fastcall void DrawWindow(dword EBX, ECX, EDX, ESI, EDI){
#speed
 EAX = 0;               // function 0 : define and draw window
 $int 0x40
#codesize
}

inline fastcall void DrawButton(dword EBX, ECX, EDX, ESI){
#speed
 EAX = 8;
 $int 0x40
#codesize
}

inline fastcall dword WaitEvent(){
#speed
 EAX = 10;              // wait here for event
 $int 0x40
#codesize
}

inline fastcall void ExitProcess(){
#speed
 EAX = -1;              // close this program
 $int 0x40
#codesize
}

/*
02 = GET KEY

     ret: al 0 successful -> ah = key
          al 1 no key in buffer
*/
inline fastcall word GetKey(){
#speed
 EAX = 2;              // just read it key from buffer
 $int  0x40
 EAX = EAX >> 8;
#codesize
}

/*
17 = GET PRESSED BUTTON ID

     ret: al 0 successful -> ah = id number
          al 1 no key in buffer
*/
inline fastcall word GetButtonID(){
#speed
 EAX = 17;            // Get ID
 $int  0x40
 EAX = EAX >> 8;
#codesize
}

/*
58 = SYSTEM TREE ACCESS

     ebx    pointer to fileinfo block

     fileinfo:

     dd   0x0                  ; 0=read (/write/delete/append)
     dd   0x0                  ; 512 block to read 0+
     dd   0x1                  ; blocks to read (/bytes to write/append)
     dd   0x20000              ; return data pointer
     dd   0x10000              ; work area for os - 16384 bytes
     db   '/RAMDISK/FIRST/KERNEL.ASM',0  ; ASCIIZ dir & filename
*/
inline fastcall void AccessSystemTree(dword EBX){
#speed
 EAX = 58;
 $int 0x40
#codesize
}

/*
04 = WRITE TEXT TO WINDOW

     ebx [x start]*65536 + [y start]
     ecx text color 0x00RRGGBB
     edx pointer to text beginning
     esi text length
     ret: nothing changed
*/
inline fastcall void WriteTextXY(dword EBX, ECX, EDX, ESI){
#speed
 EAX = 4;
 $int 0x40;
#codesize
}

/*
13 = DRAW BAR

     ebx [x start]*65536 + [x size]
     ecx [y start]*65536 + [y size]
     edx color 0x00RRGGBB
     ret: nothing changed
*/
inline fastcall void kos_DrawBar(dword EBX, ECX, EDX){
#speed
 EAX = 13;
 $int 0x40
#codesize
}

//CODED by Veliant
/*eax = 38 - номер функции 
ebx = [координата начала по оси x]*65536 + [координата конца по оси x] 
ecx = [координата начала по оси y]*65536 + [координата конца по оси y] 
edx = 0x00RRGGBB - цвет
edx = 0x01xxxxxx - рисовать инверсный отрезок (младшие 24 бита игнорируются) */
inline fastcall void DrawLine(dword EBX, ECX, EDX){
#speed
 EAX = 38;
 $int 0x40
#codesize
}

inline fastcall void DrawTitle(dword ECX)
{
#speed
	EAX = 71;
	EBX = 1;
	$int 0x40;
#codesize
}

inline fastcall dword GetSkinWidth()
{
#speed
	EAX = 48;
	EBX = 4;
	$int 0x40
#codesize
}

inline fastcall dword GetScreenWidth()
{
#speed
	EAX = 14;
	EBX = 4;
	$int 0x40
	$shr eax, 16
	$and eax,0x0000FFFF
#codesize
}

inline fastcall void DeleteButton(dword EDX)
{
#speed
	EAX = 8;
	EDX = EDX + BT_DEL;
	$int 0x40;
#codesize
}

inline fastcall dword LoadLibrary(dword ECX)
{
#speed
	$mov eax, 68 
	$mov ebx, 19
	$int  0x40
#codesize
}

//function GetProcAdress(hLib:integer; name:string):integer;
inline fastcall dword GetProcAdress(dword ECX, EAX)
{
#speed
#codesize
}

inline fastcall dword strlen(dword ESI)
{
#speed
	int len=0;
	while (AL=ESBYTE[ESI])
	{
		len++;
		ESI++;
	}
	EAX=len;
#codesize
}

//-1 - не равны
// 0 - равны
inline fastcall dword strcmp(dword ESI,EDI)
{
#speed
	dword strcmp_i,ret,len1,len2,sovpadenij,str1,str2;
	str1=ESI;
	str2=EDI;
	ret=-1;
	sovpadenij=0;
	len1=strlen(str1);
	len2=strlen(str2);
	if (len1==len2)
	{
		for (strcmp_i=0;strcmp_i<len1;strcmp_i++)
		{
			EAX = str1+strcmp_i;
			EAX = ESBYTE[EAX];
			EBX = str2+strcmp_i;
			EBX = ESBYTE[EBX];
			if (EAX==EBX) sovpadenij++;
		}
		if (sovpadenij==len1) ret=0;
	}
	else ret=-1;
	EAX = ret;
#codesize
}

inline fastcall dword upcase(dword ESI)
{
#speed
	dword str, i;
	str = ESI;
	for (i=0;i<strlen(i);i++)
	{
		EAX = str+i;
		EDX = ESBYTE[EAX];
		if (EDX>=97) && (EDX<=122) ESBYTE[str+i] = DL - 32;	//a-z
		if (EDX>=160) && (EDX<=175) ESBYTE[str+i] = DL - 32;	//а-п
		if (EDX>=224) && (EDX<=239) ESBYTE[str+i] = DL - 80;	//р-я
		if (EDX == 241) ESBYTE[EAX] = 240;					//ё
	}
	EAX = str;
	//EAX = ESDWORD[EAX];
	//if (EAX != 0x5249443C) $int 3;
#codesize
}

inline fastcall dword lowcase(dword ESI)
{
#speed
	dword str, i;
	str = ESI;
	for (i=0;i<strlen(i);i++)
	{
		EAX = str+i;
		EDX = ESBYTE[EAX];
		if (EDX>=65) && (EDX<=90) ESBYTE[str+i] = DL + 32;	//a-z
		if (EDX>=128) && (EDX<=143) ESBYTE[str+i] = DL + 32;	//а-п
		if (EDX>=144) && (EDX<=159) ESBYTE[str+i] = DL + 80;	//р-я
		if (EDX == 240) ESBYTE[EAX] = 241;					//ё
	}
	EAX = str;
	//EAX = ESDWORD[EAX];
	//if (EAX != 0x5249443C) $int 3;
#codesize
}

inline fastcall void dostowin (dword ESI) 
{
#speed
	dword stroka,dlina;
	stroka = ESI;
	while (BL=ESBYTE[ESI])
	{
		if (BL>128)
			if (BL>=240)
				ESBYTE[ESI] = BL - 16;
			else
				ESBYTE[ESI] = BL - 64;
		ESI++;
	}
#codesize
}

void WindowRedrawStatus(dword i)
{
	EAX = 12;              // function 12:tell os about windowdraw
	EBX = i;               // 1, start of draw
	$int 0x40
}

void DefineAndDrawWindow(dword x,y,sizeX,sizeY,byte mainAreaType,dword mainAreaColour,byte headerType,dword headerColour,borderColour)
{
	dword arg1, arg2, arg3, arg4;

	//
	arg1 = x << 16 + sizeX;
	arg2 = y << 16 + sizeY;
	arg3 = mainAreaType << 24 | mainAreaColour;
	arg4 = headerType << 24 | headerColour;
	//
	$mov eax, 0
	$mov ebx, arg1
	$mov ecx, arg2
	$mov edx, arg3
	$mov esi, arg4
	$mov edi, borderColour
	$int 0x40
}
void DefineButton(dword x,y,w,h,id,color)
{
	DrawButton(x<<16+w, skin_width+y<<16+h, id, color);
}
void WriteText(dword x,y,byte fontType, dword color, text, len)
{
	EBX = x<<16+skin_width+y;
	ECX = fontType<<24+color;
	EDX = text;
	ESI = len;
	EAX = 4;
	$int 0x40;
}
void DrawBar(dword x,y,w,h,color)
{
	kos_DrawBar(x<<16+w,skin_width+y<<16+h,color);
}

void DrawRegion(dword x,y,width,height,color1)
{
	DrawBar(x,y,width,1,color1); //полоса гор сверху
	DrawBar(x,y+height,width,1,color1); //полоса гор снизу
	DrawBar(x,y,1,height,color1); //полоса верт слева
	DrawBar(x+width,y,1,height+1,color1); //полоса верт справа
}

void DrawFlatButton(dword x,y,width,height,id,color)
{
	DrawRegion(x,y,width,height,0x94AECE);
	DrawBar(x+1,y+1,width-1,1,0xFFFFFF); //полоса гор белая
	DrawBar(x+1,y+height-1,width-2,1,0xC0C0C0); //тень верт
	DrawBar(x+1,y+1,1,height-1,0xFFFFFF); //полоса верт белая
	DrawBar(x+width-1,y+2,1,height-2,0xC0C0C0); //тень верт
	DrawBar(x+2,y+2,width-3,height-3,color); //заливка
	if (id<>0)
	{
	DefineButton(x,y,width,height,id+BT_DEL,0xEFEBEF); //удаляем кнопку
	DefineButton(x,y,width,height,id+BT_HIDE,0xEFEBEF); //определяем кнопку
	}
}

void PutImage(dword buf,w,h,x,y)
{
	int i,r,g,b;
	EDI=buf;
	EAX = 7;
	EBX = buf;
	ECX = w<<16+h;
	EDX = x<<16+y+skin_width;
	$int 0x40
}

void copystr(dword s,d)
{
	ECX=strlen(d);//очищаем старое
	$mov edi,d
	$xor al,al
	$cld
	$rep $stosb
	
	ECX=strlen(s);//копируем
	$mov esi,s
	$mov edi,d
	$cld
	$rep $movsb
}
int		pos,razr,backup,j=0;
char	buffer[11]="";
int		chislo;
inline fastcall dword IntToStr(dword ESI)
{
#speed
	chislo=ESI;
	ECX=12;
	$push edi
	$mov edi,#buffer
	$xor al,al
	$cld
	$rep $stosb
	pos=razr=backup=j=0;
	if (chislo<0)
	{
		buffer[pos]='-';
		chislo=-1*chislo;
		pos++;
	}
	backup=chislo;
	do
	{
		backup=backup/10;
		razr++;
	}
	while (backup!=0);
	razr--;
	for (j=razr+pos;j>pos-1;j--)
	{
		backup=chislo/10;
		backup=backup*10;
		buffer[j]=chislo-backup+48;
		chislo=chislo/10;
	}
	//return #buffer;
	$pop edi;
	EAX = #buffer;
#codesize
}

inline fastcall dword MoveSize(dword EBX,ECX,EDX,ESI)
{
#speed
	EAX = 67;
	$int 0x40
#codesize
}

f70	CopyFile_f;
BDVK CopyFile_atr;
inline fastcall dword CopyFile(dword EBX,ECX)
{
#speed
	dword s, d, buf;
	s = EBX;
	d = ECX;
	
	CopyFile_f.func = 5;
	CopyFile_f.param1 = 0;
	CopyFile_f.param2 = 0;
	CopyFile_f.param3 = 0;
	CopyFile_f.param4 = #CopyFile_atr;
	CopyFile_f.rezerv = 0;
	CopyFile_f.name = s;
	$mov	eax, 70
	$mov	ebx, #CopyFile_f
	$int	0x40
	
	if (EAX == 0)
	{	
		buf = malloc(CopyFile_atr.sizelo);	
		CopyFile_f.func = 0;
		CopyFile_f.param1 = 0;
		CopyFile_f.param2 = 0;
		CopyFile_f.param3 = CopyFile_atr.sizelo;
		CopyFile_f.param4 = buf;
		CopyFile_f.rezerv = 0;
		CopyFile_f.name = s;
		$mov	eax, 70
		$mov	ebx, #CopyFile_f
		$int	0x40
	
		if (EAX == 0)
		{
			CopyFile_f.func = 2;
			CopyFile_f.param1 = 0;
			CopyFile_f.param2 = 0;
			CopyFile_f.param3 = CopyFile_atr.sizelo;
			CopyFile_f.param4 = buf;
			CopyFile_f.rezerv = 0;
			CopyFile_f.name = d;
			$mov	eax, 70
			$mov	ebx, #CopyFile_f
			$int	0x40
		}
	}
#codesize
}
