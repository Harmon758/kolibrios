/*
Just Clicks v0.4
Copyright (C) 2008 Leency & Veliant
Clickomania v0.3
Copyright (C) 2005 Александр Мушиков aka Olaf
Compiled by C--Sphinx v0.239 b26
*/

#pragma option meos
#jumptomain NONE
#include "files\kolibri.h--"
#include "files\random.h--"

//локализация и настройки
dword header = "Just Clicks v0.4 L&V";
//

byte y, i, count, need_redraw, num, id, mark, XX, YY; 	 //j,

struct
{
  byte x;
  byte y;
  byte button_id;
  byte mark;
  dword color;
}matrix[8*8];

inline fastcall void sys_draw_button(dword EBX, ECX, EDX, ESI)
{ EAX = 8;  $int 0x40 }


void destroy_button(dword ID)
dword dest_color;
{
	dest_color=matrix[ID].color;
	IF ((matrix[ID-8].color == dest_color)&&(matrix[ID-8].mark!=1)){
		matrix[ID-8].mark=1;
		need_redraw=1;
		destroy_button(ID-8);
	}
	IF ((matrix[ID+8].color == dest_color)&&(matrix[ID+8].mark!=1)){
		matrix[ID+8].mark=1;
		need_redraw=1;
		destroy_button(ID+8);
	}
	IF ((ID!=0)&&(ID!=8)&&(ID!=16)&&(ID!=24)&&(ID!=32)&&(ID!=40)&&(ID!=48)&&(ID!=56)){
    	IF ((matrix[ID-1].color == dest_color)&&(matrix[ID-1].mark!=1)){
			matrix[ID-1].mark=1;
			need_redraw=1;
			destroy_button(ID-1);
    	}
	}
	IF ((ID!=7)&&(ID!=15)&&(ID!=23)&&(ID!=31)&&(ID!=39)&&(ID!=47)&&(ID!=55)&&(ID!=63)){
	    IF ((matrix[ID+1].color == dest_color)&&(matrix[ID+1].mark!=1)){
			matrix[ID+1].mark=1;
			need_redraw=1;
			destroy_button(ID+1);
		}
	}
	IF (matrix[ID].x<XX){
		XX=matrix[ID].x;
		IF (matrix[ID].y>YY) YY=matrix[ID].y;
	}
	IF (matrix[ID].y>YY){
		YY=matrix[ID].y;
	    IF (matrix[ID].x<XX)	XX=matrix[ID].x;
	}
}

void shift_bars(byte AA, BB)
byte id_curr,id_next,bz;
{
  for (j=AA;j<8;j++)
  {
	i=BB;
	while (i>0)
	{
		id_curr=i*8+j;
		bz=i-1;
		_HH:
		id_next=bz*8+j;
		IF (matrix[id_curr].mark == 1){
			IF (bz>0)&&(matrix[id_next].mark == 1){
				bz--;
				GOTO _HH;
			}ELSE IF (matrix[id_next].mark == 0){
				matrix[id_curr].color=matrix[id_next].color;
				matrix[id_curr].mark=matrix[id_next].mark;
				matrix[id_next].mark=1;
			}
		};
		i--;
	}
  }
}

byte count_blocks()
byte kol_vo;
{
	kol_vo=0;
	FOR (i=0;i<8;i++) FOR (j=0;j<8;j++) IF (matrix[j*8+i].mark==0) kol_vo++;
	return kol_vo;
}


byte check_for_end ()
byte end, id_next_two, id_next_one, crr;
{
	end=1;
	j=0;
	while (end==1)&&(j<8){
		i=0;
		while (end==1)&&(i<8)
		{
			crr=j*8+i;
			id_next_one=crr+1;
			id_next_two=j+1;
			id_next_two=id_next_two*8+i;
			IF(matrix[crr].color==matrix[id_next_one].color)&&(matrix[crr].mark==0)&&(matrix[id_next_one].mark==0)&&(i<7)	end=0;
			IF (matrix[crr].color==matrix[id_next_two].color)&&(matrix[crr].mark==0)&&(matrix[id_next_two].mark==0) end=0;
			i++;
		}
		j++;
	}
	return end;
}

void move_it ()
byte but_id, but_id_curr,but_id_next, x, y, xx, yy;
{
	for (x=0;x<8;x++){
		count = 0;
		FOR (y=0;y<8;y++)
		{
			but_id=y*8+x;
			IF (matrix[but_id].mark==1) count++;
		}
		if (count == 8) for (yy=0;yy<8;yy++)
			{
				xx=x;
				WHILE (xx<7)
				{
					but_id_curr=yy*8+xx;
					but_id_next=yy*8+xx+1;
					matrix[but_id_curr].mark=matrix[but_id_next].mark;
					matrix[but_id_curr].color=matrix[but_id_next].color;
					matrix[but_id_next].mark=1;
					IF (xx+1 == 7)	matrix[but_id_next].mark=1;
					xx++;
				}
			}
	}
}


void main()
{
	randomize();
	ReDraw_Blocks(1);
	loop()
	{
		switch(WaitEvent())
		{
			CASE evButton:
				id=GetButtonID();
				IF (id==600) {ExitProcess(); break;}
				ELSE IF (id==500) {ReDraw_Blocks(1);break;}
				ELSE	{
     					destroy_button(id);
						IF (XX!=9)&&(need_redraw==1)
						{
						shift_bars(XX,YY);
						IF (YY == 7) {move_it();move_it();}
						XX=9;
						YY=0;
						ReDraw_Blocks(0);
						}
					 	break;
					}
			case evKey: IF (GetKey()==051) ReDraw_Blocks(1); break;//New game
			case evReDraw:	draw_window();	break;
		}
	}
	ExitProcess();
}

void ReDraw_Blocks(dword newgame)
{
	num=0;
	for (i=0;i<8;i++) FOR (j=0;j<8;j++) DefineButton(1,1,1,1,i*8+j+BT_DEL,1);
	y=skin_width;
	for (i=0;i<8;i++)
	{
		for (j=0;j<8;j++)
		{
			if (newgame == 1)
			{
				matrix[num].mark=0;
				XX=9;
				YY=0;
				SWITCH (random(5))
				{
				   CASE 0: matrix[num].color=0x083366CC;BREAK; //Brown
				   CASE 1: matrix[num].color=0x08FF3333;BREAK; //Red
				   CASE 2: matrix[num].color=0x0866CC00;BREAK; //Green
				   CASE 3: matrix[num].color=0x0833CCFF;BREAK; //light Blue
				   CASE 4: matrix[num].color=0x08FF9900;	  //Orange
				};
			}
			mark=matrix[num].mark;
			matrix[num].x=j;
			matrix[num].y=i;
			IF (mark==0) sys_draw_button(j*21+5 << 16 + 20, y << 16 + 20, num, matrix[num].color);
				ELSE kos_DrawBar(j*21+5 << 16 + 21, y << 16 + 21, 0xB2B4BF);
			num++;
		}
		y=y+21;
	}
	EDI = 0x00E4DFE1;  //цвет панели
	IF (check_for_end()==1) WriteText(95,184,0xC0,0x000000,"Результат:",10);
	ELSE {
		WriteText(95,184,0xC0,0x000000," Осталось:",10);
		WriteText(155,184,0xC0,0x000000,IntToStr(count_blocks()),0); //Блоков осталось
		}
	need_redraw=0; newgame=0;
}

void draw_window()
{
	WindowRedrawStatus(1);
	skin_width = GetSkinWidth();
	DefineAndDrawWindow(300,176,177,201+skin_width,0x04,0x00B2B4BF,0,0,0);
	DefineButton(155,2-skin_width,18,18,600+BT_HIDE+BT_NOFRAME,0x0866CC00); //кнопка закрытия
	DrawTitle(#header);
	DrawBar(5,168,168,29,0xE4DFE1); //поле снизу
	DrawFlatButton(9,172,84,19,500,0xE4DFE1); //New
		WriteText(14,178,0x80,0x5F86B6,"New game (F2) ",14);
	WriteText(95,172,0x80,0,"  Уровень:01",10); //Уровень
	ReDraw_Blocks(0);
	WindowRedrawStatus(2);
}

stop:
