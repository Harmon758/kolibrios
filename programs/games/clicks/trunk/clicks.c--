/*
Just Clicks v0.76
Copyright (C) 2008 Leency
Clickomania v0.3
Copyright (C) 2005 Александр Мушиков aka Olaf
Compiled by C--Sphinx v0.239 b26
*/

#pragma option meos
#include "lib\kolibri.h--"
#include "lib\random.h--"
#include "files\boxes.txt"
#include "files\cups.txt"

#ifndef AUTOBUILD
#include "lang.h--"
#endif

byte i,j, XX, YY;
system_colors sc;

struct
{
  byte x;
  byte y;
  byte button_id;
  byte mark;
  dword color;
}matrix[64];


void check_n_destroy(byte ID, ID1)
{
	IF (matrix[ID1].color == matrix[ID].color) && (matrix[ID1].mark!=1)
	{
		matrix[ID1].mark=1;
		destroy_button(ID1);
	}
}


void destroy_button(byte ID)
{
	check_n_destroy(ID, ID-8);
	check_n_destroy(ID, ID+8);
		IF (ID!=0)&&(ID!=8)&&(ID!=16)&&(ID!=24)&&(ID!=32)&&(ID!=40)&&(ID!=48)&&(ID!=56)
	check_n_destroy(ID, ID-1);
		IF (ID!=7)&&(ID!=15)&&(ID!=23)&&(ID!=31)&&(ID!=39)&&(ID!=47)&&(ID!=55)&&(ID!=63)
	check_n_destroy(ID, ID+1);

	IF (matrix[ID].x<XX) {XX=matrix[ID].x;  IF (matrix[ID].y>YY) YY=matrix[ID].y;}
	IF (matrix[ID].y>YY) {YY=matrix[ID].y;  IF (matrix[ID].x<XX) XX=matrix[ID].x;}
}


void shift_bars(byte AA, BB)
byte id_curr,id_next,bz;
{
  for (j=AA;j<8;j++) for (i=BB; i>0; i--)
	{
		id_curr=i*8+j;
		bz=i-1;
		_HH:
		id_next=bz*8+j;
		IF (matrix[id_curr].mark == 1)
			IF (bz>0)&&(matrix[id_next].mark == 1) {bz--; GOTO _HH;}
			ELSE IF (matrix[id_next].mark == 0)
			{
				matrix[id_curr].color=matrix[id_next].color;
				matrix[id_curr].mark=matrix[id_next].mark;
				matrix[id_next].mark=1;
			}
	}
}

byte check_for_end()
{
	byte id_next, id_curr;
	for (j=0; j<64; j+=8)  for (i=0; i<8; i++)
		{
			id_curr=j+i;
			id_next=id_curr+1;
			IF (matrix[id_curr].color==matrix[id_next].color)&&(matrix[id_curr].mark==0)&&(matrix[id_next].mark==0) return 0;
			IF (matrix[id_curr].color==matrix[id_next+7].color)&&(matrix[id_curr].mark==0)&&(matrix[id_next+7].mark==0) return 0;
		}
	return 1;
}

void move_it()
byte but_id, count, x;
{
	for (x=0;x<8;x++)
	{
		count = 0;
		FOR (i=0;i<8;i++) IF (matrix[i*8+x].mark==1) count++;
		if (count == 8) FOR (i=0;i<8;i++)
			{
				XX=x;
				WHILE (XX<7)
				{
					but_id=i*8+XX;
					matrix[but_id].mark=matrix[but_id+1].mark;
					matrix[but_id].color=matrix[but_id+1].color;
					IF (XX == 6)	matrix[but_id+1].mark=1;
					XX++;
				}
			}
	}
}


void ReDraw_Blocks(byte newgame)
{
	byte num=0, y=22, count_blocks=0, temp[10];
	for (i=0;i<8;i++)
	{
		for (j=0;j<8;j++)
		{
			IF (newgame)
			{
				matrix[num].mark=0;
				XX=9; YY=0;
				matrix[num].color = random(5)+1;
			}
			DeleteButton(i*8+j);
			matrix[num].x=j;
			matrix[num].y=i;
			IF (matrix[num].mark==0)
				{
				DefineButton(j*21,y-22, 20, 20, num+BT_HIDE, 0);
				PutImage(matrix[num].color-1*1323+#img,21,21,j*21,y-22);
				}
			ELSE
				DrawBar(j*21,y-22,21,21, 0xB2B4BF);
			num++;
		}
		y=y+21;
	}
#ifdef LANG_RUS
	DrawBar(90,178,71,8,sc.work);
	IF (check_for_end()==1) WriteText(90,178,0x80,sc.work_text,"Результат:",10);
	ELSE WriteText(96,178,0x80,sc.work_text,"Осталось:",10);
#else
	DrawBar(108,178,60,8,sc.work);
	IF (check_for_end()==1) WriteText(108,178,0x80,sc.work_text,"Result:",10);
	ELSE WriteText(108,178,0x80,sc.work_text,"Blocks:",10);
#endif
	FOR (i=0;i<8;i++) FOR (j=0;j<8;j++) IF (matrix[j*8+i].mark==0) count_blocks++;
	WriteNumber(150,178,0x80,sc.work_text,count_blocks);
	//
	if (check_for_end()==1) && (count_blocks<8)
	{
		DrawFlatButton();
#ifdef LANG_RUS
		IF (count_blocks==0) copystr(" Лучше всех!", #temp);  
		IF (count_blocks==1) copystr("  Прекрасно", #temp);
		IF (count_blocks==2) copystr("Очень хорошо!", #temp);
#else
		IF (count_blocks==0) copystr("The best!", #temp);
		IF (count_blocks==1) copystr("Wonderful", #temp);
		IF (count_blocks==2) copystr("Very good", #temp);
#endif
		IF (count_blocks>=3) //баг!!!
		{
#ifdef LANG_RUS
			copystr("   Неплохо", #temp);
#else
			copystr(" Not bed", #temp);
#endif
			count_blocks=3;
		}
		PutImage(count_blocks*4662+#cups,42,37,63,48);
#ifdef LANG_RUS
		WriteText(46,91,0x80,0x0,#temp,0);
#else
		WriteText(58,91,0x80,0x0,#temp,0);
#endif
	}
}


void main()
{	byte id;
	//randomize();
	ReDraw_Blocks(1);
	loop()
	{
		switch(WaitEvent())
		{
			CASE evKey:
				IF (GetKey()==051) ReDraw_Blocks(1); //New game
				break;
			CASE evButton:
				id=GetButtonID();
				IF (id==255) ExitProcess();
				IF (id==254) ReDraw_Blocks(1); //New game
				IF (id<65) //Color Button
				{ 	
     				destroy_button(id);
					IF (XX!=9)
					{
						shift_bars(XX,YY);
						IF (YY==7) {move_it();move_it();}
						XX=9;
						YY=0;
						ReDraw_Blocks(0);
					}
				}    
				break;
			case evReDraw:
				WindowRedrawStatus(1);
				DefineAndDrawWindow(400,276,177,201+GetSkinWidth(),0x74,0x10B2B4BF,0,0,"Just Clicks v0.77");
				WindowRedrawStatus(2);
				sc.get();
				DefineButton(150,-18,18,18,255+BT_HIDE+BT_NOFRAME,0); //кнопочка закрытия :]
				DrawBar(0,168,168,29,sc.work); //панелька снизу
#ifdef LANG_RUS
				DefineButton(9,172,76,19,254,sc.work_button);
				WriteText(16,178,0x80,sc.work_button_text,"Заново (F2)",0);
#else
				DefineButton(9,172,86,19,254,sc.work_button);
				WriteText(15,178,0x80,sc.work_button_text,"New game (F2)",0);
#endif
				ReDraw_Blocks(0);
		}
	}
}


void DrawFlatButton()
{
	DrawBar(21,42,125,1,0x94AECE); //полоса гор сверху
	DrawBar(21,104,125,1,0x94AECE); //полоса гор снизу
	DrawBar(21,42,1,62,0x94AECE); //полоса верт слева
	DrawBar(146,42,1,63,0x94AECE); //полоса верт справа
	DrawBar(22,43,124,1,0xFFFFFF); //полоса гор белая
	DrawBar(22,103,123,1,0xC7C7C7); //тень верт
	DrawBar(22,43,1,61,0xFFFFFF); //полоса верт белая
	DrawBar(145,44,1,60,0xC7C7C7); //тень верт
	DrawBar(23,44,122,59,0xE4DFE1); //заливка
}

stop:
