/*
Just Clicks v0.6
Copyright (C) 2008 Leency & Veliant
Clickomania v0.3
Copyright (C) 2005 Александр Мушиков aka Olaf
Compiled by C--Sphinx v0.239 b26
*/

#pragma option meos
#jumptomain NONE
#include "lib\kolibri.h--"
#include "lib\random.h--"
#include "img.txt"

byte i, need_redraw, XX, YY;

struct
{
  byte x;
  byte y;
  byte button_id;
  byte mark;
  dword color;
}matrix[8*8];



void destroy_button(dword ID)
{
	IF ((matrix[ID-8].color == matrix[ID].color)&&(matrix[ID-8].mark!=1)){
		matrix[ID-8].mark=1;
		need_redraw=1;
		destroy_button(ID-8);
	}
	IF ((matrix[ID+8].color == matrix[ID].color)&&(matrix[ID+8].mark!=1)){
		matrix[ID+8].mark=1;
		need_redraw=1;
		destroy_button(ID+8);
	}
	IF ((ID!=0)&&(ID!=8)&&(ID!=16)&&(ID!=24)&&(ID!=32)&&(ID!=40)&&(ID!=48)&&(ID!=56))
    		IF ((matrix[ID-1].color == matrix[ID].color)&&(matrix[ID-1].mark!=1)){
			matrix[ID-1].mark=1;
			need_redraw=1;
			destroy_button(ID-1);
    		}
	IF ((ID!=7)&&(ID!=15)&&(ID!=23)&&(ID!=31)&&(ID!=39)&&(ID!=47)&&(ID!=55)&&(ID!=63))
	    IF ((matrix[ID+1].color == matrix[ID].color)&&(matrix[ID+1].mark!=1)){
			matrix[ID+1].mark=1;
			need_redraw=1;
			destroy_button(ID+1);
		}
	IF (matrix[ID].x<XX){XX=matrix[ID].x;  IF (matrix[ID].y>YY) YY=matrix[ID].y;}
	IF (matrix[ID].y>YY){YY=matrix[ID].y;  IF (matrix[ID].x<XX) XX=matrix[ID].x;}
}

void shift_bars(byte AA, BB)
byte id_curr,id_next,bz;
{
  for (j=AA;j<8;j++) for (i=BB; i>0; i--)
	{
		id_curr=i*8+j;
		bz=i-1;
		_HH:
		id_next=bz*8+j;
		IF (matrix[id_curr].mark == 1)
			IF (bz>0)&&(matrix[id_next].mark == 1) {bz--; GOTO _HH;}
			ELSE IF (matrix[id_next].mark == 0)
			{
				matrix[id_curr].color=matrix[id_next].color;
				matrix[id_curr].mark=matrix[id_next].mark;
				matrix[id_next].mark=1;
			}
	}
}

byte count_blocks()
{
	byte kol_vo=0;
	FOR (i=0;i<8;i++) FOR (j=0;j<8;j++) IF (matrix[j*8+i].mark==0) kol_vo++;
	return kol_vo;
}


byte check_for_end ()
byte id_next_two, id_next_one, crr;
{
	for (j=0; j<8; j++)	for (i=0; i<8; i++)
		{
			crr=j*8+i;
			id_next_one=crr+1;
			id_next_two=j+1*8+i;
			IF (matrix[crr].color==matrix[id_next_one].color)&&(matrix[crr].mark==0)&&(matrix[id_next_one].mark==0) return 0;
			IF (matrix[crr].color==matrix[id_next_two].color)&&(matrix[crr].mark==0)&&(matrix[id_next_two].mark==0) return 0;
		}
	return 1;
}

void move_it ()
byte but_id_curr,but_id_next, count, x;
{
	for (x=0;x<8;x++)
	{
		count = 0;
		FOR (i=0;i<8;i++) IF (matrix[i*8+x].mark==1) count++;
		if (count == 8) for (i=0;i<8;i++)
			{
				XX=x;
				WHILE (XX<7)
				{
					but_id_curr=i*8+XX;
					but_id_next=i*8+XX+1;
					matrix[but_id_curr].mark=matrix[but_id_next].mark;
					matrix[but_id_curr].color=matrix[but_id_next].color;
					matrix[but_id_next].mark=1;
					IF (XX+1 == 7)	matrix[but_id_next].mark=1;
					XX++;
				}
			}
	}
}


void main()
{	dword id;
	randomize();
	skin_width = GetSkinWidth();
	ReDraw_Blocks(1);
	loop()
	{
		switch(WaitEvent())
		{
			CASE evButton:
				id=GetButtonID();
				IF (id==600) {ExitProcess(); break;}
				ELSE IF (id==500) {ReDraw_Blocks(1);break;}
				ELSE	{
     					destroy_button(id);
						IF (XX!=9)&&(need_redraw==1)
						{
						shift_bars(XX,YY);
						IF (YY == 7) {move_it();move_it();}
						XX=9;
						YY=0;
						ReDraw_Blocks(0);
						}
					 	break;
					}
			case evKey: IF (GetKey()==051) ReDraw_Blocks(1); break;//New game
			case evReDraw:	draw_window();	break;
		}
	}
	ExitProcess();
}

void ReDraw_Blocks(dword newgame)
{
	dword num=0, y;
	y=skin_width;
	for (i=0;i<8;i++)
	{
		for (j=0;j<8;j++)
		{
			IF (newgame == 1)
			{
				matrix[num].mark=0;
				XX=9; YY=0;
				matrix[num].color = random(5)+1;
			}
			DefineButton(1,1,1,1,i*8+j+BT_DEL,1);
			matrix[num].x=j;
			matrix[num].y=i;
			IF (matrix[num].mark==0)
				{
				DefineButton(j*21+5,y-22, 20, 20, num+BT_HIDE, matrix[num].color);
				PutImage(matrix[num].color-1*21*21*3+#img,21,21,j*21+5,y-22);
				}	ELSE DrawBar(j*21+5,y-22,21,21, 0xB2B4BF);
			num++;
		}
		y=y+21;
	}
	EDI = 0x00E4DFE1;  //цвет панели
	IF (check_for_end()==1) WriteText(95,178,0xC0,0x000000,"Результат:",10); //184
		ELSE WriteText(95,178,0xC0,0x000000," Осталось:",10);
	WriteText(155,178,0xC0,0x000000,IntToStr(count_blocks()),0); //Блоков осталось
		IF (count_blocks()<10) DrawBar(161,178,6,8,0xE4DFE1);
	need_redraw=0;
}

void draw_window()
{
	WindowRedrawStatus(1);
	DefineAndDrawWindow(300,176,177,201+skin_width,0x04,0x00B2B4BF,0,0,0);
	DefineButton(155,2-skin_width,18,18,600+BT_HIDE+BT_NOFRAME,0x0866CC00); //кнопка закрытия
	DrawTitle("Just Clicks v0.6 L&V");
	DrawBar(5,168,168,29,0xE4DFE1); //поле снизу
	DrawFlatButton(9,172,84,19,500,0xE4DFE1); //New E4DFE1
		WriteText(14,178,0x80,0,"New game (F2) ",14);
	//WriteText(95,172,0x80,0,"  Уровень:01",10); //Уровень
	ReDraw_Blocks(0);
	WindowRedrawStatus(2);
}

stop:
