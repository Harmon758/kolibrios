СИСТЕМНЫЕ ФУНКЦИИ ОПЕРАЦИОННОЙ СИСТЕМЫ Kolibri 0.7.0.0

Номер функции помещается в регистр eax.
Вызов системной функции осуществляется командой "int 0x40".
Все регистры, кроме явно указанных в возвращаемом значении,
    включая регистр флагов eflags, сохраняются.


======================================================================
============== Функция 0 - определить и нарисовать окно. =============
======================================================================
Определяет окно приложения. Рисует рамку окна, заголовок и рабочую
область. Для окон со скином определяет стандартные кнопки закрытия и
минимизации.
Параметры:
  * eax = 0 - номер функции
  * ebx = [координата по оси x]*65536 + [размер по оси x]
  * ecx = [координата по оси y]*65536 + [размер по оси y]
  * edx = 0xXYRRGGBB, где:
    * Y = стиль окна:
      * Y=0 - тип I - окно фиксированных размеров
      * Y=1 - только определить область окна, ничего не рисовать
      * Y=2 - тип II - окно изменяемых размеров
      * Y=3 - окно со скином
      * Y=4 - окно со скином и фиксированными размерами
      * остальные возможные значения (от 4 до 15) зарезервированы,
        вызов функции с такими Y игнорируется
    * RR, GG, BB = соответственно красная, зеленая, синяя
      составляющие цвета рабочей области окна
      (игнорируется для стиля Y=2)
    * X = DCBA (биты)
      * A = 1 - у окна есть заголовок; для стиля Y=3 адрес строки
                  заголовка задаётся в edi, для прочих стилей
                  используется подфункция 1 функции 71
      * B = 1 - координаты всех графических примитивов задаются
                  относительно клиентской области окна
      * C = 1 - не закрашивать рабочую область при отрисовке окна
      * D = 0 - нормальная заливка рабочей области, 1 - градиентная
    Следующие параметры предназначены для окон типа I и II и
    игнорируются для стилей Y=1,3:
  * esi = 0xXYRRGGBB - цвет заголовка
    * RR, GG, BB определяют сам цвет
    * Y=0 - обычное окно, Y=1 - неперемещаемое окно
    * X определяет градиент заголовка: X=0 - нет градиента,
      X=8 - обычный градиент,
      для окон типа II X=4 - негативный градиент
    * прочие значения X и Y зарезервированы
  * edi = 0x00RRGGBB - цвет рамки
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Положение и размеры окна устанавливаются при первом вызове
    этой функции и игнорируются при последующих; для изменения
    положения и/или размеров уже созданного окна используйте
    67-ю функцию.
  * Для окон стиля Y=3 с заголовком (A=1) строка заголовка
    устанавливается при первом вызове этой функции и игнорируется при
    последующих (точнее говоря, игнорируется после вызова
    подфункции 2 функции 12 - конца перерисовки);
    для изменения строки заголовка уже созданного окна используйте
    подфункцию 1 функции 71.
  * Если использовать окна соответствующих стилей, то положение
    и/или размеры окна могут меняться пользователем.
    Текущие положение и размеры могут быть получены вызовом функции 9.
  * Окно должно умещаться на экране. Если переданные координаты
    и размеры не удовлетворяют этому условию, то соответствующая
    координата (или, возможно, обе) считается нулем, а если и это
    не помогает, то соответствующий размер (или, возможно, оба)
    устанавливается в размер экрана.

    Далее обозначим xpos,ypos,xsize,ysize - значения, передаваемые
    в ebx,ecx. Координаты приводятся относительно левого верхнего
    угла окна, который, таким образом, задается как (0,0), координаты
    правого нижнего угла суть (xsize,ysize).
  * Размеры окна понимаются в смысле координат правого нижнего угла.
    Это же относится и ко всем остальным функциям.
    Это означает, что реальные размеры на 1 пиксель больше.
  * Вид окна типа I:
    * рисуется внешняя рамка цвета, указанного в edi,
      шириной 1 пиксель
    * рисуется заголовок - прямоугольник с левым верхним углом (1,1)
      и правым нижним (xsize-1,min(25,ysize)) цвета, указанного в esi
      (с учетом градиента)
    * если ysize>=26, то закрашивается рабочая область окна -
      прямоугольник с левым верхним углом (1,21) и правым нижним
      (xsize-1,ysize-1) (размерами (xsize-1)*(ysize-21)) - цветом,
      указанным в edx (с учетом градиента)
    * если A=1 и строка заголовка установлена подфункцией 1
      функции 71, то она выводится в соответствующем месте заголовка
  * Вид окна стиля Y=1:
    * полностью определяется приложением
  * Вид окна типа II:
    * рисуется внешняя рамка шириной 1 пиксель "затенённого" цвета
      edi (все составляющие цвета уменьшаются в два раза)
    * рисуется промежуточная рамка шириной 3 пикселя цвета edi
    * рисуется внутренняя рамка шириной 1 пиксель
      "затенённого" цвета edi
    * рисуется заголовок - прямоугольник с левым верхним углом (4,4)
      и правым нижним (xsize-4,min(20,ysize)) цвета, указанного в esi
      (с учетом градиента)
    * если ysize>=26, то закрашивается рабочая область окна -
      прямоугольник с левым верхним углом (5,20) и правым нижним
      (xsize-5,ysize-5) - цветом, указанным в edx (с учетом градиента)
    * если A=1 и строка заголовка установлена подфункцией 1
      функции 71, то она выводится в соответствующем месте заголовка
  * Вид окна со скином:
    * рисуется внешняя рамка шириной 1 пиксель
      цвета 'outer' из скина
    * рисуется промежуточная рамка шириной 3 пикселя
      цвета 'frame' из скина
    * рисуется внутренняя рамка шириной 1 пиксель
      цвета 'inner' из скина
    * рисуется заголовок (по картинкам из скина) в прямоугольнике
      (0,0) - (xsize,_skinh-1)
    * если ysize>=26, то закрашивается рабочая область окна -
      прямоугольник с левым верхним углом (5,_skinh) и правым нижним
      (xsize-5,ysize-5) - цветом, указанным в edx (с учетом градиента)
    * определяются две стандартные кнопки: закрытия и минимизации
      (смотри функцию 8)
    * если A=1 и в edi (ненулевой) указатель на строку заголовка,
      то она выводится в заголовке в месте, определяемом скином
    * Значение переменной _skinh доступно как результат вызова
      подфункции 4 функции 48

======================================================================
================= Функция 1 - поставить точку в окне. ================
======================================================================
Параметры:
  * eax = 1 - номер функции
  * ebx = x-координата (относительно окна)
  * ecx = y-координата (относительно окна)
  * edx = 0x00RRGGBB - цвет точки
    edx = 0x01xxxxxx - инвертировать цвет точки
          (младшие 24 бита игнорируются)
Возвращаемое значение:
  * функция не возвращает значения

======================================================================
============== Функция 2 - получить код нажатой клавиши. =============
======================================================================
Забирает код нажатой клавиши из буфера.
Параметры:
  * eax = 2 - номер функции
Возвращаемое значение:
  * если буфер пуст, возвращается eax=1
  * если буфер непуст, то возвращается al=0, ah=код нажатой клавиши,
    старшее слово регистра eax обнулено
  * если есть "горячая клавиша", то возвращается
    al=2, ah=сканкод нажатой клавиши (0 для управляющих клавиш),
    старшее слово регистра eax содержит состояние управляющих клавиш
    в момент нажатия горячей клавиши
Замечания:
  * Существует общесистемный буфер нажатых клавиш размером 120 байт,
    организованный как очередь.
  * Существует ещё один общесистемный буфер на 120 "горячих клавиш".
  * При вызове этой функции приложением с неактивным окном
    считается, что буфер нажатых клавиш пуст.
  * По умолчанию эта функция возвращает ASCII-коды; переключиться на
    режим сканкодов (и назад) можно с использованием функции 66.
    Однако, горячие клавиши всегда возвращаются как сканкоды.
  * Узнать, какие комбинации клавиш соответствуют каким кодам, можно,
    запустив приложения keyascii и scancode.
  * Сканкоды возвращаются непосредственно клавиатурой и фиксированы;
    ASCII-коды получаются с использованием таблиц преобразования,
    которые можно установить подфункцией 2 функции 21 и прочитать
    подфункцией 2 функции 26.
  * Как следствие, ASCII-коды учитывают текущую раскладку клавиатуры
    (rus/en) в отличие от сканкодов.
  * Поступает информация только о тех горячих клавишах, которые были
    определены этим потоком подфункцией 4 функции 66.

======================================================================
================ Функция 3 - получить системное время. ===============
======================================================================
Параметры:
  * eax = 3 - номер функции
Возвращаемое значение:
  * eax = 0x00SSMMHH, где HH:MM:SS = часы:минуты:секунды
  * каждый элемент возвращается как BCD-число, например,
    для времени 23:59:59 результат будет 0x00595923
Замечания:
  * Смотри также подфункцию 9 функции 26 - получение времени
    с момента запуска системы; она во многих случаях удобнее,
    поскольку возвращает просто DWORD-значение счетчика времени.
  * Системное время можно установить функцией 22.

======================================================================
============== Функция 4 - вывести строку текста в окно. =============
======================================================================
Параметры:
  * eax = 4 - номер функции
  * ebx = [координата по оси x]*65536 + [координата по оси y]
  * ecx = 0xX0RRGGBB, где
    * RR, GG, BB задают цвет текста
    * X=ABnn (биты):
    * nn задает используемый шрифт: 0=системный моноширинный,
      1=системный шрифт переменной ширины
    * A=0 - выводить esi символов, A=1 - выводить ASCIIZ-строку
    * B=1 - закрашивать фон цветом edi
  * edx = указатель на начало строки
  * esi = для A=0 длина строки, должна быть не больше 255;
          для A=1 игнорируется
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Первый системный шрифт считывается при загрузке из файла char.mt,
    второй - из char2.mt.
  * Оба шрифта имеют высоту 9 пикселей, ширина моноширинного шрифта
    равна 6 пикселей.

======================================================================
========================= Функция 5 - пауза. =========================
======================================================================
Задерживает выполнение программы на заданное время.
Параметры:
  * eax = 5 - номер функции
  * ebx = время в сотых долях секунды
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Передача ebx=0 не передает управление следующему процессу и
    вообще не производит никаких действий. Если действительно
    требуется передать управление следующему процессу
    (закончить текущий квант времени), используйте подфункцию 1
    функции 68.
  * При текущей реализации произойдет немедленный возврат из функции,
    если сложение ebx с текущим значением счетчика времени вызовет
    32-битное переполнение.

======================================================================
=============== Функция 6 - прочитать файл с рамдиска. ===============
======================================================================
Параметры:
  * eax = 6 - номер функции
  * ebx = указатель на имя файла
  * ecx = номер стартового блока, считая с 1;
    ecx=0 - читать с начала файла (то же самое, что и ecx=1)
  * edx = число блоков для чтения;
    edx=0 - читать один блок (то же самое, что и edx=1)
  * esi = указатель на область памяти, куда будут записаны данные
Возвращаемое значение:
  * eax = длина файла в байтах, если файл успешно прочитан
  * eax = -1, если файл не найден
Замечания:
  * Данная функция является устаревшей; функция 70
    позволяет выполнять те же действия с расширенными возможностями.
  * Блок = 512 байт.
  * Для чтения всего файла можно указать заведомо большое значение
    в edx, например, edx = -1; но в этом случае будьте готовы к тому,
    что программа "упадет", если файл окажется слишком большим
    и "не влезет" в память программы.
  * Имя файла должно быть либо в формате 8+3 символов
    (первые 8 символов - собственно имя, последние 3 - расширение,
    короткие имена и расширения дополняются пробелами),
    либо в формате 8.3 символов "FILE.EXT"/"FILE.EX "
    (имя не более 8 символов, точка, расширение 3 символа,
    дополненное при необходимости пробелами).
    Имя файла должно быть записано заглавными буквами.
    Завершающий символ с кодом 0 не нужен (не ASCIIZ-строка).
  * Эта функция не поддерживает папки на рамдиске.

======================================================================
=============== Функция 7 - вывести изображение в окно. ==============
======================================================================
Параметры:
  * eax = 7 - номер функции
  * ebx = указатель на изображение в формате BBGGRRBBGGRR...
  * ecx = [размер по оси x]*65536 + [размер по оси y]
  * edx = [координата по оси x]*65536 + [координата по оси y]
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Координаты изображения - это координаты верхнего левого угла
    изображения относительно окна.
  * Размер изображения в байтах есть 3*xsize*ysize.

======================================================================
=============== Функция 8 - определить/удалить кнопку. ===============
======================================================================
Параметры для определения кнопки:
  * eax = 8 - номер функции
  * ebx = [координата по оси x]*65536 + [размер по оси x]
  * ecx = [координата по оси y]*65536 + [размер по оси y]
  * edx = 0xXYnnnnnn, где:
    * nnnnnn = идентификатор кнопки
    * старший (31-й) бит edx сброшен
    * если 30-й бит edx установлен - не прорисовывать кнопку
    * если 29-й бит edx установлен - не рисовать рамку
      при нажатии на кнопку
  * esi = 0x00RRGGBB - цвет кнопки
Параметры для удаления кнопки:
  * eax = 8 - номер функции
  * edx = 0x80nnnnnn, где nnnnnn - идентификатор кнопки
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Размеры кнопки должны быть больше 0 и меньше 0x8000.
  * Для окон со скином при определении окна (вызове 0-й функции)
    создаются две стандартные кнопки - закрытия окна
    с идентификатором 1 и минимизации окна с идентификатором 0xffff.
  * Создание двух кнопок с одинаковыми идентификаторами
    вполне допустимо.
  * Кнопка с идентификатором 0xffff при нажатии интерпретируется
    системой как кнопка минимизации, система обрабатывает такое
    нажатие самостоятельно, не обращаясь к приложению.
    В остальном это обычная кнопка.
  * Общее количество кнопок для всех приложений ограничено
    числом 4095.

======================================================================
============= Функция 9 - информация о потоке выполнения. ============
======================================================================
Параметры:
  * eax = 9 - номер функции
  * ebx = указатель на буфер размера 1 Кб
  * ecx = номер слота потока
    ecx = -1 - получить информацию о текущем потоке
Возвращаемое значение:
  * eax = максимальный номер слота потока
  * буфер, на который указывает ebx, содержит следующую информацию:
    * +0: dword: использование процессора (сколько тактов в секунду
      уходит на исполнение именно этого потока)
    * +4: word: позиция окна потока в оконном стэке
    * +6: word: (не имеет отношения к запрошенному потоку)
      номер слота потока, окно которого находится в оконном стэке
      в позиции ecx
    * +8: word: зарезервировано
    * +10 = +0xA: 11 байт: имя процесса
      (имя соответствующего исполняемого файла в формате 8+3)
    * +21 = +0x15: byte: зарезервировано, этот байт не изменяется
    * +22 = +0x16: dword: адрес процесса в памяти
    * +26 = +0x1A: dword: размер используемой памяти - 1
    * +30 = +0x1E: dword: идентификатор (PID/TID)
    * +34 = +0x22: dword: координата окна потока по оси x
    * +38 = +0x26: dword: координата окна потока по оси y
    * +42 = +0x2A: dword: размер окна потока по оси x
    * +46 = +0x2E: dword: размер окна потока по оси y
    * +50 = +0x32: word: состояние слота потока:
      * 0 = поток выполняется
      * 1 = поток приостановлен
      * 2 = поток приостановлен в момент ожидания события
      * 3 = поток завершается в результате вызова функции -1 или
        насильственно как следствие вызова подфункции 2 функции 18
        или завершения работы системы
      * 4 = поток завершается в результате исключения
      * 5 = поток ожидает события
      * 9 = запрошенный слот свободен, вся остальная информация о
        слоте не имеет смысла
    * +52 = +0x34: word: зарезервировано, это слово не изменяется
    * +54 = +0x36: dword: координата начала клиентской области
                          по оси x
    * +58 = +0x3A: dword: координата начала клиентской области
                          по оси y
    * +62 = +0x3E: dword: ширина клиентской области
    * +66 = +0x42: dword: высота клиентской области
    * +70 = +0x46: byte: состояние окна - битовое поле
      * бит 0 (маска 1): окно максимизировано
      * бит 1 (маска 2): окно минимизировано в панель задач
      * бит 2 (маска 4): окно свёрнуто в заголовок
Замечания:
  * Слоты нумеруются с 1.
  * Возвращаемое значение не есть общее число потоков, поскольку
    бывают свободные слоты.
  * При создании процесса автоматически создается поток выполнения.
  * Функция выдает информацию о потоке. Каждый процесс имеет
    хотя бы один поток. Один процесс может создать несколько потоков,
    в этом случае каждый поток получает свой слот, причем поля
    +10, +22, +26 в этих слотах совпадают.
    Для приложений не существует общего способа определить,
    принадлежат ли два потока одному процессу.
  * Активное окно - окно, находящееся на вершине оконного стэка,
    оно получает сообщения о вводе с клавиатуры. Для него позиция в
    оконном стэке совпадает с возвращаемым значением.
  * Слот 1 соответствует специальному потоку операционной системы,
    для которого:
    * окно находится внизу оконного стэка, поля +4 и +6 содержат
      значение 1
    * имя процесса - "OS/IDLE" (дополненное пробелами)
    * адрес процесса в памяти равен 0, размер используемой памяти
      16 Mb (0x1000000)
    * PID=1
    * координаты и размеры окна, равно как и клиентской области,
      условно полагаются равными 0
    * состояние слота - всегда 0 (выполняется)
    * время выполнения складывается из времени, уходящего на
      собственно работу, и времени простоя в ожидании прерывания
      (которое можно получить вызовом подфункции 4 функции 18).
  * Начиная со слота 2, размещаются обычные приложения.
  * Обычные приложения размещаются в памяти по адресу 0x60400000
    (константа ядра std_application_base_address).
    Наложения не происходит, поскольку у каждого процесса своя
    таблица страниц.
  * При создании потока ему назначаются слот в системной таблице и
    идентификатор (Process/Thread IDentifier = PID/TID), которые для
    заданного потока не изменяются со временем.
    После завершения потока его слот может быть заново использован
    для другого потока. Идентификатор потока не может быть назначен
    другому потоку даже после завершения первого.
    Назначаемые новым потокам идентификаторы монотонно растут.
  * Если поток еще не определил свое окно вызовом функции 0, то
    положение и размеры этого окна полагаются нулями.
  * Координаты клиентской области окна берутся относительно окна.
  * В данный момент используется только часть буфера размером
    71 = 0x47 байта. Тем не менее рекомендуется использовать буфер
    размером 1 Кб для будущей совместимости, в будущем могут быть
    добавлены некоторые поля.

======================================================================
==================== Функция 10 - ожидать события. ===================
======================================================================
Если очередь сообщений пуста, то ждет появления сообщения в очереди.
В таком состоянии поток не получает процессорного времени.
Затем считывает сообщение из очереди.

Параметры:
  * eax = 10 - номер функции
Возвращаемое значение:
  * eax = событие (смотри список событий)
Замечания:
  * Учитываются только те события, которые входят в маску,
    устанавливаемую функцией 40. По умолчанию это события
    перерисовки, нажатия на клавиши и на кнопки.
  * Для проверки, есть ли сообщение в очереди, используйте функцию 11.
    Чтобы ждать не более определенного времени, используйте
    функцию 23.

======================================================================
======= Функция 11 - проверить, есть ли событие, без ожидания. =======
======================================================================
Если в очереди сообщений есть какое-то событие, то считывает и
возвращает его. Если очередь пуста, возвращает нуль.
Параметры:
  * eax = 11 - номер функции
Возвращаемое значение:
  * eax = 0 - очередь сообщений пуста
  * иначе eax = событие (смотри список событий)
Замечания:
  * Учитываются только те события, которые входят в маску,
    устанавливаемую функцией 40. По умолчанию это события
    перерисовки, нажатия на клавиши и на кнопки.
  * Для ожидания появления события в очереди, используйте функцию 10.
    Чтобы ждать не более определенного времени, используйте
    функцию 23.

======================================================================
=========== Функция 12 - начать/закончить перерисовку окна. ==========
======================================================================

-------------- Подфункция 1 - начать перерисовку окна. ---------------
Параметры:
  * eax = 12 - номер функции
  * ebx = 1 - номер подфункции
Возвращаемое значение:
  * функция не возвращает значения

------------- Подфункция 2 - закончить перерисовку окна. -------------
Параметры:
  * eax = 12 - номер функции
  * ebx = 2 - номер подфункции
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Функция начала перерисовки удаляет все определённые
    функцией 8 кнопки, их следует определить повторно.

======================================================================
============ Функция 13 - нарисовать прямоугольник в окне. ===========
======================================================================
Параметры:
  * eax = 13 - номер функции
  * ebx = [координата по оси x]*65536 + [размер по оси x]
  * ecx = [координата по оси y]*65536 + [размер по оси y]
  * edx = цвет 0xRRGGBB или 0x80RRGGBB для градиентной заливки
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Под координатами понимаются координаты левого верхнего угла
    прямоугольника относительно окна.

======================================================================
================ Функция 14 - получить размеры экрана. ===============
======================================================================
Параметры:
  * eax = 14 - номер функции
Возвращаемое значение:
  * eax = [xsize]*65536 + [ysize], где
  * xsize = x-координата правого нижнего угла экрана =
            размер по горизонтали - 1
  * ysize = y-координата правого нижнего угла экрана =
            размер по вертикали - 1
Замечания:
  * Смотри также подфункцию 5 функции 48 - получить размеры рабочей
    области экрана.

======================================================================
= Функция 15, подфункция 1 - установить размер фонового изображения. =
======================================================================
Параметры:
  * eax = 15 - номер функции
  * ebx = 1 - номер подфункции
  * ecx = ширина изображения
  * edx = высота изображения
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Вызов функции обязателен перед вызовом подфункций 2 и 5.
  * Для обновления экрана (после завершения серии команд, работающих с
    фоном) вызывайте подфункцию 3 перерисовки фона.
  * Есть парная функция получения размеров фонового изображения -
    подфункция 1 функции 39.

======================================================================
= Функция 15, подфункция 2 - поставить точку на фоновом изображении. =
======================================================================
Параметры:
  * eax = 15 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = смещение
  * edx = цвет точки 0xRRGGBB
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Смещение для точки с координатами (x,y) вычисляется как
    (x+y*xsize)*3.
  * Если указанное смещение превышает установленный подфункцией 1
    размер, вызов игнорируется.
  * Для обновления экрана (после завершения серии команд, работающих с
    фоном) вызывайте подфункцию 3 перерисовки фона.
  * Есть парная функция получения точки с фонового изображения -
    подфункция 2 функции 39.

======================================================================
============ Функция 15, подфункция 3 - перерисовать фон. ============
======================================================================
Параметры:
  * eax = 15 - номер функции
  * ebx = 3 - номер подфункции
Возвращаемое значение:
  * функция не возвращает значения

======================================================================
===== Функция 15, подфункция 4 - установить режим отрисовки фона. ====
======================================================================
Параметры:
  * eax = 15 - номер функции
  * ebx = 4 - номер подфункции
  * ecx = режим отрисовки:
    * 1 = замостить
    * 2 = растянуть
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Для обновления экрана (после завершения серии команд, работающих с
    фоном) вызывайте подфункцию 3 перерисовки фона.
  * Есть парная команда получения режима отрисовки фона -
    подфункция 4 функции 39.

======================================================================
===== Функция 15, подфункция 5 - поместить блок пикселей на фон. =====
======================================================================
Параметры:
  * eax = 15 - номер функции
  * ebx = 5 - номер подфункции
  * ecx = указатель на данные в формате BBGGRRBBGGRR...
  * edx = смещение в данных фонового изображения
  * esi = размер данных в байтах = 3 * число пикселей
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Проверки корректности смещения и размера не производится.
  * Цвет каждого пикселя хранится как 3-байтная величина BBGGRR.
  * Пиксели фонового изображения записываются последовательно
    слева направо, сверху вниз.
  * Смещение пикселя с координатами (x,y) есть (x+y*xsize)*3.
  * Для обновления экрана (после завершения серии команд, работающих с
    фоном) вызывайте подфункцию 3 перерисовки фона.

======================================================================
====================== Функция 15, подфункция 6 ======================
==== Спроецировать данные фона на адресное пространство процесса. ====
======================================================================
Параметры:
  * eax = 15 - номер функции
  * ebx = 6 - номер подфункции
Возвращаемое значение:
  * eax = указатель на данные фона, 0 при ошибке
Замечания:
  * Спроецированные данные доступны на чтение и запись.
  * Размер данных фона равен 3*xsize*ysize. Изменение размеров фона
    блокируется на время работы с спроецированными данными.
  * Цвет каждого пикселя хранится как 3-байтовая величина BBGGRR.
  * Пиксели фонового изображения записываются последовательно
    слева направо, сверху вниз.

======================================================================
====================== Функция 15, подфункция 7 ======================
=== Закрыть проекцию данных фона на адресное пространство процесса. ==
======================================================================
Параметры:
  * eax = 15 - номер функции
  * ebx = 7 - номер подфункции
  * ecx = указатель на данные фона
Возвращаемое значение:
  * eax = 1 при успехе, 0 при ошибке

======================================================================
============= Функция 16 - сохранить рамдиск на дискету. =============
======================================================================
Параметры:
  * eax = 16 - номер функции
  * ebx = 1 или ebx = 2 - на какую дискету сохранять
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - ошибка

======================================================================
============== Функция 17 - получить код нажатой кнопки. =============
======================================================================
Забирает код нажатой кнопки из буфера.
Параметры:
  * eax = 17 - номер функции
Возвращаемое значение:
  * если буфер пуст, возвращается eax=1
  * если буфер непуст, то возвращается al=0, старшие 24 бита eax
    содержат идентификатор кнопки (в частности, в ah оказывается
    младший байт идентификатора; если все кнопки имеют идентификатор,
    меньший 256, то для различения достаточно ah)
Замечания:
  * "Буфер" хранит только одну кнопку, при нажатии новой кнопки
    информация о старой теряется.
  * При вызове этой функции приложением с неактивным окном
    возвращается ответ "буфер пуст".

======================================================================
======== Функция 18, подфункция 1 - завершить работу системы. ========
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 1 - номер подфункции
Возвращаемое значение:
  * всегда возвращается eax = 0 как признак успеха
Замечания:
  * На последнем шаге появляется меню выхода из системы, ожидающее
    реакции пользователя.
  * Смотри также подфункцию 9, завершение работы системы с параметром,
    чтобы форсировать выбор в меню выхода.

======================================================================
==== Функция 18, подфункция 2 - завершить процесс/поток по слоту. ====
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = номер слота процесса/потока
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Нельзя завершить поток операционной системы OS/IDLE (номер слота
    1), можно завершить любой обычный поток/процесс.
  * Смотри также подфункцию 18 - завершение
    процесса/потока с заданным идентификатором.

======================================================================
= Функция 18, подфункция 3 - сделать активным окно заданного потока. =
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 3 - номер подфункции
  * ecx = номер слота потока
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * При указании корректного, но несуществующего слота активизируется
    какое-то окно.
  * Узнать, какое окно является активным, можно вызовом подфункции 7.

======================================================================
 Функция 18, подфункция 4 - получить счётчик пустых тактов в секунду.
======================================================================
Под пустыми тактами понимается время, в которое процессор простаивает
в ожидании прерывания (в инструкции hlt).

Параметры:
  * eax = 18 - номер функции
  * ebx = 4 - номер подфункции
Возвращаемое значение:
  * eax = значение счётчика пустых тактов в секунду

======================================================================
======== Функция 18, подфункция 5 - получить тактовую частоту. =======
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 5 - номер подфункции
Возвращаемое значение:
  * eax = тактовая частота (по модулю 2^32 тактов = 4ГГц)

======================================================================
 Функция 18, подфункция 6 - сохранить рамдиск в файл на жёстком диске.
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 6 - номер подфункции
  * ecx = указатель на строку с полным именем файла
    (например, "/hd0/1/kolibri/kolibri.img")
Возвращаемое значение:
  * eax = 0 - успешно
  * иначе eax = код ошибки файловой системы
Замечания:
  * Все папки в указанном пути должны существовать, иначе вернётся
    значение 5, "файл не найден".

======================================================================
====== Функция 18, подфункция 7 - получить номер активного окна. =====
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 7 - номер подфункции
Возвращаемое значение:
  * eax = номер активного окна (номер слота потока, окно которого
    активно)
Замечания:
  * Активное окно находится вверху оконного стэка и получает
    сообщения обо всём вводе с клавиатуры.
  * Сделать окно активным можно вызовом подфункции 3.

======================================================================
==== Функция 18, подфункция 8 - отключить/разрешить звук спикера. ====
======================================================================
При отключённом звуке вызовы подфункции 55 функции 55 игнорируются.
При включённом - направляются на встроенный спикер.

--------------- Подподфункция 1 - получить состояние. ----------------
Параметры:
  * eax = 18 - номер функции
  * ebx = 8 - номер подфункции
  * ecx = 1 - номер подподфункции
Возвращаемое значение:
  * eax = 0 - звук спикера разрешён; 1 - запрещён

-------------- Подподфункция 2 - переключить состояние. --------------
Переключает состояния разрешения/запрещения.
Параметры:
  * eax = 18 - номер функции
  * ebx = 8 - номер подфункции
  * ecx = 2 - номер подподфункции
Возвращаемое значение:
  * функция не возвращает значения

======================================================================
= Функция 18, подфункция 9 - завершение работы системы с параметром. =
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 9 - номер подфункции
  * ecx = параметр:
    * 1 = на последнем шаге завершения работы сохранить рамдиск на
      дискету, после чего вывести меню выхода и запросить у
      пользователя дальнейшие действия
    * 2 = выключить компьютер
    * 3 = перезагрузить компьютер
    * 4 = перезапустить ядро из файла kernel.mnt на рамдиске
Возвращаемое значение:
  * при неверном ecx регистры не меняются (т.е. eax=18)
  * при правильном вызове всегда возвращается признак успеха eax=0
Замечания:
  * Не следует полагаться на возвращаемое значение при неверном
    вызове, оно может измениться в последующих версиях ядра.
  * Можно использовать подфункцию 1, чтобы на последнем шаге
    завершения работы пользователь сам решал, что ему нужно.
  * Не рекомендуется использовать значение ecx=1 (чтобы не раздражать
    пользователя излишними вопросами); сохранить рамдиск на дискету
    можно функцией 16 (которая допускает уточнение, на какую именно
    дискету писать), а завершить работу с меню выхода можно уже
    упомянутой подфункцией 1.

======================================================================
======== Функция 18, подфункция 10 - свернуть окно приложения. =======
======================================================================
Сворачивает собственное окно.
Параметры:
  * eax = 18 - номер функции
  * ebx = 10 - номер подфункции
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Минимизированное окно с точки зрения функции 9 сохраняет положение
    и размеры.
  * Восстановление окна приложения происходит при активизировании
    подфункцией 3.
  * Обычно нет необходимости явно сворачивать/разворачивать своё окно:
    сворачивание окна осуществляется системой при нажатии на кнопку
    минимизации (которая для окон со скином определяется автоматически
    функцией 0, для окон без скина её можно определить функцией 8),
    восстановление - приложением @panel.

======================================================================
====================== Функция 18, подфункция 11 =====================
============= Получить информацию о дисковой подсистеме. =============
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 11 - номер подфункции
  * ecx = тип таблицы:
    * 1 = короткая версия, 10 байт
    * 2 = полная версия, 65536 байт
  * edx = указатель на буфер (в приложении) для таблицы
Возвращаемое значение:
  * функция не возвращает значения
Формат таблицы: короткая версия:
  * +0: byte: информация о НГМД (дисководах для дискет), AAAABBBB,
    где AAAA задаёт тип первого дисковода, BBBB - второго согласно
    следующему списку:
    * 0 = нет дисковода
    * 1 = 360Kb, 5.25''
    * 2 = 1.2Mb, 5.25''
    * 3 = 720Kb, 3.5''
    * 4 = 1.44Mb, 3.5''
    * 5 = 2.88Mb, 3.5'' (такие дискеты сейчас уже не используются)
    Например, для стандартной конфигурации из одного 1.44-дисковода
    здесь будет 40h, а для случая 1.2Mb на A: и 1.44Mb на B:
    значение оказывается 24h.
  * +1: byte: информация о жёстких дисках и CD-приводах, AABBCCDD,
    где AA соответствует контроллеру IDE0, ..., DD - IDE3:
    * 0 = устройство отсутствует
    * 1 = жёсткий диск
    * 2 = CD-привод
    Например, в случае HD на IDE0 и CD на IDE2 здесь будет 48h.
  * +2: 4 db: число найденных разделов на жёстких дисках с
    соответственно IDE0,...,IDE3.
    При отсутствии жёсткого диска на IDEx соответствующий байт
    нулевой, при наличии показывает число распознанных разделов,
    которых может и не быть (если носитель не отформатирован или
    если файловая система не поддерживается). В текущей версии ядра
    для жёстких дисков поддерживаются только FAT16, FAT32 и NTFS.
  * +6: 4 db: зарезервировано
Формат таблицы: полная версия:
  * +0: 10 db: такие же, как и в короткой версии
  * +10: 100 db: данные для первого раздела
  * +110: 100 db: данные для второго раздела
  * ...
  * +10+100*(n-1): 100 db: данные для последнего раздела
Разделы расположены в следующем порядке: сначала последовательно все
распознанные разделы на HD на IDE0 (если есть),
затем на HD на IDE1 (если есть) и т.д. до IDE3.
Формат информации о разделе:
  * +0: dword: начальный физический сектор раздела
  * +4: dword: последний физический сектор раздела
    (принадлежит разделу)
  * +8: byte: тип файловой системы:
    16=FAT16, 32=FAT32, 1=NTFS
  * формат дальнейших данных зависит от файловой системы,
    может меняться с изменениями в ядре и поэтому не описывается
Замечания:
  * Короткая таблица может быть использована для получения информации
    об имеющихся устройствах.

======================================================================
========== Функция 18, подфункция 13 - получить версию ядра. =========
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 13 - номер подфункции
  * ecx = указатель на буфер (не менее 16 байт), куда будет помещена
    информация
Возвращаемое значение:
  * функция не возвращает значения
Структура буфера:
db a,b,c,d для версии a.b.c.d
db UID_xxx: одно из UID_NONE=0, UID_MENUET=1, UID_KOLIBRI=2
dd REV - номер svn-ревизии ядра
Для ядра Kolibri 0.7.0.0:
db 0,7,0,0
db 2
dd 533

======================================================================
====================== Функция 18, подфункция 14 =====================
======= Ожидать начала обратного хода луча развёртки монитора. =======
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 14 - номер подфункции
Возвращаемое значение:
  * eax = 0 как признак успеха
Замечания:
  * Функция предназначена исключительно для активных
    высокопроизводительных графических приложений; используется для
    плавного вывода графики.

======================================================================
== Функция 18, подфункция 15 - поместить курсор мыши в центр экрана. =
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 15 - номер подфункции
Возвращаемое значение:
  * eax = 0 как признак успеха

======================================================================
====================== Функция 18, подфункция 16 =====================
============ Получить размер свободной оперативной памяти. ===========
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 16 - номер подфункции
Возвращаемое значение:
  * eax = размер свободной памяти в килобайтах

======================================================================
====================== Функция 18, подфункция 17 =====================
============ Получить размер имеющейся оперативной памяти. ===========
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 17 - номер подфункции
Возвращаемое значение:
  * eax = общий размер имеющейся памяти в килобайтах

======================================================================
====================== Функция 18, подфункция 18 =====================
============= Завершить процесс/поток по идентификатору. =============
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 18 - номер подфункции
  * ecx = идентификатор процесса/потока (PID/TID)
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = -1 - ошибка (процесс не найден или является системным)
Замечания:
  * Нельзя завершить поток операционной системы OS/IDLE (номер слота
    1), можно завершить любой обычный поток/процесс.
  * Смотри также подфункцию 2 - завершение
    процесса/потока по заданному слоту.

======================================================================
=== Функция 18, подфункция 19 - получить/установить настройки мыши. ==
======================================================================

------------- Подподфункция 0 - получить скорость мыши. --------------
Параметры:
  * eax = 18 - номер функции
  * ebx = 19 - номер подфункции
  * ecx = 0 - номер подподфункции
Возвращаемое значение:
  * eax = текущая скорость мыши

------------ Подподфункция 1 - установить скорость мыши. -------------
Параметры:
  * eax = 18 - номер функции
  * ebx = 19 - номер подфункции
  * ecx = 1 - номер подподфункции
  * edx = новое значение скорости
Возвращаемое значение:
  * функция не возвращает значения

------------- Подподфункция 2 - получить задержку мыши. --------------
Параметры:
  * eax = 18 - номер функции
  * ebx = 19 - номер подфункции
  * ecx = 2 - номер подподфункции
Возвращаемое значение:
  * eax = текущая задержка мыши

------------ Подподфункция 3 - установить задержку мыши. -------------
Параметры:
  * eax = 18 - номер функции
  * ebx = 19 - номер подфункции
  * ecx = 3 - номер подподфункции
  * edx = новое значение задержки мыши
Возвращаемое значение:
  * функция не возвращает значения

-------- Подподфункция 4 - установить положение курсора мыши. --------
Параметры:
  * eax = 18 - номер функции
  * ebx = 19 - номер подфункции
  * ecx = 4 - номер подподфункции
  * edx = [координата по оси x]*65536 + [координата по оси y]
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Рекомендуемая скорость мыши (в подподфункции 1) от 1 до 9.
    Устанавливаемая величина не проверяется кодом ядра, поэтому
    используйте осторожно, при некорректном значении курсор может
    "замёрзнуть". Скорость мыши можно регулировать в приложении SETUP.
  * Рекомендуемая величина задержки (в подподфункции 3) = 10.
    Меньшие значения не обрабатываются COM-мышами. При очень больших
    значениях невозможно передвижение мыши на 1 пиксель и курсор будет
    прыгать на величину установленной скорости (подподфункция 1).
    Устанавливаемая величина не проверяется кодом ядра.
    Величину задержки можно менять в приложении SETUP.
  * Подподфункция 4 не проверяет переданное значение. Перед вызовом
    необходимо узнать текущее разрешение экрана (подфункцией 14)
    и проверить, что устанавливаемое положение не выходит за пределы
    экрана.

======================================================================
====================== Функция 18, подфункция 20 =====================
============= Получить информацию об оперативной памяти. =============
======================================================================
Параметры:
  * eax = 18 - номер функции
  * ebx = 20 - номер подфункции
  * ecx = указатель на буфер для информации (36 байт)
Возвращаемое значение:
  * eax = общий размер имеющейся оперативной памяти в байтах
    или -1 в случае ошибки
  * буфер, на который указывает ecx, содержит следующую информацию:
    * +0: dword: общий размер имеющейся оперативной памяти в страницах
    * +4:  dword: размер свободной оперативной памяти в страницах
    * +8:  dword: число страничных ошибок (исключений #PF)
                 в приложениях
    * +12: dword: размер кучи ядра в байтах
    * +16: dword: размер свободной памяти в куче ядра в байтах
    * +20: dword: общее количество блоков памяти в куче ядра
    * +24: dword: количество свободных блоков памяти в куче ядра
    * +28: dword: размер наибольшего свободного блока в куче ядра
                 (зарезервировано)
    * +32: dword: размер наибольшего выделенного блока в куче ядра
                 (зарезервировано)

======================================================================
==================== Функция 20 - интерфейс MIDI. ====================
======================================================================

------------------------ Подфункция 1 - сброс ------------------------
Параметры:
  * eax = 20 - номер функции
  * ebx = 1 - номер подфункции

-------------------- Подфункция 2 - вывести байт ---------------------
Параметры:
  * eax = 20 - номер функции
  * ebx = 2 - номер подфункции
  * cl = байт для вывода
Возвращаемое значение (одинаково для обеих подфункций):
  * eax = 0 - успешно
  * eax = 1 - не определён базовый порт
Замечания:
  * Предварительно должен быть определён базовый порт вызовом
    подфункции 1 функции 21.

======================================================================
==== Функция 21, подфункция 1 - установить базовый порт MPU MIDI. ====
======================================================================
Параметры:
  * eax = 21 - номер функции
  * ebx = 1 - номер подфункции
  * ecx = номер базового порта
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = -1 - ошибочный номер порта
Замечания:
  * Номер порта должен удовлетворять условиям 0x100<=ecx<=0xFFFF.
  * Установка базы нужна для работы функции 20.
  * Получить установленный базовый порт можно вызовом
    подфункции 1 функции 26.

======================================================================
===== Функция 21, подфункция 2 - установить раскладку клавиатуры. ====
======================================================================
Раскладка клавиатуры используется для преобразования сканкодов,
поступающих от клавиатуры, в ASCII-коды, считываемые функцией 2.
Параметры:
  * eax = 21 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = какую раскладку устанавливать:
    * 1 = нормальную
    * 2 = раскладку при нажатом Shift
    * 3 = раскладку при нажатом Alt
  * edx = указатель на раскладку - таблицу длиной 128 байт
Или:
  * ecx = 9
  * dx = идентификатор страны (1=eng, 2=fi, 3=ger, 4=rus)
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - параметр задан неверно
Замечания:
  * Если нажат Alt, то используется раскладка с Alt;
    если не нажат Alt, но нажат Shift, то
    используется раскладка с Shift;
    если не нажаты Alt и Shift, но нажат Ctrl, то используется
    нормальная раскладка, после чего из кода вычитается 0x60;
    если не нажата ни одна из управляющих клавиш, то используется
    нормальная раскладка.
  * Получить раскладки и идентификатор страны можно с помощью
    подфункции 2 функции 26.
  * Идентификатор страны - глобальная системная переменная, которая
    самим ядром не используется; однако приложение @panel отображает
    соответствующую текущей стране иконку.
  * Приложение @panel переключает раскладки по запросу пользователя.

======================================================================
=========== Функция 21, подфункция 3 - установить базу CD. ===========
======================================================================
Параметры:
  * eax = 21 - номер функции
  * ebx = 3 - номер подфункции
  * ecx = база CD: 1=IDE0, 2=IDE1, 3=IDE2, 4=IDE3
Возвращаемое значение:
  * eax = 0
Замечания:
  * База CD используется функцией 24.
  * Получить установленную базу CD можно вызовом
    подфункции 3 функции 26.

======================================================================
== Функция 21, подфункция 4 - установить базовый порт Sound Blaster. =
======================================================================
Параметры:
  * eax = 21 - номер функции
  * ebx = 4 - номер подфункции
  * ecx = номер базового порта
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = -1 - ошибочный номер порта
Замечания:
  * Номер порта должен удовлетворять условиям 0x100<=ecx<=0xFFFF.
  * Установка базы нужна для работы функций 25, 28, 55.
  * Получить установленный базовый порт можно вызовом
    подфункции 4 функции 26.

======================================================================
========= Функция 21, подфункция 5 - установить язык системы. ========
======================================================================
Параметры:
  * eax = 21 - номер функции
  * ebx = 5 - номер подфункции
  * ecx = язык системы (1=eng, 2=fi, 3=ger, 4=rus)
Возвращаемое значение:
  * eax = 0
Замечания:
  * Язык системы - глобальная системная переменная, никак
    не используемая самим ядром, однако приложение @panel рисует
    соответствующую иконку.
  * Проверок на корректность не делается, поскольку ядро эту
    переменную не использует.
  * Получить язык системы можно вызовом подфункции 5 функции 26.

======================================================================
=========== Функция 21, подфункция 7 - установить базу HD. ===========
======================================================================
База HD нужна для определения, на какой жёсткий диск писать, при
использовании устаревшего синтаксиса /HD в устаревшей функции 58;
при использовании современного синтаксиса /HD0,/HD1,/HD2,/HD3
база устанавливается автоматически.
Параметры:
  * eax = 21 - номер функции
  * ebx = 7 - номер подфункции
  * ecx = база HD: 1=IDE0, 2=IDE1, 3=IDE2, 4=IDE3
Возвращаемое значение:
  * eax = 0
Замечания:
  * Любое приложение в любой момент времени может изменить базу.
  * Не следует изменять базу, когда какое-нибудь приложение работает
    с жёстким диском. Если не хотите глюков системы.
  * Получить установленную базу можно вызовом подфункции 7 функции 26.
  * Следует также определить используемый раздел жёсткого диска
    подфункцией 8.

======================================================================
========== Функция 21, подфункция 8 - установить раздел HD. ==========
======================================================================
Раздел HD нужен для определения, на какой раздел жёсткого диска
писать, при использовании устаревшего синтаксиса /HD в устаревшей
функции 58; при использовании современного синтаксиса
/HD0,/HD1,/HD2,/HD3 база и раздел устанавливаются автоматически.
Параметры:
  * eax = 21 - номер функции
  * ebx = 8 - номер подфункции
  * ecx = раздел HD (считая с 1)
Возвращаемое значение:
  * eax = 0
Замечания:
  * Любое приложение в любой момент времени может изменить раздел.
  * Не следует изменять раздел, когда какое-нибудь приложение работает
    с жёстким диском. Если не хотите глюков системы.
  * Получить установленный раздел можно вызовом подфункции 8
    функции 26.
  * Проверок на корректность не делается.
  * Узнать число разделов на жёстком диске можно вызовом
    подфункции 11 функции 18.
  * Следует также определить используемую базу жёсткого диска
    подфункцией 7.

======================================================================
===== Функция 21, подфункция 10 - установить канал DMA для звука. ====
======================================================================
Параметры:
  * eax = 21 - номер функции
  * ebx = 10 - номер подфункции
  * ecx = номер канала (от 0 до 3 включительно)
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = -1 - неверный номер канала
Замечания:
  * Номер канала DMA используется в
    подфункции 1 функции 55.
  * Получить канал DMA для звука можно вызовом
    подфункции 10 функции 26.

======================================================================
====================== Функция 21, подфункция 11 =====================
=========== Разрешить/запретить низкоуровневый доступ к HD. ==========
======================================================================
Параметры:
  * eax = 21 - номер функции
  * ebx = 11 - номер подфункции
  * ecx = 0/1 - запретить/разрешить
Возвращаемое значение:
  * eax = 0
Замечания:
  * Используется при LBA-чтении (подфункция 8 функции 58).
  * Текущая реализация использует только младший бит ecx.
  * Получить текущее состояние можно вызовом подфункции 11 функции 26.

======================================================================
====================== Функция 21, подфункция 12 =====================
========== Разрешить/запретить низкоуровневый доступ к PCI. ==========
======================================================================
Параметры:
  * eax = 21 - номер функции
  * ebx = 12 - номер подфункции
  * ecx = 0/1 - запретить/разрешить
Возвращаемое значение:
  * eax = 0
Замечания:
  * Используется при работе с шиной PCI (функция 62).
  * Текущая реализация использует только младший бит ecx.
  * Получить текущее состояние можно вызовом подфункции 12 функции 26.

======================================================================
============= Функция 21, подфункция 13, подподфункция 1 =============
==== Инициализировать + получить информацию о драйвере vmode.mdr. ====
======================================================================
Параметры:
  * eax = 21 - номер функции
  * ebx = 13 - номер подфункции
  * ecx = 1 - номер функции драйвера
  * edx = указатель на буфер размера 512 байт
Возвращаемое значение:
  * если драйвер не загружен (никогда не бывает в текущей реализации):
    * eax = -1
    * ebx, ecx разрушаются
  * если драйвер загружен:
    * eax = 'MDAZ' (в стиле fasm'а, т.е. 'M' - младший байт,
      'Z' - старший) - сигнатура
    * ebx = текущая частота развёртки (в Гц)
    * ecx разрушается
    * буфер, на который указывает edx, заполнен
Формат буфера:
  * +0: 32*byte: имя драйвера, "Trans VideoDriver" (без кавычек,
    дополнено пробелами)
  * +32 = +0x20: dword: версия драйвера (версия x.y кодируется как
    y*65536+x), для текущей реализации 1 (1.0)
  * +36 = +0x24: 7*dword: зарезервировано (0 в текущей реализации)
  * +64 = +0x40: 32*word: список поддерживаемых видеорежимов (каждое
    слово - номер видеорежима, после собственно списка идут нули)
  * +128 = +0x80: 32*(5*word): список поддерживаемых частот развёрток
    для видеорежимов: для каждого видеорежима, указанного в предыдущем
    поле, указано до 5 поддерживаемых частот
    (в неиспользуемых позициях записаны нули)
Замечания:
  * Функция инициализирует драйвер (если он ещё не инициализирован)
    и должна вызываться первой, перед остальными (иначе они будут
    возвращать -1, ничего не делая).
  * В текущей реализации поддерживается только одна частота развёртки
    на видеорежим.

======================================================================
============= Функция 21, подфункция 13, подподфункция 2 =============
============= Получить информацию о текущем видеорежиме. =============
======================================================================
Параметры:
  * eax = 21 - номер функции
  * ebx = 13 - номер подфункции
  * ecx = 2 - номер функции драйвера
Возвращаемое значение:
  * eax = -1 - драйвер не загружен или не инициализирован;
    ebx,ecx разрушаются
  * eax = [ширина]*65536 + [высота]
  * ebx = частота вертикальной развёртки (в Гц)
  * ecx = номер текущего видеорежима
Замечания:
  * Драйвер предварительно должен быть инициализирован вызовом
    функции драйвера 1.
  * Если нужны только размеры экрана, целесообразней использовать
    функцию 14 с учётом того, что она возвращает размеры на 1 меньше.

======================================================================
= Функция 21, подфункция 13, подподфункция 3 - установить видеорежим.
======================================================================
Параметры:
  * eax = 21 - номер функции
  * ebx = 13 - номер подфункции
  * ecx = 3 - номер функции драйвера
  * edx = [частота развёртки]*65536 + [номер видеорежима]
Возвращаемое значение:
  * eax = -1 - драйвер не загружен, не инициализирован или
    произошла ошибка
  * eax = 0 - успешно
  * ebx, ecx разрушаются
Замечания:
  * Драйвер предварительно должен быть инициализирован вызовом
    функции драйвера 1.
  * Номер видеорежима и частота должны быть в таблице, возвращаемой
    функцией драйвера 1.

======================================================================
============= Функция 21, подфункция 13, подподфункция 4 =============
================= Вернуться к начальному видеорежиму. ================
======================================================================
Возвращает экран в видеорежим, установленный при загрузке системы.
Параметры:
  * eax = 21 - номер функции
  * ebx = 13 - номер подфункции
  * ecx = 4 - номер функции драйвера
Возвращаемое значение:
  * eax = -1 - драйвер не загружен или не инициализирован
  * eax = 0 - успешно
  * ebx, ecx разрушаются
Замечания:
  * Драйвер предварительно должен быть инициализирован вызовом
    функции драйвера 1.

======================================================================
============= Функция 21, подфункция 13, подподфункция 5 =============
======== Увеличить/уменьшить размер видимой области монитора. ========
======================================================================
Параметры:
  * eax = 21 - номер функции
  * ebx = 13 - номер подфункции
  * ecx = 5 - номер функции драйвера
  * edx = 0/1 - уменьшить/увеличить размер по горизонтали
    на одну позицию
  * edx = 2/3 - в текущей реализации не поддерживается; планируется
    как уменьшение/увеличение размера по вертикали на одну позицию
Возвращаемое значение:
  * eax = -1 - драйвер не загружен или не инициализирован
  * eax = 0 - успешно
  * ebx, ecx разрушаются
Замечания:
  * Драйвер предварительно должен быть инициализирован вызовом
    функции драйвера 1.
  * Функция влияет только на физический размер изображения
    на мониторе; логический размер (число пикселей) не меняется.

======================================================================
============ Функция 22 - установить системную дату/время. ===========
======================================================================
Параметры:
  * eax = 22 - номер функции
  * ebx = 0 - установить время
    * ecx = 0x00SSMMHH - время в двоично-десятичном коде (BCD):
    * HH=час 00..23
    * MM=минута 00..59
    * SS=секунда 00..59
  * ebx = 1 - установить дату
    * ecx = 0x00DDMMYY - дата в двоично-десятичном коде (BCD):
    * DD=день 01..31
    * MM=месяц 01..12
    * YY=год 00..99
  * ebx = 2 - установить день недели
    * ecx = 1 для воскресенья, ..., 7 для субботы
  * ebx = 3 - установить будильник
    * ecx = 0x00SSMMHH
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - параметр задан неверно
  * eax = 2 - CMOS-батарейки разрядились
Замечания:
  * Ценность установки дня недели представляется сомнительной,
    поскольку он мало где используется
    (день недели можно рассчитать по дате).
  * Будильник можно установить на срабатывание в заданное время
    каждые сутки. При этом отключить его существующими системными
    функциями нельзя.
  * Срабатывание будильника заключается в генерации IRQ8.
  * Вообще-то CMOS поддерживает для будильника установку значения
    0xFF в качестве одного из параметров и означает это, что
    соответствующий параметр игнорируется. Но в текущей реализации
    это не пройдёт (вернётся значение 1).
  * Будильник - глобальный системный ресурс; установка будильника
    автоматически отменяет предыдущую установку. Впрочем, на данный
    момент ни одна программа его не использует.

======================================================================
============== Функция 23 - ожидать события с таймаутом. =============
======================================================================
Если очередь сообщений пуста, ждёт появления сообщения в очереди,
но не более указанного времени. Затем считывает сообщение из очереди.

Параметры:
  * eax = 23 - номер функции
  * ebx = таймаут (в сотых долях секунды)
Возвращаемое значение:
  * eax = 0 - очередь сообщений пуста
  * иначе eax = событие (смотри список событий)
Замечания:
  * Учитываются только те события, которые входят в маску,
    устанавливаемую функцией 40. По умолчанию это события
    перерисовки, нажатия на клавиши и на кнопки.
  * Для проверки, есть ли сообщение в очереди, используйте функцию 11.
    Чтобы ждать сколь угодно долго, используйте функцию 10.
  * Передача ebx=0 приводит к моментальному возвращению eax=0.
  * При текущей реализации произойдёт немедленный возврат из функции
    с eax=0, если сложение ebx с текущим значением счётчика времени
    вызовет 32-битное переполнение.

======================================================================
======= Функция 24, подфункция 1 - начать проигрывать CD-audio. ======
======================================================================
Параметры:
  * eax = 24 - номер функции
  * ebx = 1 - номер подфункции
  * ecx = 0x00FRSSMM, где
    * MM = начальная минута
    * SS = начальная секунда
    * FR = начальный фрейм
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - не определена база CD
Замечания:
  * Предварительно нужно определить базовый порт CD вызовом
    подфункции 3 функции 21.
  * В секунде 75 фреймов, в минуте 60 секунд.
  * Функция асинхронна (возвращает управление, когда началось
    проигрывание).

======================================================================
===== Функция 24, подфункция 2 - получить информацию о дорожках. =====
======================================================================
Параметры:
  * eax = 24 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = указатель на буфер для таблицы
    (максимум 8*64h+4 байт=100 дорожек)
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - не определена база CD
Замечания:
  * Формат таблицы с информацией о дорожках такой же, как и для
    ATAPI-CD команды 43h (READ TOC), обычной таблицы (подкоманда 00h).
    Адреса возвращаются в формате MSF.
  * Предварительно нужно определить базовый порт CD вызовом
    подфункции 3 функции 21.
  * Функция возвращает информацию только о не более чем 100
    первых дорожках. В большинстве случаев этого достаточно.

======================================================================
==== Функция 24, подфункция 3 - остановить проигрываемое CD-audio. ===
======================================================================
Параметры:
  * eax = 24 - номер функции
  * ebx = 1 - номер подфункции
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - не определена база CD
Замечания:
  * Предварительно нужно определить базовый порт CD вызовом
    подфункции 3 функции 21.

======================================================================
============== Функция 25 - установить громкость SBPro. ==============
======================================================================
Параметры:
  * eax = 25 - номер функции
  * ebx = что устанавливать:
    * 1 - установить общую громкость
    * 2 - установить громкость CD-audio
  * cl = уровень громкости: старшие 4 бита для левой колонки,
    младшие 4 - для правой
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - не определена база SB
  * eax = 2 - неверная подфункция
Замечания:
  * Предварительно нужно определить базовый порт SB вызовом
    подфункции 4 функции 21.
  * Смотри также функцию 28
    установки звука для более позднего стандарта SB16.

======================================================================
===== Функция 26, подфункция 1 - получить базовый порт MPU MIDI. =====
======================================================================
Параметры:
  * eax = 26 - номер функции
  * ebx = 1 - номер подфункции
Возвращаемое значение:
  * eax = номер порта
Замечания:
  * Установить базовый порт можно вызовом
    подфункции 1 функции 21.

======================================================================
====== Функция 26, подфункция 2 - получить раскладку клавиатуры. =====
======================================================================
Раскладка клавиатуры используется для преобразования сканкодов,
поступающих от клавиатуры, в ASCII-коды, считываемые функцией 2.
Параметры:
  * eax = 26 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = какую раскладку получать:
    * 1 = нормальную
    * 2 = раскладку при нажатом Shift
    * 3 = раскладку при нажатом Alt
  * edx = указатель на буфер длиной 128 байт, куда будет скопирована
    раскладка
Возвращаемое значение:
  * функция не возвращает значения
Или:
  * eax = 26 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = 9
Возвращаемое значение:
  * eax = идентификатор страны (1=eng, 2=fi, 3=ger, 4=rus)
Замечания:
  * Если нажат Alt, то используется раскладка с Alt;
    если не нажат Alt, но нажат Shift, то используется
    раскладка с Shift;
    если не нажаты Alt и Shift, но нажат Ctrl, то используется
    нормальная раскладка, после чего из кода вычитается 0x60;
    если не нажата ни одна из управляющих клавиш, то используется
    нормальная раскладка.
  * Установить раскладки и идентификатор страны можно с помощью
    подфункции 2 функции 21.
  * Идентификатор страны - глобальная системная переменная, которая
    самим ядром не используется; однако приложение @panel отображает
    соответствующую текущей стране иконку
    (используя описываемую функцию).
  * Приложение @panel переключает раскладки по запросу пользователя.

======================================================================
============ Функция 26, подфункция 3 - получить базу CD. ============
======================================================================
Параметры:
  * eax = 26 - номер функции
  * ebx = 3 - номер подфункции
Возвращаемое значение:
  * eax = база CD: 1=IDE0, 2=IDE1, 3=IDE2, 4=IDE3
Замечания:
  * База CD используется функцией 24.
  * Установить базу CD можно вызовом подфункции 3 функции 21.

======================================================================
=== Функция 26, подфункция 4 - получить базовый порт Sound Blaster. ==
======================================================================
Параметры:
  * eax = 26 - номер функции
  * ebx = 4 - номер подфункции
Возвращаемое значение:
  * eax = номер базового порта
Замечания:
  * Установка базы нужна для работы функций 25, 55.
  * Установить базовый порт можно вызовом подфункции 4 функции 21.

======================================================================
========== Функция 26, подфункция 5 - получить язык системы. =========
======================================================================
Параметры:
  * eax = 26 - номер функции
  * ebx = 5 - номер подфункции
Возвращаемое значение:
  * eax = язык системы (1=eng, 2=fi, 3=ger, 4=rus)
Замечания:
  * Язык системы - глобальная системная переменная, никак
    не используемая самим ядром, однако приложение @panel рисует
    соответствующую иконку (используя описываемую функцию).
  * Установить язык системы можно вызовом подфункции 5 функции 21.

======================================================================
============ Функция 26, подфункция 7 - получить базу HD. ============
======================================================================
База HD нужна для определения, на какой жёсткий диск писать, при
использовании устаревшего синтаксиса /HD в устаревшей функции 58;
при использовании современного синтаксиса /HD0,/HD1,/HD2,/HD3
база устанавливается автоматически.
Параметры:
  * eax = 26 - номер функции
  * ebx = 7 - номер подфункции
Возвращаемое значение:
  * eax = база HD: 1=IDE0, 2=IDE1, 3=IDE2, 4=IDE3
Замечания:
  * Любое приложение в любой момент времени может изменить базу.
  * Установить базу можно вызовом подфункции 7 функции 21.
  * Получить используемый раздел жёсткого диска можно подфункцией 8.

======================================================================
=========== Функция 26, подфункция 8 - получить раздел HD. ===========
======================================================================
Раздел HD нужен для определения, на какой раздел жёсткого диска
писать, при использовании устаревшего синтаксиса /HD в устаревшей
функции 58; при использовании современного синтаксиса
/HD0,/HD1,/HD2,/HD3 база и раздел устанавливаются автоматически.
Параметры:
  * eax = 26 - номер функции
  * ebx = 8 - номер подфункции
Возвращаемое значение:
  * eax = раздел HD (считая с 1)
Замечания:
  * Любое приложение в любой момент времени может изменить раздел.
  * Установить раздел можно вызовом подфункции 8 функции 21.
  * Узнать число разделов на жёстком диске можно вызовом
    подфункции 11 функции 18.
  * Получить используемую базу жёсткого диска можно подфункцией 7.

======================================================================
=== Функция 26, подфункция 9 - получить значение счётчика времени. ===
======================================================================
Параметры:
  * eax = 26 - номер функции
  * ebx = 9 - номер подфункции
Возвращаемое значение:
  * eax = число сотых долей секунды, прошедших с момента
    запуска системы
Замечания:
  * Счётчик берётся по модулю 2^32, что соответствует немногим более
    497 суток.
  * Системное время можно получить функцией 3.

======================================================================
====== Функция 26, подфункция 10 - получить канал DMA для звука. =====
======================================================================
Параметры:
  * eax = 26 - номер функции
  * ebx = 10 - номер подфункции
Возвращаемое значение:
  * eax = номер канала (от 0 до 3 включительно)
Замечания:
  * Номер канала DMA используется в подфункции 1 функции 55.
  * Установить канал DMA для звука можно вызовом
    подфункции 10 функции 21.

======================================================================
====================== Функция 26, подфункция 11 =====================
=========== Узнать, разрешён ли низкоуровневый доступ к HD. ==========
======================================================================
Параметры:
  * eax = 26 - номер функции
  * ebx = 11 - номер подфункции
Возвращаемое значение:
  * eax = 0/1 - запрещён/разрешён
Замечания:
  * Используется при LBA-чтении (подфункция 8 функции 58).
  * Установить текущее состояние можно вызовом
    подфункции 11 функции 21.

======================================================================
====================== Функция 26, подфункция 12 =====================
========== Узнать, разрешён ли низкоуровневый доступ к PCI. ==========
======================================================================
Параметры:
  * eax = 26 - номер функции
  * ebx = 12 - номер подфункции
Возвращаемое значение:
  * eax = 0/1 - запрещён/разрешён
Замечания:
  * Используется при работе с шиной PCI (функция 62).
  * Текущая реализация использует только младший бит ecx.
  * Установить текущее состояние можно вызовом
    подфункции 12 функции 21.

======================================================================
=============== Функция 28 - установить громкость SB16. ==============
======================================================================
Параметры:
  * eax = 28 - номер функции
  * ebx = что устанавливать:
    * 1 - установить общую громкость
    * 2 - установить громкость CD-audio
  * cl = уровень громкости (0=off, 0xFF=max)
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - не определена база SB
  * eax = 2 - неверная подфункция
Замечания:
  * Предварительно нужно определить базовый порт SB вызовом
    подфункции 4 функции 21.
  * Эта функция предоставляет больше вариантов для громкости,
    чем функция 25.

======================================================================
================ Функция 29 - получить системную дату. ===============
======================================================================
Параметры:
  * eax = 29 - номер функции
Возвращаемое значение:
  * eax = 0x00DDMMYY, где
    (используется двоично-десятичное кодирование, BCD)
  * YY = две младшие цифры года (00..99)
  * MM = месяц (01..12)
  * DD = день (01..31)
Замечания:
  * Системную дату можно установить функцией 22.

======================================================================
================ Функция 30 - работа с текущей папкой. ===============
======================================================================

-------- Подфункция 1 - установить текущую папку для потока. ---------
Параметры:
  * eax = 30 - номер функции
  * ebx = 1 - номер подфункции
  * ecx = указатель на ASCIIZ-строку с путём к новой текущей папке
Возвращаемое значение:
  * функция не возвращает значения

--------- Подфункция 2 - получить текущую папку для потока. ----------
Параметры:
  * eax = 30 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = указатель на буфер
  * edx = размер буфера
Возвращаемое значение:
  * eax = длина имени текущей папки (включая завершающий 0)
Замечания:
  * Если размера буфера недостаточно для копирования всего имени,
    копируются только первые (edx-1) байт
    и в конце ставится завершающий 0.

======================================================================
================ Функция 32 - удалить файл с рамдиска. ===============
======================================================================
Параметры:
  * eax = 32 - номер функции
  * ebx = указатель на имя файла
Возвращаемое значение:
  * eax = 0 - успешно; иначе код ошибки файловой системы
Замечания:
  * Эта функция устарела; функция 58 позволяет выполнять
    те же действия с расширенными возможностями.
  * Текущая реализация возвращает только значения 0(успех) и
    5(файл не найден).
  * Имя файла должно быть либо в формате 8+3 символов (первые
    8 символов - собственно имя, последние 3 - расширение,
    короткие имена и расширения дополняются пробелами),
    либо в формате 8.3 символов "FILE.EXT"/"FILE.EX "
    (имя не более 8 символов, точка, расширение 3 символа,
    дополненное при необходимости пробелами).
    Имя файла должно быть записано заглавными буквами.
    Завершающий символ с кодом 0 не нужен (не ASCIIZ-строка).
  * Эта функция не поддерживает папок на рамдиске.

======================================================================
=============== Функция 33 - записать файл на рамдиск. ===============
======================================================================
Параметры:
  * eax = 33 - номер функции
  * ebx = указатель на имя файла
  * ecx = указатель на данные для записи
  * edx = число байт для записи
  * следует устанавливать esi=0
Возвращаемое значение:
  * eax = 0 - успешно, иначе код ошибки файловой системы
Замечания:
  * Эта функция устарела; функция 70 позволяет выполнять
    те же действия с расширенными возможностями.
  * Если указать ненулевое значение в esi и на рамдиске уже есть
    указанный файл, то будет создан ещё один файл с тем же именем.
  * В противном случае файл перезаписывается.
  * Имя файла должно быть либо в формате 8+3 символов
    (первые 8 символов - собственно имя, последние 3 - расширение,
    короткие имена и расширения дополняются пробелами),
    либо в формате 8.3 символов "FILE.EXT"/"FILE.EX "
    (имя не более 8 символов, точка, расширение 3 символа,
    дополненное при необходимости пробелами).
    Имя файла должно быть записано заглавными буквами.
    Завершающий символ с кодом 0 не нужен (не ASCIIZ-строка).
  * Эта функция не поддерживает папок на рамдиске.

======================================================================
============ Функция 35 - прочитать цвет точки на экране. ============
======================================================================
Параметры:
  * eax = 35
  * ebx = y*xsize+x, где
  * (x,y) = координаты точки (считая от 0)
  * xsize = размер экрана по горизонтали
Возвращаемое значение:
  * eax = цвет 0x00RRGGBB
Замечания:
  * Узнать размеры экрана можно вызовом функции 14. Обратите внимание,
    что она вычитает 1 из обоих размеров.
  * К видеопамяти есть также прямой доступ (без вызовов системных
    функций) через селектор gs. Параметры текущего видеорежима
    можно получить функцией 61.

======================================================================
==================== Функция 37 - работа с мышью. ====================
======================================================================

-------------- Подфункция 0 - экранные координаты мыши ---------------
Параметры:
  * eax = 37 - номер функции
  * ebx = 0 - номер подфункции
Возвращаемое значение:
  * eax = x*65536 + y, (x,y)=координаты курсора мыши (считая от 0)

---------- Подфункция 1 - координаты мыши относительно окна ----------
Параметры:
  * eax = 37 - номер функции
  * ebx = 1 - номер подфункции
Возвращаемое значение:
  * eax = x*65536 + y, (x,y)=координаты курсора мыши относительно
    окна приложения (считая от 0)
Замечания:
  * Значение вычисляется по формуле (x-xwnd)*65536 + (y-ywnd).
    Если y>=ywnd, то младшее слово неотрицательно и содержит
    относительную y-координату, а старшее - относительную x-координату
    (правильного знака). В противном случае младшее слово отрицательно
    и всё равно содержит относительную y-координату,
    а к старшему слову следует прибавить 1.

----------------- Подфункция 2 - нажатые кнопки мыши -----------------
Параметры:
  * eax = 37 - номер функции
  * ebx = 2 - номер подфункции
Возвращаемое значение:
  * eax содержит информацию о нажатых кнопках мыши:
  * бит 0 установлен = левая кнопка нажата
  * бит 1 установлен = правая кнопка нажата
  * бит 2 установлен = средняя кнопка нажата
  * бит 3 установлен = 4-я кнопка нажата
  * бит 4 установлен = 5-я кнопка нажата
  * прочие биты сброшены

------------------ Подфункция 4 - загрузить курсор -------------------
Параметры:
  * eax = 37 - номер функции
  * ebx = 4 - номер подфункции
  * dx = источник данных:
  * dx = LOAD_FROM_FILE = 0 - данные в файле
    * ecx = указатель на полный путь к файлу курсора
    * файл курсора должен быть в формате .cur, стандартном для
      MS Windows, причём размером 32*32 пикселя
  * dx = LOAD_FROM_MEM = 1 - данные файла уже загружены в память
    * ecx = указатель на данные файла курсора
    * формат данных такой же, как и в предыдущем случае
  * dx = LOAD_INDIRECT = 2 - данные в памяти
    * ecx = указатель на образ курсора в формате ARGB 32*32 пикселя
    * edx = 0xXXYY0002, где
      * XX = x-координата "горячей точки" курсора
      * YY = y-координата
      * 0 <= XX, YY <= 31
Возвращаемое значение:
  * eax = 0 - неудача
  * иначе eax = хэндл курсора

------------------ Подфункция 5 - установить курсор ------------------
Устанавливает новый курсор для окна текущего потока.
Параметры:
  * eax = 37 - номер функции
  * ebx = 5 - номер подфункции
  * ecx = хэндл курсора
Возвращаемое значение:
  * eax = хэндл предыдущего установленного курсора
Замечания:
  * Если передан некорректный хэндл, то функция восстановит курсор
    по умолчанию (стандартную стрелку). В частности, к восстановлению
    курсора по умолчанию приводит передача ecx=0.

------------------- Подфункция 6 - удалить курсор --------------------
Параметры:
  * eax = 37 - номер функции
  * ebx = 6 - номер подфункции
  * ecx = хэндл курсора
Возвращаемое значение:
  * eax разрушается
Замечания:
  * Курсор должен был быть ранее загружен текущим потоком
    (вызовом подфункции 4). Функция не удаляет системные курсоры и
    курсоры, загруженные другими приложениями.
  * Если удаляется активный (установленный подфункцией 5) курсор, то
    восстанавливается курсор по умолчанию (стандартная стрелка).

------------------ Подфункция 7 - данные прокрутки -------------------
Параметры:
  * eax = 37 - номер функции
  * ebx = 6 - номер подфункции
Возвращаемое значение:
  * eax = [horizontal offset]*65536 + [vertical offset]
Замечания:
  * Данные доступны только активному окну.
  * После прочтения значения обнуляются.
  * Данные имеют знаковые значения.

======================================================================
================== Функция 38 - нарисовать отрезок. ==================
======================================================================
Параметры:
  * eax = 38 - номер функции
  * ebx = [координата начала по оси x]*65536 +
              [координата конца по оси x]
  * ecx = [координата начала по оси y]*65536 +
              [координата конца по оси y]
  * edx = 0x00RRGGBB - цвет
    edx = 0x01xxxxxx - рисовать инверсный отрезок
          (младшие 24 бита игнорируются)
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Координаты берутся относительно окна.
  * Конечная точка также рисуется.

======================================================================
== Функция 39, подфункция 1 - получить размер фонового изображения. ==
======================================================================
Параметры:
  * eax = 39 - номер функции
  * ebx = 1 - номер подфункции
Возвращаемое значение:
  * eax = [ширина]*65536 + [высота]
Замечания:
  * Есть парная команда установки размеров фонового изображения -
    подфункция 1 функции 15. После которой, разумеется, следует
    заново определить само изображение.

======================================================================
= Функция 39, подфункция 2 - прочитать точку с фонового изображения. =
======================================================================
Параметры:
  * eax = 39 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = смещение
Возвращаемое значение:
  * eax = 0x00RRGGBB - цвет точки, если смещение допустимо
    (меньше 0x160000-16)
  * eax = 2 - иначе
Замечания:
  * Не следует полагаться на возвращаемое значение в случае неверного
    смещения, оно может измениться в следующих версиях ядра.
  * Смещение точки с координатами (x,y) вычисляется как (x+y*xsize)*3.
  * Есть парная функция установки точки на фоновом изображении -
    подфункция 2 функции 15.

======================================================================
====== Функция 39, подфункция 4 - получить режим отрисовки фона. =====
======================================================================
Параметры:
  * eax = 39 - номер функции
  * ebx = 4 - номер подфункции
Возвращаемое значение:
  * eax = 1 - замостить
  * eax = 2 - растянуть
Замечания:
  * Есть парная функция установки режима отрисовки фона -
    подфункция 4 функции 15.

======================================================================
======== Функция 40 - установить маску для ожидаемых событий. ========
======================================================================
Маска для ожидаемых событий влияет на функции работы с событиями 10,
11, 23 - они сообщают только о событиях, разрешённых этой маской.
Параметры:
  * eax = 40 - номер функции
  * ebx = маска: бит i соответствует событию i+1 (см. список событий)
    (установленный бит разрешает извещение о событии)
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Маска по умолчанию (7=111b) разрешает извещения о перерисовке
    и нажатиях клавиш и кнопок.
    Этого достаточно для большинства приложений.
  * События, запрещённые в маске, всё равно сохраняются, если
    приходят; о них просто не извещают функции работы с событиями.
  * Функции работы с событиями учитывают маску на момент
    вызова функции, а не на момент поступления сообщения.

======================================================================
================= Функция 41 - узнать владельца IRQ. =================
======================================================================
Параметры:
  * eax = 41 - номер функции
  * ebx = номер IRQ, 0..15
Возвращаемое значение:
  * eax = PID владельца
  * eax = 0, если владельца нет
  * eax = -1 для некорректного ebx

======================================================================
========== Функция 42 - прочитать данные, полученные по IRQ. =========
======================================================================
При возникновении IRQ система может считывать данные из указанных
ранее функцией 44 портов и записывать эти данные в буфер.
Описываемая функция считывает побайтно данные из этого буфера.
Параметры:
  * eax = 42 - номер функции
  * ebx = номер IRQ, 0..15
Возвращаемое значение: (ситуацию можно различить по значению ecx)
  * если поток не является владельцем IRQ
    (или номер IRQ задан неверно):
    * ecx = 2
  * если данных нет:
    * eax = 0
    * ecx = 1
    * ebx разрушается
  * если всё в порядке и данные были:
    * eax = размер данных, ещё не прочитанных из буфера (в байтах)
    * ecx = 0
    * ebx = очередной байт
Замечания:
  * Предварительно поток должен зарезервировать для себя указанный IRQ
    функцией 45.
  * Размер буфера для данных - 4000 байт, при переполнении
    "свежие" данные перестают записываться в буфер.

======================================================================
=================== Функция 43 - ввод/вывод в порт. ==================
======================================================================

------------------------ Вывод данных в порт -------------------------
Параметры:
  * eax = 43 - номер функции
  * bl = байт для вывода
  * ecx = номер порта 0xnnnn (от 0 до 0xFFFF)
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - поток не зарезервировал указанный порт

------------------------ Ввод данных из порта ------------------------
Параметры:
  * eax = 43 - номер функции
  * ebx игнорируется
  * ecx = 0x8000nnnn, где nnnn = номер порта (от 0 до 0xFFFF)
Возвращаемое значение:
  * eax = 0 - успешно, при этом ebx = введённый байт
  * eax = 1 - поток не зарезервировал данный порт
Замечания:
  * Предварительно поток должен зарезервировать за собой
    указанный порт функцией 46.
  * Для зарезервированных портов вместо вызова этих функций
    лучше использовать команды процессора in/out - это значительно
    быстрее и несколько короче и проще. Из незарезервированных
    портов читать всё равно нельзя.

======================================================================
======== Функция 44 - определить действия при поступлении IRQ. =======
======================================================================
При возникновении IRQ система может считывать данные из указанных этой
функцией портов и записывать эти данные в буфер, откуда их можно
прочитать функцией 42.
Параметры:
  * eax = 44 - номер функции
  * ebx = указатель на массив структур, описывающих по одному порту:
    * +0: word: 0 означает конец массива, иначе номер порта
    * +2: byte: зарезервировано (игнорируется)
    * +3: byte: 1=считывать байт из этого порта, 2=считывать слово
  * ecx = номер IRQ, 0..15
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - поток не является владельцем указанного IRQ
Замечания:
  * Предварительно поток должен зарезервировать за собой
    указываемый IRQ функцией 45.
  * Принимаются во внимание только первые 16 портов.
  * Текущая реализация рассматривает неправильное значение поля +3
    как сигнал прекращения обработки IRQ.

======================================================================
============ Функция 45 - зарезервировать/освободить IRQ. ============
======================================================================
Параметры:
  * eax = 45 - номер функции
  * ebx = 0 - зарезервировать, 1 = освободить
  * ecx = номер IRQ, 0..15
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - ошибка (неверный номер IRQ или
    попытка зарезервировать несвободный IRQ или освободить IRQ, не
    зарезервированный текущим потоком)
Замечания:
  * Резервирование IRQ нужно для работы функций 42 и 44.
  * Только один поток может зарезервировать конкретный IRQ.
  * IRQ, обрабатываемые системой самостоятельно, резервируются
    системой (потоком 1) при загрузке.
  * При завершении потока автоматически освобождаются
    все зарезервированные им IRQ.

======================================================================
= Функция 46 - зарезервировать/освободить группу портов ввода/вывода.
======================================================================
К зарезервированным портам можно обращаться напрямую из приложения
командами in/out (рекомендуемый способ) и вызовом функции 43
(нерекомендуемый способ).
Параметры:
  * eax = 46 - номер функции
  * ebx = 0 - зарезервировать, 1 - освободить
  * ecx = номер начала диапазона портов
  * edx = номер конца диапазона портов (включительно)
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - ошибка
Замечания:
  * В случае резервирования портов ошибкой считается выполнение
    одного из условий:
    * начальный адрес больше конечного;
    * указанный диапазон содержит некорректный номер порта
      (корректные - от 0 до 0xFFFF);
    * превышено ограничение на общее число зарезервированных областей
      - допускается максимум 255;
    * указанный диапазон пересекается с одним из
      ранее зарезервированных
  * В случае освобождения портов ошибкой считается попытка
    освобождения диапазона, который ранее не был целиком
    зарезервирован этой же функцией (с такими же значениями ecx,edx).
  * При обнаружении ошибки (в обоих случаях) никаких действий
    не производится.
  * При загрузке система резервирует за собой порты
    0..0x2d, 0x30..0x4d, 0x50..0xdf, 0xe5..0xff (включительно).
  * При завершении потока автоматически освобождаются все
    зарезервированные им порты.

======================================================================
================= Функция 47 - вывести число в окно. =================
======================================================================
Параметры:
  * eax = 47 - номер функции
  * ebx = параметры преобразования числа в текст:
    * bl = 0 - ecx содержит число
    * bl = 1 - ecx содержит указатель на dword-число
    * bh = 0 - отображать в десятичной системе счисления
    * bh = 1 - отображать в шестнадцатеричной системе
    * bh = 2 - отображать в двоичной системе
    * биты 16-21 = сколько цифр отображать
    * биты 22-31 зарезервированы и должны быть установлены в 0
  * ecx = число (при bl=0) или указатель (при bl=1)
  * edx = [координата по оси x]*65536 + [координата по оси y]
  * esi = 0xX0RRGGBB:
    * RR, GG, BB задают цвет
    * X = ABnn (биты)
    * nn = шрифт (0/1)
    * A игнорируется
    * B=1 - закрашивать фон цветом edi
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Указанная длина не должна превосходить 60.
  * Выводится ровно указанное количество цифр. Если число мало и
    может быть записано меньшим количеством цифр, оно дополняется
    ведущими нулями; если число велико и не может быть записано
    таким количеством цифр, "лишние" ведущие цифры обрезаются.
  * Параметры шрифтов указаны в описании функции 4 (вывода текста).

======================================================================
======= Функция 48, подфункция 0 - применить настройки экрана. =======
======================================================================
Параметры:
  * eax = 48 - номер функции
  * ebx = 0 - номер подфункции
  * ecx = 0 - зарезервировано
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Функция перерисовывает экран после изменения параметров
    подфункциями 1 и 2.
  * Вызов функции без предшествующих вызовов указанных подфункций
    игнорируется.
  * Вызов функции с ненулевым ecx игнорируется.

======================================================================
========= Функция 48, подфункция 1 - установить стиль кнопок. ========
======================================================================
Параметры:
  * eax = 48 - номер функции
  * ebx = 1 - номер подфункции
  * ecx = тип кнопок:
    * 0 = плоские
    * 1 = объёмные
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * После вызова описываемой функции следует перерисовать экран
    подфункцией 0.
  * Тип кнопок влияет только на их прорисовку функцией 8.

======================================================================
==== Функция 48, подфункция 2 - установить стандартные цвета окон. ===
======================================================================
Параметры:
  * eax = 48 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = указатель на таблицу цветов
  * edx = размер таблицы цветов
    (должен быть 40 байт для будущей совместимости)
Формат таблицы цветов указан в описании подфункции 3.
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * После вызова описываемой функции следует перерисовать экран
    подфункцией 0.
  * Таблица стандартных цветов влияет только на приложения,
    которые эту таблицу явным образом получают (подфункцией 3) и
    используют (указывая цвета из неё при вызовах функций рисования).
  * Таблица стандартных цветов входит в скин и устанавливается заново
    при установке скина (подфункции 8).
  * Таблицу цветов можно просматривать/изменять интерактивно с помощью
    приложения desktop.

======================================================================
===== Функция 48, подфункция 3 - получить стандартные цвета окон. ====
======================================================================
Параметры:
  * eax = 48 - номер функции
  * ebx = 3 - номер подфункции
  * ecx = указатель на буфер размером edx байт,
    куда будет записана таблица
  * edx = размер таблицы цветов
    (должен быть 40 байт для будущей совместимости)
Возвращаемое значение:
  * функция не возвращает значения
Формат таблицы цветов: каждый элемент -
dword-значение цвета 0x00RRGGBB
  * +0: dword: frames - цвет рамки
  * +4: dword: grab - цвет заголовка
  * +8: dword: grab_button - цвет кнопки на полосе заголовка
  * +12 = +0xC: dword: grab_button_text - цвет текста на кнопке
    на полосе заголовка
  * +16 = +0x10: dword: grab_text - цвет текста на заголовке
  * +20 = +0x14: dword: work - цвет рабочей области
  * +24 = +0x18: dword: work_button - цвет кнопки в рабочей области
  * +28 = +0x1C: dword: work_button_text - цвет текста на кнопке
    в рабочей области
  * +32 = +0x20: dword: work_text - цвет текста в рабочей области
  * +36 = +0x24: dword: work_graph - цвет графики в рабочей области
Замечания:
  * Структура таблицы цветов описана в стандартном включаемом файле
    macros.inc под названием system_colors; например, можно писать:
    	sc	system_colors		; объявление переменной
    	...				; где-то надо вызвать
    					; описываемую функцию с ecx=sc
    	mov	ecx, [sc.work_button_text]	; читаем цвет текста
    					; на кнопке в рабочей области
  * Использование/неиспользование этих цветов - дело исключительно
    самой программы. Для использования нужно просто при вызове функций
    рисования указывать цвет, взятый из этой таблицы.
  * При изменении таблицы стандартных цветов (подфункцией 2 с
    последующим применением изменений подфункцией 0 или
    при установке скина подфункцией 8) всем окнам посылается сообщение
    о необходимости перерисовки (событие с кодом 1).
  * Стандартные цвета можно просматривать/изменять интерактивно
    с помощью приложения desktop.

======================================================================
========== Функция 48, подфункция 4 - получить высоту скина. =========
======================================================================
Параметры:
  * eax = 48 - номер функции
  * ebx = 4 - номер подфункции
Возвращаемое значение:
  * eax = высота скина
Замечания:
  * Высотой скина по определению считается высота заголовка окон,
    использующих скин.
  * Смотри также общую структуру окна в описании функции 0.

======================================================================
===== Функция 48, подфункция 5 - получить рабочую область экрана. ====
======================================================================
Параметры:
  * eax = 48 - номер функции
  * ebx = 5 - номер подфункции
Возвращаемое значение:
  * eax = [left]*65536 + [right]
  * ebx = [top]*65536 + [bottom]
Замечания:
  * Рабочая область экрана определяет положение и координаты
    максимизированного окна.
  * Рабочая область экрана при нормальной работе есть весь экран
    за вычетом панели (@panel).
  * (left,top) - координаты левого верхнего угла,
    (right,bottom) - координаты правого нижнего.
    Таким образом, размер рабочей области по оси x определяется
    формулой right-left+1, по оси y - формулой bottom-right+1.
  * Смотри также функцию 14,
    позволяющую определить размеры всего экрана.
  * Есть парная функция установки рабочей области - подфункция 6.

======================================================================
==== Функция 48, подфункция 6 - установить рабочую область экрана. ===
======================================================================
Параметры:
  * eax = 48 - номер функции
  * ebx = 6 - номер подфункции
  * ecx = [left]*65536 + [right]
  * edx = [top]*65536 + [bottom]
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Рабочая область экрана определяет положение и координаты
    максимизированного окна.
  * Эта функция используется только приложением @panel,
    устанавливающим рабочей областью весь экран за вычетом панели.
  * (left,top) - координаты левого верхнего угла,
    (right,bottom) - координаты правого нижнего.
    Таким образом, размер рабочей области по оси x определяется
    формулой right-left+1, по оси y - формулой bottom-right+1.
  * Если left>=right, то x-координаты рабочей области не изменяются.
    Если left<0, то left не устанавливается. Если right больше
    или равно ширины экрана, то right не устанавливается.
    Аналогично по оси y.
  * Смотри также функцию 14,
    позволяющую определить размеры всего экрана.
  * Есть парная функция получения рабочей области -
    подфункция 5.
  * Эта функция автоматически перерисовывает экран, по ходу дела
    обновляет координаты и размеры максимизированных окон.
    Все окна извещаются о необходимости перерисовки (событие 1).

======================================================================
====================== Функция 48, подфункция 7 ======================
============ Получить область скина для текста заголовка. ============
======================================================================
Возвращает область заголовка окна со скином, предназначенную
для вывода текста заголовка.
Параметры:
  * eax = 48 - номер функции
  * ebx = 7 - номер подфункции
Возвращаемое значение:
  * eax = [left]*65536 + [right]
  * ebx = [top]*65536 + [bottom]
Замечания:
  * Использование/неиспользование этой функции -
    личное дело приложения.
  * Рекомендуется учитывать значения, возвращаемые этой функцией,
    при выборе места для рисования текста заголовка (функцией 4) или
    какого-нибудь заменителя текста заголовка
    (по усмотрению приложения).

======================================================================
==== Функция 48, подфункция 8 - установить используемый скин окон. ===
======================================================================
Параметры:
  * eax = 48 - номер функции
  * ebx = 8 - номер подфункции
  * ecx = указатель на имя файла скина
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - не удалось загрузить файл
  * eax = 2 - файл не является файлом скина
Замечания:
  * При успешной загрузке скина все окна извещаются о необходимости
    перерисовки (событие 1).
  * При загрузке система считывает скин из файла default.skn
    на рамдиске.
  * Пользователь может изменять скин статически, создав свой
    default.skn, или динамически с помощью приложения desktop.

======================================================================
============ Функция 49 - Advanced Power Management (APM). ===========
======================================================================
Параметры:
  * eax = 49 - номер функции
  * dx = номер функции APM (аналог ax в спецификации)
  * bx, cx = параметры функции APM
Возвращаемое значение:
  * 16-битные регистры ax, bx, cx, dx, si, di и флаг CF
    установлены в соответствии со спецификацией APM
  * старшие половины 32-битных регистров eax, ebx, ecx,
    edx, esi, edi разрушаются
Замечания:
  * Спецификация APM 1.2 описывается в документе
    "Advanced Power Management (APM) BIOS Specification"
    (Revision 1.2), доступном на
    http://www.microsoft.com/whdc/archive/amp_12.mspx;
    кроме того, она включена в известный Interrupt List by Ralf Brown
    (http://www.pobox.com/~ralf/files.html,
    ftp://ftp.cs.cmu.edu/afs/cs/user/ralf/pub/).

======================================================================
================= Функция 50 - установка формы окна. =================
======================================================================
Обычные окна представляют собой прямоугольники. С помощью этой функции
окну можно придать произвольную форму. Форма задаётся набором точек
внутри обрамляющего прямоугольника, принадлежащих окну. Положение и
размеры обрамляющего прямоугольника задаются функцией 0 и изменяются
функцией 67.

--------------- Установка данных с информацией о форме ---------------
Параметры:
  * eax = 50 - номер функции
  * ebx = 0 - номер подфункции
  * ecx = указатель на данные формы (массив байт 0/1)
Возвращаемое значение:
  * функция не возвращает значения

------------------ Установка масштаба данных формы -------------------
Параметры:
  * eax = 50 - номер функции
  * ebx = 1 - номер подфункции
  * ecx задаёт масштаб: каждый байт данных определяет
    (2^scale)*(2^scale) пикселей
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Масштаб по умолчанию равен 0 (масштабирующий множитель 1). Если в
    данных формы один байт соответствует одному пикселю, то масштаб
    можно не устанавливать.
  * Обозначим xsize = ширина окна (в пикселях), ysize = высота;
    обратите внимание, что они на единицу больше, чем устанавливаемые
    функциями 0, 67.
  * По определению масштаба xsize и ysize должны делиться на 2^scale.
  * Байт данных по смещению a должен быть 0/1 и
    определяет принадлежность окну квадрата со стороной 2^scale
    (при scale=0 получаем пиксель) и координатами левого верхнего угла
    (a mod (xsize shr scale), a div (xsize shr scale))
  * Размер данных: (xsize shr scale)*(ysize shr scale).
  * Данные должны присутствовать в памяти и не меняться
    после установки формы.
  * Система просматривает данные о форме при каждой перерисовке окна
    функцией 0.
  * Вызов подфункции 0 с нулевым указателем приводит к возврату
    к прямоугольной форме.

======================================================================
===================== Функция 51 - создать поток. ====================
======================================================================
Параметры:
  * eax = 51 - номер функции
  * ebx = 1 - единственная подфункция
  * ecx = адрес точки входа потока (начальный eip)
  * edx = указатель стэка потока (начальный esp)
Возвращаемое значение:
  * eax = -1 - ошибка (в системе слишком много потоков)
  * иначе eax = TID - идентификатор потока

======================================================================
= Функция 52, подфункция 0 - получить конфигурацию сетевого драйвера.
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 0 - номер подфункции
Возвращаемое значение:
  * eax = двойное слово конфигурации
Замечания:
  * Слово конфигурации можно установить подфункцией 2.
  * Ядро не использует соответствующую переменную.
    Ценность этой переменной и работающих с ней подфункций 0 и 2
    представляется сомнительной.

======================================================================
======= Функция 52, подфункция 1 - получить локальный IP-адрес. ======
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 1 - номер подфункции
Возвращаемое значение:
  * eax = IP-адрес (4 байта)
Замечания:
  * Локальный IP-адрес устанавливается подфункцией 3.

======================================================================
 Функция 52, подфункция 2 - установить конфигурацию сетевого драйвера.
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = двойное слово конфигурации; если младшие 7 бит образуют
    число 3, это воспринимается как запрос на [пере-]инициализацию
    Ethernet-карты, в противном случае Ethernet выключается
Возвращаемое значение:
  * если не запрошен Ethernet-интерфейс, то возвращается eax=2,
    но это может измениться в будущих версиях ядра
  * если запрошен Ethernet-интерфейс, то eax=0 означает ошибку
    (отсутствие Ethernet-карты), а ненулевое значение - успех
Замечания:
  * Слово конфигурации можно прочитать подфункцией 0.
  * Ядро не использует соответствующую переменную.
    Ценность этой переменной, подфункции 0 и части подфункции 2,
    устанавливающей эту переменную, представляется сомнительной.

======================================================================
====== Функция 52, подфункция 3 - установить локальный IP-адрес. =====
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 3 - номер подфункции
  * ecx = IP-адрес (4 байта)
Возвращаемое значение:
  * текущая реализация возвращает eax=3, но это может быть изменено
    в будущих версиях
Замечания:
  * Локальный IP-адрес можно получить подфункцией 1.

======================================================================
= Функция 52, подфункция 6 - добавить данные в стек входной очереди. =
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 6 - номер подфункции
  * edx = размер данных
  * esi = указатель на данные
Возвращаемое значение:
  * eax = -1 - ошибка
  * eax = 0 - успешно
Замечания:
  * Эта функция предназначена только для медленных сетевых драйверов
    (PPP, SLIP).
  * Размер данных не должен превосходить 1500 байт,
    хотя проверок корректности не делается.

======================================================================
====================== Функция 52, подфункция 8 ======================
============= Прочитать данные из сетевой очереди вывода. ============
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 8 - номер подфункции
  * esi = указатель на буфер размером 1500 байт
Возвращаемое значение:
  * eax = число прочитанных байт (в текущей реализации
    либо 0 = нет данных, либо 1500)
  * данные скопированы в буфер
Замечания:
  * Эта функция предназначена только для медленных сетевых драйверов
    (PPP, SLIP).

======================================================================
=========== Функция 52, подфункция 9 - получить gateway IP. ==========
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 9 - номер подфункции
Возвращаемое значение:
  * eax = gateway IP (4 байта)

======================================================================
========= Функция 52, подфункция 10 - получить маску подсети. ========
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 10 - номер подфункции
Возвращаемое значение:
  * eax = маска подсети

======================================================================
========= Функция 52, подфункция 11 - установить gateway IP. =========
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 11 - номер подфункции
  * ecx = gateway IP (4 байта)
Возвращаемое значение:
  * текущая реализация возвращает eax=11, но это может быть изменено
    в будущих реализациях

======================================================================
======== Функция 52, подфункция 12 - установить маску подсети. =======
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 12 - номер подфункции
  * ecx = маска подсети
Возвращаемое значение:
  * текущая реализация возвращает eax=12, но это может быть изменено
    в будущих версиях

======================================================================
============ Функция 52, подфункция 13 - получить DNS IP. ============
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 13 - номер подфункции
Возвращаемое значение:
  * eax = DNS IP (4 байта)

======================================================================
=========== Функция 52, подфункция 14 - установить DNS IP. ===========
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 14 - номер подфункции
  * ecx = DNS IP (4 байта)
Возвращаемое значение:
  * текущая реализация возвращает eax=14, но это может быть изменено
    в следующих версиях

======================================================================
====== Функция 52, подфункция 15 - получить локальный MAC-адрес. =====
======================================================================
Параметры:
  * eax = 52 - номер функции
  * ebx = 15 - номер подфункции
  * ecx = 0 - читать первые 4 байта,
    ecx = 4 - читать последние 2 байта
Возвращаемое значение:
  * для ecx=0: eax = первые 4 байта MAC-адреса
  * для ecx=4: ax = последние 2 байта MAC-адреса,
               старшая половина eax разрушается
  * для других ecx: eax = -1 как признак ошибки

======================================================================
============ Функция 53, подфункция 0 - открыть UDP-сокет. ===========
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 0 - номер подфункции
  * ecx = локальный порт (учитывается только младшее слово)
  * edx = удалённый порт (учитывается только младшее слово)
  * esi = удалённый IP
Возвращаемое значение:
  * eax = -1 = 0xFFFFFFFF - ошибка; ebx разрушается
  * eax = хэндл сокета (некоторое число, однозначно идентифицирующее
    сокет и имеющее смысл только для системы) - успешно;
    ebx разрушается

======================================================================
============ Функция 53, подфункция 1 - закрыть UDP-сокет. ===========
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 1 - номер подфункции
  * ecx = хэндл сокета
Возвращаемое значение:
  * eax = -1 - неверный хэндл
  * eax = 0 - успешно
  * ebx разрушается
Замечания:
  * Текущая реализация не закрывает автоматически все сокеты потока
    при его завершении. В частности, не следует прибивать поток
    с кучей открытых сокетов - будет утечка ресурсов.
  * Текущая реализация не делает проверок на корректность
    (единственное, на что возвращается ошибка, - попытка закрыть
    неоткрытый сокет с корректным хэндлом).

======================================================================
============== Функция 53, подфункция 2 - опрос сокета. ==============
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = хэндл сокета
Возвращаемое значение:
  * eax = число полученных байт
  * ebx разрушается
Замечания:
  * Проверки корректности не делается.

======================================================================
======== Функция 53, подфункция 3 - прочитать байт из сокета. ========
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 3 - номер подфункции
  * ecx = хэндл сокета
Возвращаемое значение:
  * если нет принятых данных: eax=0, bl=0,
    прочие байты ebx разрушаются
  * если были принятые данные: eax=число оставшихся байт
    (возможно, 0), bl=прочитанный байт, прочие байты ebx разрушаются
Замечания:
  * Проверки корректности не производится.

======================================================================
========== Функция 53, подфункция 4 - записать в UDP-сокет. ==========
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 4 - номер подфункции
  * ecx = хэндл сокета
  * edx = число байт для записи
  * esi = указатель на данные для записи
Возвращаемое значение:
  * eax = 0xffffffff - неверный хэндл
  * eax = 0xffff - недостаточно памяти
  * eax = 0 - успешно
  * ebx разрушается
Замечания:
  * Проверка на правильность хэндла минимальна - исключаются только
    не очень неправильные неоткрытые хэндлы.
  * Число байт для записи не может превышать 1500-28, хотя
    соответствующей проверки не делается.

======================================================================
============ Функция 53, подфункция 5 - открыть TCP-сокет. ===========
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 5 - номер подфункции
  * ecx = локальный порт (учитывается только младшее слово)
  * edx = удалённый порт (учитывается только младшее слово)
  * esi = удалённый IP
  * edi = режим открытия: SOCKET_PASSIVE=0 или SOCKET_ACTIVE=1
Возвращаемое значение:
  * eax = -1 = 0xFFFFFFFF - ошибка; ebx разрушается
  * eax = хэндл сокета (некоторое число, однозначно идентифицирующее
    сокет и имеющее смысл только для системы) - успешно;
    ebx разрушается

======================================================================
====== Функция 53, подфункция 6 - получить состояние TCP-сокета. =====
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 6 - номер подфункции
  * ecx = хэндл сокета
Возвращаемое значение:
  * eax = статус сокета: одно из
  * TCB_LISTEN = 1
  * TCB_SYN_SENT = 2
  * TCB_SYN_RECEIVED = 3
  * TCB_ESTABLISHED = 4
  * TCB_FIN_WAIT_1 = 5
  * TCB_FIN_WAIT_2 = 6
  * TCB_CLOSE_WAIT = 7
  * TCB_CLOSING = 8
  * TCB_LAST_ASK = 9
  * TCB_TIME_WAIT = 10
  * TCB_CLOSED = 11
  * ebx разрушается
Замечания:
  * Проверок корректности не производится.

======================================================================
========== Функция 53, подфункция 7 - записать в TCP-сокет. ==========
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 7 - номер подфункции
  * ecx = хэндл сокета
  * edx = число байт для записи
  * esi = указатель на данные для записи
Возвращаемое значение:
  * eax = 0xffffffff - ошибка
  * eax = 0xffff - недостаточно памяти
  * eax = 0 - успешно
  * ebx разрушается
Замечания:
  * Проверка на правильность хэндла минимальна - исключаются только
    не очень неправильные неоткрытые хэндлы.
  * Число байт для записи не может превышать 1500-40,
    хотя соответствующей проверки не делается.

======================================================================
============ Функция 53, подфункция 8 - закрыть TCP-сокет. ===========
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 8 - номер подфункции
  * ecx = хэндл сокета
Возвращаемое значение:
  * eax = -1 - неверный хэндл
  * eax = 0xffff - недостаточно памяти для пакета закрытия сокета
  * eax = 0 - успешно
  * во многих случаях eax разрушается (возвращается результат функции
    queue) - видимо, это баг, который будет исправлен
  * ebx разрушается
Замечания:
  * Текущая реализация не закрывает автоматически все сокеты потока
    при его завершении. В частности, не следует прибивать поток
    с кучей открытых сокетов - будет утечка ресурсов.
  * Текущая реализация не делает проверок на корректность
    (единственное, на что возвращается ошибка, - попытка закрыть
    неоткрытый сокет с корректным хэндлом).

======================================================================
== Функция 53, подфункция 9 - проверить, свободен ли локальный порт. =
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 9 - номер подфункции
  * ecx = номер локального порта (используются только младшие 16 бит)
Возвращаемое значение:
  * eax = 0 - порт используется
  * eax = 1 - порт свободен
  * ebx разрушается

======================================================================
==== Функция 53, подфункция 10 - получить статус кабеля Ethernet. ====
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 10 - номер подфункции
Возвращаемое значение:
  * al = -1 - драйвер сетевой карты не загружен или
              не поддерживает эту функцию
  * al = 0 - кабель не подключён
  * al = 1 - кабель подключён
  * ebx разрушается
Замечания:
  * Текущая реализация ядра поддерживает эту функцию
    только для сетевых карт RTL8139.

======================================================================
==== Функция 53, подфункция 11 - прочитать данные сетевого стека. ====
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 11 - номер подфункции
  * ecx = хэндл сокета
  * edx = указатель на буфер
  * esi = число байт для чтения;
  * esi = 0 - читать все данные (максимум 4096 байт)
Возвращаемое значение:
  * eax = число прочитанных байт
  * ebx разрушается
Замечания:
  * Проверки на правильность хэндла не делается.

======================================================================
 Функция 53, подфункция 255 - отладочная информация сетевого драйвера.
======================================================================
Параметры:
  * eax = 53 - номер функции
  * ebx = 255 - номер подфункции
  * ecx = тип запрашиваемой информации (смотри ниже)
Возвращаемое значение:
  * eax = запрошенная информация
  * ebx разрушается
Возможные значения ecx:
  * 100: длина очереди 0 (empty queue)
  * 101: длина очереди 1 (ip-out queue)
  * 102: длина очереди 2 (ip-in queue)
  * 103: длина очереди 3 (net1out queue)
  * 200: число элементов в таблице ARP
  * 201: размер таблицы ARP (в элементах) (20 в текущей версии)
  * 202: прочитать элемент edx таблицы ARP во временный буфер, откуда
    берут информацию 5 последующих типов;
    в этом случае eax неопределён
  * 203: IP-адрес, запомненный типом 202
  * 204: старшее dword MAC-адреса, запомненного типом 202
  * 205: младшее word MAC-адреса, запомненного типом 202
  * 206: слово статуса, запомненное типом 202
  * 207: слово ttl, запомненное типом 202
  * 2: общее число полученных IP-пакетов
  * 3: общее число переданных IP-пакетов
  * 4: общее число сдампленных полученных пакетов
  * 5: общее число полученных ARP-пакетов
  * 6: статус драйвера пакетов, 0=неактивен,
    ненулевое значение=активен

======================================================================
======== Функция 55, подфункция 0 - загрузить данные для SB16. =======
======================================================================
Параметры:
  * eax = 55 - номер функции
  * ebx = 0 - номер подфункции
  * ecx = указатель на данные (копируется 64 килобайта, используется
    столько, сколько установлено подфункцией 2)
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Формат и размер данных устанавливаются подфункцией 2.

======================================================================
==== Функция 55, подфункция 1 - начать проигрывать данные на SB16. ===
======================================================================
Параметры:
  * eax = 55 - номер функции
  * ebx = 1 - номер подфункции
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Предварительно данные должны быть загружены подфункцией 0 и
    определён их формат подфункцией 2.
  * Функция возвращает управление, когда началось проигрывание данных;
    после этого проигрывание идёт независимо от приложения (и вообще
    не требует загрузки процессора).
  * Предварительно должны быть определены базовый порт SB16
    (подфункцией 4 функции 21) и канал DMA
    (подфункцией 10 функции 21).

======================================================================
====== Функция 55, подфункция 2 - установить формат данных SB16. =====
======================================================================
Параметры:
  * eax = 55 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = 0 - установить разрядность
    * edx = 1 - 8бит моно
    * edx = 2 - 8бит стерео
  * ecx = 1 - установить размер данных
    * edx = размер в байтах
  * ecx = 2 - установить частоту проигрывания
    * edx = частота
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * При загрузке системы устанавливаются следующие параметры
    по умолчанию: разрядность - 8 бит моно, размер - 64 Кб,
    частота 44100 Гц. Тем не менее рекомендуется явно устанавливать
    необходимые значения, поскольку они могли быть переустановлены
    какой-нибудь программой.

======================================================================
====================== Функция 55, подфункция 55 =====================
========== Начать проигрывать данные на встроенном спикере. ==========
======================================================================
Параметры:
  * eax = 55 - номер функции
  * ebx = 55 - номер подфункции
  * esi = указатель на данные
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 55 - ошибка (спикер отключён или занят)
Данные - это массив элементов переменной длины.
Формат каждого элемента определяется первым байтом:
  * 0 = конец данных
  * 1..0x80 = задаёт длительность звучания в сотых долях секунды
    ноты, определяемой непосредственным значением частоты
    * следующее слово (2 байта) содержит делитель частоты;
      частота определяется как 1193180/divider
  * 0x81 = invalid
  * 0x82..0xFF = нота, определяемая октавой и номером:
    * длительность в сотых долях секунды = (первый байт)-0x81
    * присутствует ещё один байт;
    * (второй байт)=0xFF - пауза
    * иначе он имеет вид a*0x10+b, где b=номер ноты в октаве от 1
      до 12, a=номер октавы (считая с 0)
Замечания:
  * Пищание спикером может быть запрещено/разрешено подфункцией 8
    функции 18.
  * Функция возвращает управление, сообщив куда следует информацию
    о запросе. Само проигрывание идёт независимо от программы.
  * Данные должны сохраняться в памяти по крайней мере
    до конца проигрывания.

======================================================================
============================ Функция 57 ==============================
====================== Вызов сервисов PCIBIOS ========================
======================================================================
Параметры:
  * eax = 57
  * ebp = соответствует регистру al по спецификации PCIBIOS
  * остальные регистры по спецификации PCIBIOS
Возвращаемые значения:
   * CF не определён
   * остальные регистры по спецификации PCIBIOS

======================================================================
============== Функция 58 - работа с файловой системой. ==============
======================================================================
Параметры:
  * eax = 58
  * ebx = указатель на информационную структуру
Возвращаемое значение:
  * eax = 0 - успешно; иначе код ошибки файловой системы
  * в зависимости от подфункции может возвращаться значение и
    в других регистрах
Общий формат информационной структуры:
  * +0: dword: номер подфункции
  * +4: dword: номер блока
  * +8: dword: размер
  * +12 = +0xC: dword: указатель на данные
  * +16 = +0x10: dword: указатель на память для работы системы
    (4096 байт)
  * +20 = +0x14: n db: ASCIIZ-строка с именем файла
Уточнения - в документации на соответствующую подфункцию.
Имя файла нечувствительно к регистру латинских букв,
русские буквы должны быть заглавными.
Формат имени файла:
/base/number/dir1/dir2/.../dirn/file,
где /base/number идентифицирует устройство, на котором ищется файл:
одно из
  * /RD/1 = /RAMDISK/1 для доступа к рамдиску
  * /FD/1 = /FLOPPYDISK/1 для доступа к первому флоппи-дисководу,
    /FD/2 = /FLOPPYDISK/2 для второго флоппи-дисковода
  * /HD/x = /HARDDISK/x - устаревший вариант доступа к жёсткому диску
    (в этом случае база определяется подфункцией 7 функции 21),
    x - номер раздела (считая с 1)
  * /HD0/x, /HD1/x, /HD2/x, /HD3/x для доступа соответственно
    к устройствам IDE0 (Primary Master), IDE1 (Primary Slave),
    IDE2 (Secondary Master), IDE3 (Secondary Slave);
    x - номер раздела на выбранном винчестере, изменяется от 1 до 255
    (на каждом из винчестеров нумерация начинается с 1)
Замечания:
  * В первых двух случаях допускается использование FIRST вместо 1,
    SECOND вместо 2, но использовать эту возможность
    не рекомендуется для удобства перехода на будущие расширения.
  * Накладывается ограничение n<=39.
  * Имена папок и файла dir1,...,dirn,file должны быть в формате 8.3:
    имя не более 8 символов, точка, расширение не более 3 символов.
    Хвостовые пробелы игнорируются. Других пробелов быть не должно.
    Если имя занимает ровно 8 символов, точку можно опустить
    (хотя пользоваться этим не рекомендуется для удобства перехода
    на будущие расширения).
  * Функция не поддерживает папок на рамдиске.
Примеры:
  * '/RAMDISK/FIRST/KERNEL.ASM',0
    '/rd/1/kernel.asm',0
  * '/HD0/1/kernel.asm',0
  * '/hd0/1/menuet/pics/tanzania.bmp',0
Доступные подфункции:
  * подфункция 0 - чтение файла/папки
  * подфункция 8 - LBA-чтение с устройства
  * подфункция 15 - получение информации о файловой системе

======================================================================
========== Функция 58, подфункция 0 - прочитать файл/папку. ==========
======================================================================
Параметры:
  * eax = 58
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 0 = номер подфункции
  * +4: dword: номер блока для чтения (считая с 0)
  * +8: dword: число блоков для чтения
  * +12 = +0xC: dword: указатель на буфер, куда будут записаны данные
  * +16 = +0x10: dword: указатель на буфер для работы системы
    (4096 байт)
  * +20 = +0x14: ASCIIZ-имя файла, правила формирования имён указаны в
    общем описании
Возвращаемое значение:
  * eax = 0 - успешно, иначе код ошибки файловой системы
  * ebx = размер файла (в байтах) или
    -1=0xffffffff, если файл не найден
Замечания:
  * Размер блока - 512 байт.
  * Эта функция устарела, для чтения файлов используйте подфункцию 0
    функции 70, для чтения папок - подфункцию 1 функции 70.
  * Функция позволяет читать содержимое папки. Из файловых систем
    поддерживается только FAT. Формат FAT-папки описан в любой
    документации по FAT.
  * Размер папки определяется по размеру цепочки кластеров в FAT.
  * Если файл кончился раньше, чем был прочитан последний запрошенный
    блок, то функция прочитает, сколько сможет, после чего вернёт
    eax=6 (EOF).
  * Функция позволяет читать корневые папки /rd/1,/fd/x,/hd[n]/x, но
    в первых двух случаях текущая реализация не следует
    установленным правилам:
    для /rd/1:
    * если указано 0 блоков для чтения, считается,
      что запрашивается 1;
    * если запрашивается больше 14 блоков или начальный блок
      не меньше 14-го, то возвращается eax=5 (not found) и ebx=-1;
    * размер корневого каталога рамдиска = 14 блоков,
      0x1C00=7168 байт; но возвращается ebx=0
      (за исключением случая предыдущего пункта);
    * как ни странно, можно прочитать 14-й блок (там, вообще говоря,
      мусор - напоминаю, счёт ведётся с 0);
    * если был запрошен хотя бы один блок с номером, не меньшим 14,
      то возвращается eax=6(EOF); иначе eax=0.
    Для /fd/x:
    * если начальный блок не меньше 14-го, то возвращается
      eax=5 (not found) и ebx=0;
    * кстати говоря, формат FAT12 допускает дискеты с размером
      корневого каталога меньше или больше 14 блоков;
    * проверки длины не делается;
    * если удалось прочитать данные с дискеты, возвращается
      eax=0,ebx=0; в противном случае eax=10 (access denied), ebx=-1.
  * Функция обрабатывает чтение специальных папок /,/rd,/fd,/hd[n];
    но результат не соответствует ожидаемому
    (по работе с обычными файлами/папками), не следует установленным
    правилам, может измениться в следующих версиях ядра и потому
    не описывается. Для получения информации об оборудовании
    используйте подфункцию 11 функции 18 или
    читайте соответствующие папки подфункцией 1 функции 70.

======================================================================
========= Функция 58, подфункция 8 - LBA-чтение с устройства. ========
======================================================================
Параметры:
  * eax = 58 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 8 = номер подфункции
  * +4: dword: номер блока для чтения (считая с 0)
  * +8: dword: игнорируется (устанавливайте в 1)
  * +12 = +0xC: dword: указатель на буфер, куда будут записаны данные
    (512 байт)
  * +16 = +0x10: dword: указатель на буфер для работы системы
    (4096 байт)
  * +20 = +0x14: ASCIIZ-имя устройства: нечувствительно к регистру,
    одно из /rd/1 = /RamDisk/1, /hd/n = /HardDisk/n,
    1<=n<=4 - номер устройства: 1=IDE0, ..., 4=IDE3.
    Вместо цифр допускается, хотя и не рекомендуется для удобства
    перехода на будущие расширения,
    использование 'first','second','third','fourth'.
Возвращаемое значение:
  * если указано имя устройства /hd/xxx, где xxx не находится
    в списке выше:
    * eax = ebx = 1
  * если указано неправильное имя устройства
    (за исключением предыдущего случая):
    * eax = 5
    * ebx не меняется
  * если LBA-доступ запрещён подфункцией 11 функции 21:
    * eax = 2
    * ebx разрушается
  * для рамдиска: попытка чтения блока за пределами рамдиска
    (18*2*80 блоков) приводит к
    * eax = 3
    * ebx = 0
  * при успешном чтении:
    * eax = ebx = 0
Замечания:
  * Размер блока - 512 байт; читается один блок.
  * Не следует полагаться на возвращаемое значение,
    оно может измениться в следующих версиях.
  * Требуется, чтобы был разрешён LBA-доступ к устройствам
    подфункцией 11 функции 21. Узнать это можно вызовом
    подфункцией 11 функции 26.
  * LBA-чтение дискеты не поддерживается.
  * Функция считывает данные физического жёсткого диска;
    если по каким-то причинам нужны данные конкретного раздела,
    придётся определять начальный сектор этого раздела
    (либо напрямую через MBR, либо из расширенной структуры,
    возвращаемой той же подфункцией 11 функции 18).
  * Функция не проверяет код ошибки жёсткого диска, так что запрос
    несуществующего сектора всё равно что-то прочитает
    (вероятнее всего, нули, но это определяется устройством) и
    это будет считаться успехом (eax=0).

======================================================================
= Функция 58, подфункция 15 - получить информацию о файловой системе.
======================================================================
Параметры:
  * eax = 58 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 15 = номер подфункции
  * +4: dword: игнорируется
  * +8: dword: игнорируется
  * +12 = +0xC: dword: игнорируется
  * +16 = +0x10: dword: игнорируется
  * +20 = +0x14: (проверяется только второй символ, сразу после слэша)
    /rd=/RAMDISK или /hd=/HARDDISK
Возвращаемое значение:
  * если второй символ не принадлежит множеству {'r','R','h','H'}:
    * eax = 3
    * ebx = ecx = dword [fileinfo] = 0
  * для рамдиска:
    * eax = 0 (успех)
    * ebx = общее число кластеров = 2847
    * ecx = число свободных кластеров
    * dword [fileinfo] = размер кластера = 512
  * для жёсткого диска: база и раздел определяются подфункциями 7 и 8
    функции 21:
    * eax = 0 (успех)
    * ebx = общее число кластеров
    * ecx = число свободных кластеров
    * dword [fileinfo] = размер кластера (в байтах)
Замечания:
  * Не удивляйтесь странному расположению 4-го возвращаемого
    параметра - когда писался этот код, при системных вызовах
    приложению возвращались только регистры eax,ebx,ecx (из
    pushad-структуры, передающейся как аргумент системной функции).
    Теперь это исправлено, так что, возможно, имеет смысл возвращать
    размер кластера в edx, пока эту функцию не начали использовать.
  * Вообще-то ещё существует подфункция 11 функции 18, возвращающая
    информацию о файловой системе. По расширенной таблице дисковой
    подсистемы можно определить размер кластера (там он хранится
    в секторах) и общее число кластеров для жёстких дисков.

======================================================================
=========== Функция 60 - Inter Process Communication (IPC). ==========
======================================================================
IPC применяется для посылок сообщений от одного процесса/потока
другому. При этом следует предварительно договориться о том, как
интерпретировать конкретное сообщение.

-------- Подфункция 1 - установить область для получения IPC ---------
Вызывается процессом-приёмником.
Параметры:
  * eax = 60 - номер функции
  * ebx = 1 - номер подфункции
  * ecx = указатель на буфер
  * edx = размер буфера
Возвращаемое значение:
  * eax = 0 - всегда успешно
Формат IPC-буфера:
  * +0: dword: если здесь не 0, то буфер считается заблокированным;
    блокируйте/разблокируйте буфер, когда вы с ним активно работаете
    и вам надо, чтобы извне не изменялись данные буфера
    (не поступали новые сообщения)
  * +4: dword: занято места в буфере (в байтах)
  * +8: первое сообщение
  * +8+n: второе сообщение
  * ...
Формат сообщения:
  * +0: dword: PID процесса/потока, пославшего сообщение
  * +4: dword: длина сообщения (не считая этот заголовок)
  * +8: n*byte: данные сообщения

--------------- Подфункция 2 - послать сообщение IPC. ----------------
Вызывается процессом-инициатором.
Параметры:
  * eax = 60 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = PID приёмника
  * edx = указатель на данные сообщения
  * esi = длина сообщения (в байтах)
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - приёмник не определил буфер для IPC-сообщений
    (может быть, ещё не успел, а может быть, это не тот поток,
    который нужен)
  * eax = 2 - приёмник заблокировал IPC-буфер;
    попробуйте немного подождать
  * eax = 3 - переполнение IPC-буфера приёмника
  * eax = 4 - процесса/потока с таким PID не существует
Замечания:
  * Система сразу после записи IPC-сообщения в буфер посылает
    потоку-приёмнику событие с кодом 7 (см. коды событий).

======================================================================
=== Функция 61 - получить параметры для прямого доступа к графике. ===
======================================================================
Программе доступны данные графического экрана (область памяти, которая
собственно и отображает содержимое экрана) напрямую без вызовов
системных функций через селектор gs:
	mov	eax, [gs:0]
поместит в eax первый dword буфера, содержащий информацию о цвете
левой верхней точки (и, возможно, цвета нескольких следующих).
	mov	[gs:0], eax
при работе в режимах VESA c LFB
установит цвет левой верхней точки
(и возможно, цвета нескольких следующих).
Для интерпретации данных графического экрана требуется знание
некоторых параметров, которые возвращаются этой функцией.
Замечания:
  * Параметры графики очень редко меняются при работе системы,
    а именно, только в случаях, когда пользователь работает
    с программой VRR.
  * При изменении видеорежима система перерисовывает все окна
    (событие с кодом 1) и перерисовывает фон (событие 5).
    Эти же события происходят и в других случаях,
    которые встречаются значительно чаще, чем изменение видеорежима.
  * При работе в видеорежимах с LFB селектор gs указывает на
    собственно LFB, так что чтение/запись по gs приводят
    непосредственно к изменению содержимого экрана. При работе в
    видеорежимах без LFB gs указывает на некоторую область данных
    ядра, причём все функции вывода на экран добросовестно выполняют
    двойную работу по записи непосредственно на экран и по записи
    в этот буфер. В результате при чтении содержимого этого буфера
    результаты соответствуют содержимому экрана
    (с, вообще говоря, большим цветовым разрешением),
    а запись игнорируется.
    Исключением является режим 320*200, для которого в главном цикле
    системного потока выполняется обновление экрана в соответствии
    с движениями курсора мыши.

------------------------- Разрешение экрана --------------------------
Параметры:
  * eax = 61 - номер функции
  * ebx = 1 - номер подфункции
Возвращаемое значение:
  * eax = [разрешение по оси x]*65536 + [разрешение по оси y]
Замечания:
  * Можно использовать функцию 14 с учётом того, что она возвращает
    размеры на 1 меньше. Это полностью эквивалентный способ.

------------------------ Число бит на пиксель ------------------------
Параметры:
  * eax = 61 - номер функции
  * ebx = 2 - номер подфункции
Возвращаемое значение:
  * eax = число бит на пиксель (24 или 32)

------------------------ Число байт на строку ------------------------
Параметры:
  * eax = 61 - номер функции
  * ebx = 3 - номер подфункции
Возвращаемое значение:
  * eax = число байт, которое занимает одна строка развёртки
    (горизонтальная линия на экране)

======================================================================
===== Функция 62, подфункция 0 - получить версию PCI-интерфейса. =====
======================================================================
Параметры:
  * eax = 62 - номер функции
  * bl = 0 - номер подфункции
Возвращаемое значение:
  * eax = -1 - доступ к PCI запрещён; иначе
  * ah.al = версия PCI-интерфейса (ah=версия, al=подверсия)
  * старшее слово eax обнулено
Замечания:
  * Предварительно должен быть разрешён низкоуровневый доступ к PCI
    для приложений подфункцией 12 функции 21.
  * Если PCI BIOS не поддерживается, то значение ax неопределено.

======================================================================
==== Функция 62, подфункция 1 - получить номер последней PCI-шины. ===
======================================================================
Параметры:
  * eax = 62 - номер функции
  * bl = 1 - номер подфункции
Возвращаемое значение:
  * eax = -1 - доступ к PCI запрещён; иначе
  * al = номер последней PCI-шины; оставшиеся байты eax разрушаются
Замечания:
  * Предварительно должен быть разрешён низкоуровневый доступ к PCI
    для приложений подфункцией 12 функции 21.
  * Если PCI BIOS не поддерживается, то значение al неопределено.

======================================================================
====================== Функция 62, подфункция 2 ======================
== Получить механизм обращения к конфигурационному пространству PCI. =
======================================================================
Параметры:
  * eax = 62 - номер функции
  * bl = 2 - номер подфункции
Возвращаемое значение:
  * eax = -1 - доступ к PCI запрещён; иначе
  * al = механизм (1 или 2); прочие байты eax разрушаются
Замечания:
  * Предварительно должен быть разрешён низкоуровневый доступ к PCI
    для приложений подфункцией 12 функции 21.
  * Механизм обращения выбирается в соответствии
    с характеристиками оборудования.
  * Подфункции чтения и записи автоматически работают
    с выбранным механизмом.

======================================================================
======== Функция 62, подфункции 4,5,6 - прочитать PCI-регистр. =======
======================================================================
Параметры:
  * eax = 62 - номер функции
  * bl = 4 - читать байт
  * bl = 5 - читать слово
  * bl = 6 - читать двойное слово
  * bh = номер PCI-шины
  * ch = dddddfff, где ddddd = номер устройства на шине,
    fff = номер функции устройства
  * cl = номер регистра (должен быть чётным для bl=5,
    делиться на 4 для bl=6)
Возвращаемое значение:
  * eax = -1 - ошибка (запрещён доступ к PCI или
    неподдерживаемые параметры); иначе
  * al/ax/eax (в зависимости от запрошенного размера) содержит данные;
    оставшаяся часть регистра eax разрушается
Замечания:
  * Предварительно должен быть разрешён низкоуровневый доступ к PCI
    для приложений подфункцией 12 функции 21.
  * Механизм доступа 2 поддерживает только 16 устройств на шине и
    игнорирует номер функции. Получить механизм доступа можно вызовом
    подфункции 2.
  * Некоторые регистры стандартны и существуют для всех устройств,
    некоторые определяются конкретным устройством. Список первых
    входит, например, в известный Interrupt List by Ralf Brown
    (http://www.pobox.com/~ralf/files.html,
    ftp://ftp.cs.cmu.edu/afs/cs/user/ralf/pub/);
    список вторых должен быть указан в документации по устройству.

======================================================================
======= Функция 62, подфункции 8,9,10 - записать в PCI-регистр. ======
======================================================================
Параметры:
  * eax = 62 - номер функции
  * bl = 8 - писать байт
  * bl = 9 - писать слово
  * bl = 10 - писать двойное слово
  * bh = номер PCI-шины
  * ch = dddddfff, где ddddd = номер устройства на шине,
    fff = номер функции устройства
  * cl = номер регистра (должен быть чётным для bl=9,
    делиться на 4 для bl=10)
  * dl/dx/edx (в зависимости от запрошенного размера) содержит
    данные для записи
Возвращаемое значение:
  * eax = -1 - ошибка (запрещён доступ к PCI или
    неподдерживаемые параметры)
  * eax = 0 - успешно
Замечания:
  * Предварительно должен быть разрешён низкоуровневый доступ к PCI
    для приложений подфункцией 12 функции 21.
  * Механизм доступа 2 поддерживает только 16 устройств на шине и
    игнорирует номер функции. Получить механизм доступа можно вызовом
    подфункции 2.
  * Некоторые регистры стандартны и существуют для всех устройств,
    некоторые определяются конкретным устройством. Список первых
    входит, например, в известный Interrupt List by Ralf Brown;
    список вторых должен быть указан в документации по устройству.

======================================================================
================ Функция 63 - работа с доской отладки. ===============
======================================================================
Доска отладки представляет собой системный буфер (на 4096 байт),
в который любая программа может записать (вообще говоря, произвольные)
данные и из которого другая программа может эти данные прочитать.
Есть соглашение, в соответствии с которым записываемые данные -
текстовые строки, интерпретируемые как отладочные сообщения о ходе
выполнения программы. Ядро в определённых ситуациях также записывает
на доску отладки сведения о выполнении некоторых функций;
по соглашению сообщения ядра начинаются с префикса "K : ".
Для просмотра доски отладки создано приложение board,
которое считывает данные из буфера и отображает их в своём окне. board
понимает последовательность кодов 13,10 как переход на новую строку.
Символ с нулевым кодом в конце строки не обязателен, но и не мешает.
В связи с появлением отладчика ценность доски отладки несколько
снизилась, поскольку отладчик позволяет полностью контролировать ход
выполнения программы, причём для этого не требуется никаких усилий
со стороны самой программы. Тем не менее во многих случаях
доска отладки продолжает оставаться полезной.

---------------------------- Запись байта ----------------------------
Параметры:
  * eax = 63 - номер функции
  * ebx = 1 - номер подфункции
  * cl = байт данных
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Байт записывается в буфер. Длина буфера - 512 байт.
    При переполнении буфера все полученные данные теряются
    и заполнение начинается снова с нуля.
  * Для вывода на доску отладки более сложных объектов (строк, чисел)
    достаточно этой функции, вызываемой в цикле. Можно не писать
    вручную соответствующий код, а воспользоваться файлом debug.inc,
    входящим в дистрибутив.

---------------------------- Чтение байта ----------------------------
Забирает байт из буфера.
Параметры:
  * eax = 63 - номер функции
  * ebx = 2 - номер подфункции
Возвращаемое значение:
  * eax = ebx = 0 - буфер пуст
  * eax = байт, ebx = 1 - байт успешно прочитан

======================================================================
========== Функция 64 - перераспределить память приложения. ==========
======================================================================
Параметры:
  * eax = 64 - номер функции
  * ebx = 1 - единственная подфункция
  * ecx = новый размер памяти
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - недостаточно памяти
Замечания:
  * Есть другой способ выделения/освобождения динамической памяти -
    подфункции 11, 12, 13 функции 68.
  * Функция не может использоваться совместно с 68.11, 68.12, 68.13.
    Вызов функции будет игнорироваться, если приложение создаст
    локальную кучу вызовом 68.11.

======================================================================
========= Функция 65 - вывести изображение с палитрой в окно. ========
======================================================================
Параметры:
  * eax = 65 - номер функции
  * ebx = указатель на изображение
  * ecx = [размер по оси x]*65536 + [размер по оси y]
  * edx = [координата по оси x]*65536 + [координата по оси y]
  * esi = число бит на пиксель, должно быть 8, 24 или 32
  * edi = указатель на палитру (256 цветов 0x00RRGGBB);
          игнорируется при esi = 24 и 32
  * ebp = смещение данных каждой следующей строки изображения
          относительно предыдущей
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Координаты изображения - это координаты верхнего левого угла
    изображения относительно окна.
  * Размер изображения в байтах есть xsize*ysize.
  * Каждый байт изображения рассматривается как индекс в палитре.
  * Если изображение использует не все 256 цветов, а меньше,
    размер палитры может быть меньше 256.
  * Вызов функции 7 эквивалентен вызову этой функции с параметрами
    esi=24, ebp=0.

======================================================================
================= Функция 66 - работа с клавиатурой. =================
======================================================================
Режим ввода влияет на результаты чтения клавиш функцией 2.
При загрузке программы для неё устанавливается ASCII-режим ввода.

-------- Подфункция 1 - установить режим ввода с клавиатуры. ---------
Параметры:
  * eax = 66 - номер функции
  * ebx = 1 - номер подфункции
  * ecx = режим:
    * 0 = обычный (ASCII-символы)
    * 1 = сканкоды
Возвращаемое значение:
  * функция не возвращает значения

--------- Подфункция 2 - получить режим ввода с клавиатуры. ----------
Параметры:
  * eax = 66 - номер функции
  * ebx = 2 - номер подфункции
Возвращаемое значение:
  * eax = текущий режим

------- Подфункция 3 - получить состояние управляющих клавиш. --------
Параметры:
  * eax = 66 - номер функции
  * ebx = 3 - номер подфункции
Возвращаемое значение:
  * eax = битовая маска:
  * бит 0 (маска 1): левый Shift нажат
  * бит 1 (маска 2): правый Shift нажат
  * бит 2 (маска 4): левый Ctrl нажат
  * бит 3 (маска 8): правый Ctrl нажат
  * бит 4 (маска 0x10): левый Alt нажат
  * бит 5 (маска 0x20): правый Alt нажат
  * бит 6 (маска 0x40): CapsLock включён
  * бит 7 (маска 0x80): NumLock включён
  * бит 8 (маска 0x100): ScrollLock включён
  * прочие биты сброшены

----- Подфункция 4 - установить общесистемную "горячую клавишу". -----
О нажатии "горячей клавиши" извещаются только приложения,
установившие её; активное приложение (к которому поступает
весь нормальный ввод) таких клавиш не получает.
Извещение заключается в посылке события с кодом 2.
Прочитать "горячую клавишу" можно так же, как и обычную, -
функцией 2.
Параметры:
  * eax = 66 - номер функции
  * ebx = 4 - номер подфункции
  * cl задаёт сканкод клавиши;
    используйте cl=0 для задания комбинаций типа Ctrl+Shift
  * edx = 0xXYZ задаёт возможные состояния управляющих клавиш:
    * Z (младшие 4 бита) задаёт состояние клавиш LShift и RShift:
      * 0 = ни одна из клавиш не должна быть нажата;
      * 1 = ровно одна из клавиш должна быть нажата;
      * 2 = обе клавиши должны быть нажаты;
      * 3 = должна быть нажата LShift, но не RShift;
      * 4 = должна быть нажата RShift, но не LShift
    * Y - аналогично для LCtrl и RCtrl;
    * X - аналогично для LAlt и RAlt
Возвращаемое значение:
  * eax=0 - успешно
  * eax=1 - слишком много "горячих клавиш" (допускается максимум 256)
Замечания:
  * Горячая клавиша может срабатывать либо при нажатии,
    либо при отпускании. Сканкод отпускания клавиши на 128 больше,
    чем сканкод нажатия (т.е. установлен старший бит).
  * Несколько приложений могут установить одну и ту же комбинацию;
    о нажатии такой комбинации будут извещаться все такие приложения.

------ Подфункция 5 - удалить установленную "горячую клавишу". -------
Параметры:
  * eax = 66 - номер функции
  * ebx = 5 - номер подфункции
  * cl = сканкод клавиши и edx = 0xXYZ такие же, как и в подфункции 4
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - нет такой горячей клавиши
Замечания:
  * При завершении процесса/потока удаляются все установленные им
    горячие клавиши.
  * Вызов функции не влияет на другие приложения.
    Если другое приложение определило эту же комбинацию,
    оно по-прежнему будет получать уведомления.

======================================================================
============ Функция 67 - изменить положение/размеры окна. ===========
======================================================================
Параметры:
  * eax = 67 - номер функции
  * ebx = новая x-координата окна
  * ecx = новая y-координата окна
  * edx = новый x-размер окна
  * esi = новый y-размер окна
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Значение -1 для параметра означает "не изменять"; например, для
    перемещения окна без изменения размеров можно указать edx=esi=-1.
  * Предварительно окно должно быть определено функцией 0.
    Она же задаёт начальные координаты и размеры окна.
  * Размеры окна понимаются в смысле функции 0, т.е.
    на один пиксель меньше, чем реальные размеры.
  * Вызов функции для максимизированных окон просто игнорируется.
  * Для окон соответствующих стилей положение и/или размеры могут быть
    изменены пользователем; текущие положение и размеры могут быть
    получены вызовом функции 9.
  * Функция посылает окну событие перерисовки (с кодом 1).

======================================================================
=== Функция 68, подфункция 0 - получить счётчик переключений задач. ==
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 0 - номер подфункции
Возвращаемое значение:
  * eax = число переключений задач с момента загрузки системы
    (по модулю 2^32)

======================================================================
====================== Функция 68, подфункция 1 ======================
============ Переключиться на следующий поток выполнения. ============
======================================================================
Функция завершает текущий квант времени, выделенный потоку,
и переключается на следующий.
(Какой поток какого процесса будет следующим, предсказать нельзя).
Позднее, когда до текущего потока дойдёт очередь,
выполнение возобновится.
Параметры:
  * eax = 68 - номер функции
  * ebx = 1 - номер подфункции
Возвращаемое значение:
  * функция не возвращает значения

======================================================================
=============== Функция 68, подфункция 2 - кэш + rdpmc. ==============
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = требуемое действие:
    * ecx = 0 - разрешить выполнение инструкции rdpmc
      (ReaD Performance-Monitoring Counters)
    * ecx = 1 - узнать, включён/выключен кэш
    * ecx = 2 - включить кэш
    * ecx = 3 - выключить кэш
Возвращаемое значение:
  * для ecx=0:
    * eax = значение cr4
  * для ecx=1:
    * eax = (cr0 and 0x60000000):
    * eax = 0 - кэш включён
    * eax <> 0 - кэш выключен
  * для ecx=2 и ecx=3:
    * функция не возвращает значения

======================================================================
========== Функция 68, подфункция 3 - прочитать MSR-регистр. =========
======================================================================
MSR = Model Specific Register; полный список MSR-регистров процессора
содержится в документации по процессору (например, IA-32 Intel
Architecture Software Developer's Manual, Volume 3, Appendix B);
каждое семейство процессоров имеет своё подмножество MSR-регистров.
Параметры:
  * eax = 68 - номер функции
  * ebx = 3 - номер подфункции
  * ecx игнорируется
  * edx = адрес MSR
Возвращаемое значение:
  * ebx:eax = старший:младший dword результата
Замечания:
  * Указание в ecx несуществующего или нереализованного для данного
    процессора MSR повлечёт исключение в ядре, которое прибьёт поток.
  * Предварительно следует определить, поддерживаются ли MSR в целом,
    командой cpuid. Иначе возникнет уже другое исключение в ядре,
    которое всё равно прибьёт поток.

======================================================================
========= Функция 68, подфункция 4 - записать в MSR-регистр. =========
======================================================================
MSR = Model Specific Register; полный список MSR-регистров процессора
содержится в документации по процессору (например, IA-32 Intel
Architecture Software Developer's Manual, Volume 3, Appendix B);
каждое семейство процессоров имеет своё подмножество MSR-регистров.
Параметры:
  * eax = 68 - номер функции
  * ebx = 4 - номер подфункции
  * ecx игнорируется
  * edx = адрес MSR
  * esi:edi = старший:младший dword
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Указание в ecx несуществующего или нереализованного для данного
    процессора MSR повлечёт исключение в ядре, которое прибьёт поток.
  * Предварительно следует определить, поддерживаются ли MSR в целом,
    командой cpuid. Иначе возникнет уже другое исключение в ядре,
    которое всё равно прибьёт поток.

======================================================================
===== Функция 68, подфункция 11 - инициализировать кучу процесса. ====
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 11 - номер подфункции
Возвращаемое значение:
  * eax = 0 - неуспех
  * иначе размер созданной кучи
Замечания:
  * Вызов функции инициализирует кучу, из которой впоследствии можно
    выделять и освобождать блоки памяти подфункциями 12 и 13.
    Размер кучи равен размеру всей свободной памяти приложения.
  * При повторном вызове функции тем же процессом функция вернёт
    размер существующей кучи.
  * После создания кучи вызовы функции 64 игнорируются.

======================================================================
========== Функция 68, подфункция 12 - выделить блок памяти. =========
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 12 - номер подфункции
  * ecx = требуемый размер в байтах
Возвращаемое значение:
  * eax = указатель на выделенный блок
Замечания:
  * Предварительно следует инициализировать кучу процесса вызовом
    подфункции 11.
  * Функция выделяет целое число страниц (4 Кб) так, что фактический
    размер выделенного блока больше или равен запрошенному.

======================================================================
========= Функция 68, подфункция 13 - освободить блок памяти. ========
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 13 - номер подфункции
  * ecx = указатель на блок памяти
Возвращаемое значение:
  * eax = 1 - успешно
  * eax = 0 - неудача
Замечания:
  * Блок памяти должен быть ранее выделен подфункцией 12
    или подфункцией 20.

======================================================================
===== Функция 68, подфункция 14 - ожидать извещения от драйвера. =====
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 14 - номер подфункции
  * ecx = указатель на буфер для информации (8 байт)
Возвращаемое значение:
  * буфер, на который указывает ecx, содержит следующую информацию:
    * +0: dword: константа EV_INTR = 1
    * +4: dword: данные драйвера
Замечания:
  * Текущая реализация во время ожидания требует довольно "тяжёлых"
    операций переключения контекста.

======================================================================
== Функция 68, подфункция 15 - установить обработчик исключений FPU. =
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 15 - номер подфункции
  * ecx = адрес нового обработчика исключений
Возвращаемое значение:
  * eax = адрес старого обработчика исключений
    (0, если он не был установлен)

======================================================================
=========== Функция 68, подфункция 16 - загрузить драйвер. ===========
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 16 - номер подфункции
  * ecx = указатель на ASCIIZ-строку с именем драйвера
Возвращаемое значение:
  * eax = 0 - неудача
  * иначе eax = хэндл драйвера
Замечания:
  * Если драйвер ещё не загружен, он загружается;
    если драйвер уже загружен, ничего не меняется.
  * Имя драйвера чувствительно к регистру символов.
    Максимальная длина имени - 16 символов, включая завершающий
    нулевой символ, остальные символы игнорируются.
  * Драйвер с именем ABC загружается из файла /rd/1/drivers/ABC.obj.

======================================================================
========== Функция 68, подфункция 17 - управление драйвером. =========
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 17 - номер подфункции
  * ecx = указатель на управляющую структуру:
    * +0: dword: хэндл драйвера
    * +4: dword: код функции драйвера
    * +8: dword: указатель на входные данные
    * +12 = +0xC: dword: размер входных данных
    * +16 = +0x10: dword: указатель на выходные данные
    * +20 = +0x14: dword: размер выходных данных
Возвращаемое значение:
  * eax = определяется драйвером
Замечания:
  * Коды функций и структура входных/выходных данных
    определяются драйвером.
  * Предварительно должен быть получен хэндл драйвера подфункцией 16.

======================================================================
== Функция 68, подфункция 18 - установить обработчик исключений SSE. =
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 18 - номер подфункции
  * ecx = адрес нового обработчика исключений
Возвращаемое значение:
  * eax = адрес старого обработчика исключений
    (0, если он не был установлен)

======================================================================
============= Функция 68, подфункция 19 - загрузить DLL. =============
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 19 - номер подфункции
  * ecx = указатель на ASCIIZ-строку с полным путём к DLL
Возвращаемое значение:
  * eax = 0 - неудача
  * иначе eax = указатель на таблицу экспорта DLL
Замечания:
  * Таблица экспорта представляет собой массив структур по 2 dword'а,
    заканчивающийся нулём. Первый dword в структуре является
    указателем на имя функции, второй содержит адрес функции.

======================================================================
====== Функция 68, подфункция 20 - перераспределить блок памяти. =====
======================================================================
Параметры:
  * eax = 68 - номер функции
  * ebx = 20 - номер подфункции
  * ecx = новый размер в байтах
  * edx = указатель на уже выделенный блок памяти
Возвращаемое значение:
  * eax = указатель на перераспределённый блок, 0 при ошибке
Замечания:
  * Предварительно следует инициализировать кучу процесса вызовом
    подфункции 11.
  * Функция выделяет целое число страниц (4 Кб) так, что фактический
    размер выделенного блока больше или равен запрошенному.
  * Если edx=0, то вызов функции эквивалентен выделению памяти
    подфункцией 12. В противном случае блок памяти по адресу edx
    должен быть ранее выделен подфункцией 12 или
    описываемой подфункцией.
  * Если ecx=0, то функция освобождает блок памяти по адресу edx и
    возвращает 0.
  * Содержимое памяти вплоть до наименьшего из старого и нового
    размеров сохраняется.

======================================================================
======================== Функция 69 - отладка. =======================
======================================================================
Процесс может загрузить другой процесс как отлаживаемый установкой
соответствующего бита при вызове подфункции 7 функции 70.
У процесса может быть только один отладчик; один процесс может
отлаживать несколько разных. Система уведомляет отладчик о событиях,
происходящих с отлаживаемым процессом. Сообщения записываются в буфер,
определённый подфункцией 0.
Формат сообщения:
  * +0: dword: код сообщения
  * +4: dword: PID отлаживаемого процесса
  * +8: могут присутствовать дополнительные данные,
    определяемые кодом сообщения
Коды сообщений:
  * 1 = исключение
    * дополнительно передаётся dword-номер исключения
    * процесс приостановлен
  * 2 = процесс завершился
    * приходит при любом завершении: как через системную функцию -1,
      так и при "убийстве" любым другим процессом
      (в том числе самим отладчиком)
  * 3 = отладочное исключение int 1 = #DB
    * дополнительно передаётся dword-образ регистра DR6:
      * биты 0-3: выполнено условие соответствующей точки останова
        (установленной подфункцией 9)
      * бит 14: исключение произошло из-за режима
        пошаговой трассировки (установлен флаг TF)
    * процесс приостановлен
При завершении отладчика прибиваются все отлаживаемые процессы.
Если отладчик этого не хочет, он должен предварительно отключиться
подфункцией 3.

Все подфункции применимы только к процессам/потокам, запущенным
из текущего функцией 70 с установленным флагом отладки.
Отладка многопоточных программ пока не поддерживается.
Полный список подфункций:
  * подфункция 0 - определить область данных для отладочных сообщений
  * подфункция 1 - получить состояние регистров отлаживаемого потока
  * подфункция 2 - установить состояние регистров отлаживаемого потока
  * подфункция 3 - отключиться от отлаживаемого процесса
  * подфункция 4 - приостановить отлаживаемый поток
  * подфункция 5 - возобновить выполнение отлаживаемого потока
  * подфункция 6 - прочитать из памяти отлаживаемого процесса
  * подфункция 7 - записать в память отлаживаемого процесса
  * подфункция 8 - завершить отлаживаемый поток
  * подфункция 9 - установить/снять аппаратную точку останова

======================================================================
====================== Функция 69, подфункция 0 ======================
========= Определить область данных для отладочных сообщений. ========
======================================================================
Параметры:
  * eax = 69 - номер функции
  * ebx = 0 - номер подфункции
  * ecx = указатель
Формат области данных:
  * +0: dword: N = размер буфера (не считая этого заголовка)
  * +4: dword: занято в буфере
  * +8: N*byte: буфер
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Если поле размера отрицательно, буфер считается заблокированным
    и при поступлении нового сообщения система будет ждать.
    Для синхронизации обрамляйте всю работу с буфером операциями
    блокировки/разблокировки
    	neg	[bufsize]
  * Данные в буфере трактуются как массив элементов переменной длины -
    сообщений. Формат сообщения указан в общем описании.

======================================================================
====================== Функция 69, подфункция 1 ======================
========= Получить состояние регистров отлаживаемого потока. =========
======================================================================
Параметры:
  * eax = 69 - номер функции
  * ebx = 1 - номер подфункции
  * ecx = идентификатор потока
  * edx = длина структуры контекста, должно быть 0x28=40 байт
  * esi = указатель на структуру контекста
Возвращаемое значение:
  * функция не возвращает значения
Формат структуры контекста: (FPU пока не поддерживается)
  * +0: dword: eip
  * +4: dword: eflags
  * +8: dword: eax
  * +12 = +0xC: dword: ecx
  * +16 = +0x10: dword: edx
  * +20 = +0x14: dword: ebx
  * +24 = +0x18: dword: esp
  * +28 = +0x1C: dword: ebp
  * +32 = +0x20: dword: esi
  * +36 = +0x24: dword: edi
Замечания:
  * Если поток выполняет код 0-кольца, возвращается
    состояние регистров 3-кольца.
  * Процесс должен быть загружен для отладки (как указано в
    общем описании).

======================================================================
====================== Функция 69, подфункция 2 ======================
======== Установить состояние регистров отлаживаемого потока. ========
======================================================================
Параметры:
  * eax = 69 - номер функции
  * ebx = 2 - номер подфункции
  * ecx = идентификатор потока
  * edx = длина структуры контекста, должно быть 0x28=40 байт
  * esi = указатель на структуру контекста
Возвращаемое значение:
  * функция не возвращает значения
Формат структуры контекста указан в описании подфункции 1.
Замечания:
  * Если поток выполняет код 0-кольца, устанавливается
    состояние регистров 3-кольца.
  * Процесс должен быть загружен для отладки (как указано в
    общем описании).

======================================================================
== Функция 69, подфункция 3 - отключиться от отлаживаемого процесса. =
======================================================================
Параметры:
  * eax = 69 - номер функции
  * ebx = 3 - номер подфункции
  * ecx = идентификатор
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Если процесс был приостановлен, он возобновляет выполнение.

======================================================================
==== Функция 69, подфункция 4 - приостановить отлаживаемый поток. ====
======================================================================
Параметры:
  * eax = 69 - номер процесса
  * ebx = 4 - номер подфункции
  * ecx = идентификатор
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Процесс должен быть загружен для отладки (как указано в
    общем описании).

======================================================================
====================== Функция 69, подфункция 5 ======================
============ Возобновить выполнение отлаживаемого потока. ============
======================================================================
Параметры:
  * eax = 69 - номер функции
  * ebx = 5 - номер подфункции
  * ecx = идентификатор
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Процесс должен быть загружен для отладки (как указано в
    общем описании).

======================================================================
====================== Функция 69, подфункция 6 ======================
============= Прочитать из памяти отлаживаемого процесса. ============
======================================================================
Параметры:
  * eax = 69 - номер функции
  * ebx = 6 - номер подфункции
  * ecx = идентификатор
  * edx = сколько байт читать
  * esi = адрес памяти отлаживаемого процесса
  * edi = указатель на буфер для данных
Возвращаемое значение:
  * eax = -1 при ошибке (неверный PID или буфер)
  * иначе eax = число прочитанных байт (возможно, 0,
    если в esi слишком большое значение)
Замечания:
  * Процесс должен быть загружен для отладки (как указано в
    общем описании).

======================================================================
 Функция 69, подфункция 7 - записать в память отлаживаемого процесса.
======================================================================
Параметры:
  * eax = 69 - номер функции
  * ebx = 7 - номер подфункции
  * ecx = идентификатор
  * edx = сколько байт писать
  * esi = адрес памяти в отлаживаемом процессе
  * edi = указатель на данные
Возвращаемое значение:
  * eax = -1 при ошибке (неверный PID или буфер)
  * иначе eax = число записанных байт (возможно, 0,
    если в esi слишком большое значение)
Замечания:
  * Процесс должен быть загружен для отладки (как указано в
    общем описании).

======================================================================
====== Функция 69, подфункция 8 - завершить отлаживаемый поток. ======
======================================================================
Параметры:
  * eax = 69 - номер функции
  * ebx = 8 - номер подфункции
  * ecx = идентификатор
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Процесс должен быть загружен для отладки (как указано в
    общем описании).
  * Функция аналогична подфункции 2 функции 18 с двумя отличиями:
    требуется выполнение первого замечания и принимается PID,
    а не номер слота.

======================================================================
====================== Функция 69, подфункция 9 ======================
============= Установить/снять аппаратную точку останова. ============
======================================================================
Параметры:
  * eax = 69 - номер функции
  * ebx = 9 - номер подфункции
  * ecx = идентификатор потока
  * dl = индекс точки останова, от 0 до 3 включительно
  * dh = флаги:
    * если старший бит сброшен - установить точку останова:
      * биты 0-1 - условие:
        * 00 = точка останова на выполнение
        * 01 = точка останова на запись
        * 11 = точка останова на чтение/запись
      * биты 2-3 - длина; для точек останова на исполнение должно быть
        00, в противном случае одно из
        * 00 = байт
        * 01 = слово
        * 11 = двойное слово
      * esi = адрес точки останова; должен быть выровнен
        соответственно длине (т.е. должен быть чётным для
        точек останова на слово, кратен 4 для двойного слова)
    * если старший бит установлен - сбросить точку останова
Возвращаемое значение:
  * eax = 0 - успешно
  * eax = 1 - ошибка во входных данных
  * eax = 2 - (зарезервировано, никогда не возвращается
    в текущей реализации) с этим индексом уже установлена
    глобальная точка останова
Замечания:
  * Процесс должен быть загружен для отладки (как указано в
    общем описании).
  * Аппаратные точки останова реализуются через DRx-регистры
    процессора, отсюда все ограничения.
  * Функция может переустановить ранее установленную ей же
    точку останова (никак не сообщая об этом).
    Ведите список установленных точек останова в отладчике.
  * Срабатывание точки останова заключается в генерировании
    отладочного исключения #DB, о котором система сообщает отладчику.
  * Точка останова на запись и чтение/запись срабатывает после
    выполнения вызвавшей её инструкции.

======================================================================
= Функция 70 - работа с файловой системой с поддержкой длинных имён. =
======================================================================
Параметры:
  * eax = 70
  * ebx = указатель на информационную структуру
Возвращаемое значение:
  * eax = 0 - успешно; иначе код ошибки файловой системы
  * в зависимости от подфункции может возвращаться значение и
    в других регистрах
Общий формат информационной структуры:
  * +0: dword: номер подфункции
  * +4: dword: смещение в файле
  * +8: dword: старший dword смещения (должен быть 0) или поле флагов
  * +12 = +0xC: dword: размер
  * +16 = +0x10: dword: указатель на данные
  * +20 = +0x14: n db: ASCIIZ-строка с именем файла
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем файла
Уточнения - в документации на соответствующую подфункцию.
Имя файла нечувствительно к регистру букв. Русские буквы должны быть
записаны в кодировке cp866 (DOS).
Формат имени файла:
/base/number/dir1/dir2/.../dirn/file,
где /base/number идентифицирует устройство, на котором ищется файл:
одно из
  * /RD/1 = /RAMDISK/1 для доступа к рамдиску
  * /FD/1 = /FLOPPYDISK/1 для доступа к первому флоппи-дисководу,
    /FD/2 = /FLOPPYDISK/2 для второго флоппи-дисковода
  * /HD0/x, /HD1/x, /HD2/x, /HD3/x для доступа соответственно
    к жёстким дискам на IDE0 (Primary Master), IDE1 (Primary Slave),
    IDE2 (Secondary Master), IDE3 (Secondary Slave);
    x - номер раздела на выбранном винчестере, изменяется от 1 до 255
    (на каждом из винчестеров нумерация начинается с 1)
  * /CD0/1, /CD1/1, /CD2/1, /CD3/1 для доступа соответственно
    к CD на IDE0 (Primary Master), IDE1 (Primary Slave),
    IDE2 (Secondary Master), IDE3 (Secondary Slave)
  * /SYS - определяет системную папку; при обычной загрузке системы
    с дискеты эквивалентно /RD/1
Примеры:
  * '/rd/1/kernel.asm',0
  * '/HD0/1/kernel.asm',0
  * '/hd0/2/menuet/pics/tanzania.bmp',0
  * '/hd0/1/Program files/NameOfProgram/SomeFile.SomeExtension',0
  * '/sys/MySuperApp.ini',0
Доступные подфункции:
  * подфункция 0 - чтение файла
  * подфункция 1 - чтение папки
  * подфункция 2 - создание/перезапись файла
  * подфункция 3 - запись в существующий файл
  * подфункция 4 - установка размера файла
  * подфункция 5 - получение атрибутов файла/папки
  * подфункция 6 - установка атрибутов файла/папки
  * подфункция 7 - запуск программы
  * подфункция 8 - удаление файла/папки
  * подфункция 9 - создание папки
Для CD-приводов в связи с аппаратными ограничениями доступны
только подфункции 0,1,5 и 7, вызов других подфункций завершится
ошибкой с кодом 2.
При первом обращении подфункций 0,1,5,7 к устройствам ATAPI (CD и DVD)
производится блокировка ручного управления механизмом лотка. Это связано
с алгоритмом кэширования данных полученных от привода. Разблокировка
производится обращением подфункцией 10 к соответствующему устройству.

======================================================================
= Функция 70, подфункция 0 - чтение файла с поддержкой длинных имён. =
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 0 = номер подфункции
  * +4: dword: позиция в файле (в байтах)
  * +8: dword: 0 (зарезервировано под старший dword позиции)
  * +12 = +0xC: dword: сколько байт читать
  * +16 = +0x10: dword: указатель на буфер, куда будут записаны данные
  * +20 = +0x14: ASCIIZ-имя файла, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем файла
Возвращаемое значение:
  * eax = 0 - успешно, иначе код ошибки файловой системы
  * ebx = число прочитанных байт или
    -1=0xffffffff, если файл не найден
Замечания:
  * Если файл кончился раньше, чем был прочитан последний запрошенный
    блок, то функция прочитает, сколько сможет, после чего вернёт
    eax=6 (EOF).
  * Функция не позволяет читать папки
    (вернётся eax=10, access denied).

======================================================================
= Функция 70, подфункция 1 - чтение папки с поддержкой длинных имён. =
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 1 = номер подфункции
  * +4: dword: индекс начального блока (считая с 0)
  * +8: dword: поле флагов:
    * бит 0 (маска 1): в каком формате возвращать имена,
      0=ANSI, 1=UNICODE
    * прочие биты зарезервированы и должны быть установлены в 0
      для будущей совместимости
  * +12 = +0xC: dword: сколько блоков читать
  * +16 = +0x10: dword: указатель на буфер, куда будут записаны
    данные, размер буфера должен быть не меньше 32 + [+12]*560 байт
  * +20 = +0x14: ASCIIZ-имя папки, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем файла
Возвращаемое значение:
  * eax = 0 - успешно, иначе код ошибки файловой системы
  * ebx = число файлов, информация о которых была записана в буфер,
    или -1=0xffffffff, если папка не найдена
Структура буфера:
  * +0: 32*byte: заголовок
  * +32 = +0x20: n1*byte: блок с информацией о файле 1
  * +32+n1: n2*byte: блок с информацией о файле 2
  * ...
Структура заголовка:
  * +0: dword: версия структуры (текущая версия = 1)
  * +4: dword: количество размещённых блоков; не больше, чем запрошено
    в поле +12 информационной структуры; может быть меньше,
    если в папке кончились файлы (то же самое, что и в ebx)
  * +8: dword: общее число файлов в папке
  * +12 = +0xC: 20*byte: зарезервировано (нули)
Структура блока данных входа каталога (БДВК):
  * +0: dword: атрибуты файла:
    * бит 0 (маска 1): файл только для чтения
    * бит 1 (маска 2): файл является скрытым
    * бит 2 (маска 4): файл является системным
    * бит 3 (маска 8): это не файл, а метка тома
      (на заданном разделе встречается не более одного раза и
      только в корневой папке)
    * бит 4 (маска 0x10): это папка
    * бит 5 (маска 0x20): файл не архивировался - многие программы
      архивации имеют опцию, по которой архивируются только файлы
      с установленным этим битом, после чего этот бит сбрасывается -
      это может быть полезно для автоматического создания
      backup-архивов, ибо при записи бит обычно устанавливается
      (не в Kolibri, правда)
  * +4: byte: тип данных имени:
    (совпадает с битом 0 флагов информационной структуры)
    * 0 = ASCII = 1-байтное представление каждого символа
    * 1 = UNICODE = 2-байтное представление каждого символа
  * +5: 3*byte: зарезервировано (нули)
  * +8: 4*byte: время создания файла
  * +12 = +0xC: 4*byte: дата создания файла
  * +16 = +0x10: 4*byte: время последнего доступа (чтение или запись)
  * +20 = +0x14: 4*byte: дата последнего доступа
  * +24 = +0x18: 4*byte: время последней модификации
  * +28 = +0x1C: 4*byte: дата последней модификации
  * +32 = +0x20: qword: размер файла в байтах (до 16777216 Тб)
  * +40 = +0x28: имя
    * для формата ASCII: максимальная длина имени 263 символа
      (263 байта), байт после имени имеет значение 0
    * для формата UNICODE: максимальная длина имени 259 символов
      (518 байт), два байта после имени имеют значение 0
Формат времени:
  * +0: byte: секунды
  * +1: byte: минуты
  * +2: byte: часы
  * +3: byte: зарезервировано (0)
  * например, 23.59.59 записывается как (в hex) 3B 3B 17 00
Формат даты:
  * +0: byte: день
  * +1: byte: месяц
  * +2: word: год
  * например, 25.11.1979 записывается как (в hex) 19 0B BB 07
Замечания:
  * Если в БДВК присутствует имя в ASCII, то длина БДВК составляет
    304 байта, если в UNICODE - 560 байт. Значение длины выравнено
    на целое кратное 16 байт
    (для ускорения обработки в кэш-памяти CPU).
  * Первый символ после имени нулевой (ASCIIZ-строка). Дальнейшие
    данные содержат мусор.
  * Если файлы в папке кончились раньше, чем было прочитано
    запрошенное количество, то функция прочитает, сколько сможет,
    после чего вернёт eax=6 (EOF).
  * Любая папка на диске, кроме корневой, содержит два специальных
    входа "." и "..", идентифицирующих соответственно саму папку и
    родительскую папку.
  * Функция позволяет также читать виртуальные папки "/", "/rd",
    "/fd", "/hd[n]", при этом атрибуты подпапок полагаются равными
    0x10, а времена и даты обнулены. Альтернативный способ получения
    информации об оборудовании - подфункция 11 функции 18.

======================================================================
====================== Функция 70, подфункция 2 ======================
======== Создание/перезапись файла с поддержкой длинных имён. ========
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 2 = номер подфункции
  * +4: dword: 0 (зарезервировано)
  * +8: dword: 0 (зарезервировано)
  * +12 = +0xC: dword: сколько байт писать
  * +16 = +0x10: dword: указатель на данные
  * +20 = +0x14: ASCIIZ-имя файла, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем файла
Возвращаемое значение:
  * eax = 0 - успешно, иначе код ошибки файловой системы
  * ebx = число записанных байт (возможно, 0)
Замечания:
  * Если файл с таким именем не существовал, он создаётся; если
    существовал, то перезаписывается.
  * Если свободного места на диске недостаточно, то функция запишет,
    сколько сможет, после чего вернёт код ошибки 8.
  * Функция не поддерживается для CD (вернётся код ошибки 2).

======================================================================
====================== Функция 70, подфункция 3 ======================
======== Запись в существующий файл с поддержкой длинных имён. =======
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 3 = номер подфункции
  * +4: dword: позиция в файле (в байтах)
  * +8: dword: старший dword позиции (должен быть 0 для FAT)
  * +12 = +0xC: dword: сколько байт писать
  * +16 = +0x10: dword: указатель на данные
  * +20 = +0x14: ASCIIZ-имя файла, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем файла
Возвращаемое значение:
  * eax = 0 - успешно, иначе код ошибки файловой системы
  * ebx = число записанных байт (возможно, 0)
Замечания:
  * Файл должен уже существовать, иначе вернётся eax=5.
  * Единственным результатом записи 0 байт является установка в
    атрибутах файла даты/времени модификации и доступа в текущую.
  * Если начальная и/или конечная позиция выходит за пределы файла
    (за исключением предыдущего случая), файл расширяется до
    необходимого размера нулевыми символами.
  * Функция не поддерживается для CD (вернётся код ошибки 2).

======================================================================
========= Функция 70, подфункция 4 - установка размера файла. ========
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 4 = номер подфункции
  * +4: dword: младший dword нового размера файла
  * +8: dword: старший dword нового размера файла
                   (должен быть 0 для FAT)
  * +12 = +0xC: dword: 0 (зарезервировано)
  * +16 = +0x10: dword: 0 (зарезервировано)
  * +20 = +0x14: ASCIIZ-имя файла, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем файла
Возвращаемое значение:
  * eax = 0 - успешно, иначе код ошибки файловой системы
  * ebx разрушается
Замечания:
  * Если новый размер файла меньше старого, файл усекается. Если
    новый размер больше старого, файл расширяется нулевыми символами.
    Если новый размер равен старому, единственным результатом вызова
    является установка даты/времени модификации и доступа в текущие.
  * Если свободного места на диске недостаточно для расширения файла,
    то функция расширит насколько возможно, после чего вернёт
    код ошибки 8.
  * Функция не поддерживается для CD (вернётся код ошибки 2).

======================================================================
=== Функция 70, подфункция 5 - получение информации о файле/папке. ===
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 5 = номер подфункции
  * +4: dword: 0 (зарезервировано)
  * +8: dword: 0 (зарезервировано)
  * +12 = +0xC: dword: 0 (зарезервировано)
  * +16 = +0x10: dword: указатель на буфер, куда будут записаны данные
                        (40 байт)
  * +20 = +0x14: ASCIIZ-имя файла, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем файла
Возвращаемое значение:
  * eax = 0 - успешно, иначе код ошибки файловой системы
  * ebx разрушается
Информация о файле возвращается в формате БДВК
(блока данных входа каталога), указанном в описании
подфункции 1, но без имени файла
(то есть первые 40 = 0x28 байт).
Замечания:
  * Функция не поддерживает виртуальные папки типа /, /rd и
    корневые папки типа /rd/1.

======================================================================
===== Функция 70, подфункция 6 - установка атрибутов файла/папки. ====
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 6 = номер подфункции
  * +4: dword: 0 (зарезервировано)
  * +8: dword: 0 (зарезервировано)
  * +12 = +0xC: dword: 0 (зарезервировано)
  * +16 = +0x10: dword: указатель на буфер с атрибутами (32 байта)
  * +20 = +0x14: ASCIIZ-имя файла, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем файла
Возвращаемое значение:
  * eax = 0 - успешно, иначе код ошибки файловой системы
  * ebx разрушается
Атрибуты файла - первые 32 байта в БДВК (блоке данных входа каталога),
формат которого указан в описании подфункции 1
(то есть без имени и размера файла). Атрибут файл/папка/метка тома
(биты 3,4 в dword'е +0) не меняется.
Байт +4 (формат имени) игнорируется.
Замечания:
  * Функция не поддерживает виртуальные папки типа /, /rd и
    корневые папки типа /rd/1.
  * Функция не поддерживается для CD (вернётся код ошибки 2).

======================================================================
============ Функция 70, подфункция 7 - запуск программы. ============
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 7 = номер подфункции
  * +4: dword: поле флагов:
    * бит 0: запустить процесс как отлаживаемый
    * остальные биты зарезервированы и должны быть установлены в 0
  * +8: dword: 0 или указатель на ASCIIZ-строку с параметрами
  * +12 = +0xC: dword: 0 (зарезервировано)
  * +16 = +0x10: dword: 0 (зарезервировано)
  * +20 = +0x14: ASCIIZ-имя файла, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем файла
Возвращаемое значение:
  * eax > 0 - программа загружена, eax содержит PID
  * eax < 0 - произошла ошибка, -eax содержит
    код ошибки файловой системы
  * ebx разрушается
Замечания:
  * Командная строка должна заканчиваться символом с кодом 0
    (ASCIIZ-строка); учитываются либо все символы до завершающего нуля
    включительно, либо первые 256 символов, в зависимости от того,
    что меньше.
  * Если процесс запускается как отлаживаемый, он создаётся
    в замороженном состоянии; для запуска используйте
    подфункцию 5 функции 69.

======================================================================
========== Функция 70, подфункция 8 - удаление файла/папки. ==========
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 8 = номер подфункции
  * +4: dword: 0 (зарезервировано)
  * +8: dword: 0 (зарезервировано)
  * +12 = +0xC: dword: 0 (зарезервировано)
  * +16 = +0x10: dword: 0 (зарезервировано)
  * +20 = +0x14: ASCIIZ-имя файла, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем файла
Возвращаемое значение:
  * eax = 0 - успешно, иначе код ошибки файловой системы
  * ebx разрушается
Замечания:
  * Функция не поддерживается для CD (вернётся код ошибки 2).
  * Можно удалять только пустые папки (попытка удаления непустой папки
    приведёт к ошибке с кодом 10, "доступ запрещён").

======================================================================
============= Функция 70, подфункция 9 - создание папки. =============
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 9 = номер подфункции
  * +4: dword: 0 (зарезервировано)
  * +8: dword: 0 (зарезервировано)
  * +12 = +0xC: dword: 0 (зарезервировано)
  * +16 = +0x10: dword: 0 (зарезервировано)
  * +20 = +0x14: ASCIIZ-имя папки, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем папки
Возвращаемое значение:
  * eax = 0 - успешно, иначе код ошибки файловой системы
  * ebx разрушается
Замечания:
  * Функция не поддерживается для CD (вернётся код ошибки 2).
  * Родительская папка должна уже существовать.
  * Если папка уже существует, функция завершится успешно (eax=0).

======================================================================
========== Функция 70, подфункция 10 - извлечь лоток привода диска. ============
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 10 = номер подфункции
  * +4: dword: 0 (зарезервировано)
  * +8: dword: 0 (зарезервировано)
  * +12 = +0xC: dword: 0 (зарезервировано)
  * +16 = +0x10: dword: 0 (зарезервировано)
  * +20 = +0x14: ASCIIZ-имя папки, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем папки
Возвращаемое значение:
    * Ничего не возвращается.
Замечания:
  * Функция поддерживается только для ATAPI устройств (CD и DVD).
  * При извлечении лотка производится разблокировка ручного управления механизмом лотка.
  * При извлечении лотка код производит очистку кэша соответствующего устройства.
  * Путь вводится в стандартном для 70 функции виде. Для работоспособности можно
     ограничиться путями вида:
     db '/cd0/1/',0
     db '/cd1/1/',0
     db '/cd2/1/',0
     db '/cd3/1/',0
  * Примером использования функции является приложение CD_tray.

======================================================================
========== Функция 70, подфункция 11 - загрузить лоток привода диска. ===========
======================================================================
Параметры:
  * eax = 70 - номер функции
  * ebx = указатель на информационную структуру
Формат информационной структуры:
  * +0: dword: 11 = номер подфункции
  * +4: dword: 0 (зарезервировано)
  * +8: dword: 0 (зарезервировано)
  * +12 = +0xC: dword: 0 (зарезервировано)
  * +16 = +0x10: dword: 0 (зарезервировано)
  * +20 = +0x14: ASCIIZ-имя папки, правила формирования имён указаны в
    общем описании
    или
  * +20 = +0x14: db 0
  * +21 = +0x15: dd указатель на ASCIIZ-строку с именем папки
Возвращаемое значение:
    * Ничего не возвращается.
Замечания:
  * Функция поддерживается только для ATAPI устройств (CD и DVD)
  * Путь вводится в стандартном для 70 функции виде. Для работоспособности можно
     ограничиться путями вида:
     db '/cd0/1/',0
     db '/cd1/1/',0
     db '/cd2/1/',0
     db '/cd3/1/',0
  * Примером использования функции является приложение CD_tray.

======================================================================
=== Функция 71, подфункция 1 - установить заголовок окна программы. ==
======================================================================
Параметры:
  * eax = 71 - номер функции
  * ebx = 1 - номер подфункции
  * ecx = адрес строки заголовка
Возвращаемое значение:
  * функция не возвращает значения
Замечания:
  * Строка заголовка должна быть в формате ASCIIZ. В заголовке
    отображается не более 255 символов независимо от полной длины
    строки.
  * Чтобы убрать заголовок, передайте NULL в ecx.

======================================================================
========== Функция -1 - завершить выполнение потока/процесса =========
======================================================================
Параметры:
  * eax = -1 - номер функции
Возвращаемое значение:
  * функция не возвращает ни значения, ни управления
Замечания:
  * Если процесс явно не создавал потоков, то у него есть только
    один поток, завершение которого приводит к завершению процесса.
  * Если текущий поток - последний в процессе, то его завершение
    также приводит к завершению процесса.
  * Эта функция завершает текущий поток. Другой поток можно прибить
    вызовом подфункции 2 функции 18.

======================================================================
=========================== Список событий ===========================
======================================================================
Очередное событие можно получить вызовом одной из функций 10
(ожидать события), 11 (проверить без ожидания), 23
(ожидать в течение заданного времени).
Эти функции возвращают только те события, которые входят в маску,
устанавливаемую функцией 40. По умолчанию это первые три, чего
вполне достаточно для многих приложений.
Коды событий:
  * 1 = сообщение о перерисовке (сбрасывается при вызове функции 0)
  * 2 = нажата клавиша на клавиатуре (поступает, только когда окно
    активно) или нажата "горячая клавиша";
    сбрасывается, когда все клавиши из буфера считаны функцией 2
  * 3 = нажата кнопка, определённая ранее функцией 8 (или кнопка
    закрытия, созданная неявно функцией 0; кнопка минимизации
    обрабатывается системой и о ней сообщения не приходит;
    поступает, только когда окно активно; сбрасывается, когда все
    кнопки из буфера считаны функцией 17)
  * 4 = зарезервировано (в текущей реализации никогда не приходит даже
    при размаскировке функцией 40)
  * 5 = перерисовывается фон рабочего стола (сбрасывается
    автоматически после перерисовки, так что если во время перерисовки
    фона программа не ждёт и не проверяет события, то этого события
    она не заметит)
  * 6 = событие от мыши (что-то случилось - нажатие на кнопку мыши
    или перемещение; сбрасывается при прочтении)
  * 7 = произошло событие IPC (смотри функцию 60 - Inter Process
    Communication; сбрасывается при прочтении)
  * 8 = произошло сетевое событие (сбрасывается при прочтении;
    смотри работу с сетью)
  * 9 = произошло отладочное событие (сбрасывается при прочтении;
    смотри отладочную подсистему)
  * 16..31 = произошло событие с соответствующим IRQ
    (16=IRQ0, 31=IRQ15) (сбрасывается при считывании всех данных IRQ)

======================================================================
==================== Коды ошибок файловой системы ====================
======================================================================
  * 0 = успешно
  * 1 = не определена база и/или раздел жёсткого диска (подфункциями
    7, 8 функции 21)
  * 2 = функция не поддерживается для данной файловой системы
  * 3 = неизвестная файловая система
  * 4 = зарезервировано, никогда не возвращается в текущей реализации
  * 5 = файл не найден
  * 6 = файл закончился
  * 7 = указатель вне памяти приложения
  * 8 = диск заполнен
  * 9 = таблица FAT разрушена
  * 10 = доступ запрещён
  * 11 = ошибка устройства
При запуске программы возможны также следующие коды ошибок:
  * 30 = 0x1E = недостаточно памяти
  * 31 = 0x1F = файл не является исполнимым
  * 32 = 0x20 = слишком много процессов
