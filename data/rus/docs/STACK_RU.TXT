 Что осуществлено
==================

Следующие особенности присутствуют в коде TCP/IP стека:


  Уровень IP.
  ICMP.
  Уровень TCP.
  Уровень UDP.
  Локальный возврат цикла.
  Realtek 8029 интерфейсов сети стандарта Ethernet PCI.
  Realtek 8139 интерфейсов сети стандарта Ethernet PCI.
  Intel i8255x PCI интерфейс сети стандарта Ethernet.
  Динамическая таблица протокола определения адресов.
  Point-to-point протокол(PPP)

И следующие Интернет программы:

  HTTP сервер
  POP клиент
  Telnet
  DNS Name resolver
  Mp3 сервер
  TFTP клиент
  IRC клиент
  FTP клиент
  PPP - звонилка

Есть ряд экспериментальных приложений для проигрывания потоковой музыки и
выполнения взаимодействия процессов через сокеты. Также есть простенький
браузер, позволяющий лазить по всемирной паутине(WWW).


Что не осуществлено
===================

Уровень IP не обрабатывает опции заголовка.
Уровень IP не поддерживает маршрутизацию.
Фрагментация пакета не поддерживается.


Конфигурация PPP в Колибри
===========================

Смотрите ppp.txt(или ppp_rus.txt с русским переводом)


Как сконфигурировать Колибри для локальной сети
==============================================

Для начала у вас должна быть сетевая карта стандарта Ethernet или, если её нет,
встроенную в вашу системную плату. Если вы, не знаете, есть ли у вас сетевая
карта, то пробуйте сконфигурировать стек. Если она есть и поддерживается, то
сможете использовать её.

Установка таблицы протокола определения адресов
-----------------------------------------------

Таблица протокола определения адресов в Колибри уже динамически создана и
сконфигурированна. Вы можете посмотреть, с какими компьютерами Колибри работает,
выполнив приложение ARPSTAT.

Подключение к локальной сети
---------------------------

Загрузите Колибри, затем выберите STACKCFG(конфигурация стека) в меню NET(сеть).

Нажмите Кнопку 'Чтения', затем выберите 'Драйвер Пакета'.
Нажмите "Change"(выбор) рядом с адресом IP, и введите нужный IP, который вы
хотите использовать. Удостоверьтесь, что он находится в той же самой подсети,
что и сама локальная сеть, к которой вы подключены. Нажмите "Apply"(применить)
для подтверждения изменений.
Закройте программу.

Стек сконфигурирован и запущен. Вы можете проверить его работу, пропинговав
Колибри с удаленного компьютера.

Самый простой способ подключить два PC вместе - это использовать нулевое
модемное соединение. Это обычное соединение компьютеров посредством кабеля. Они
могут быть куплены вместе с памятью или просто сделаны. Подробности можно найти
в Интернете. Ищите на поисковиках, (например www.gogle.ru) введя в строку
поиска: 'организация соединения компьютеров с помощью кабеля' или подобные.

Как использовать TCP/IP без подключения к сети
=============================================

Колибри поддерживает форму локального возврата цикла, а это значит, что
приложения на одном и том же самом PC могут общаться друг с другом через
сокеты, как если бы они находились на удалённых компьютерах. Чтобы соединяться
с приложением на локальной машине, определите локальный адрес IP как адрес
назначения. Вы даже не должны конфигурировать стек для сети стандарта Ethernet,
локальный возврат цикла будет работать без любых сетевых, аппаратных средств.
Хорошо подходит для проверки и отладки сетевых приложений.

Прикладной программный интерфейс
================================

Разработчик может обратиться к стеку через прерывание 0x40, функции 53. Файл
TFTPC.ASM - хороший пример того, как можно использовать программный интерфейс
(по крайней мере, для UDP), но как сетевая коммуникация, довольно сложен. Я дам
краткий обзор.

Сокеты
=======

Приложения соединяются друг с другом и передают информацию между собой через
механизм, названный 'сокетом'. Сокеты - оконечные точки для коммуникации. Для
каждого нужного сетевого приложения должен быть открыт хотя бы один сокет.

Использование сокетов немного походит на использования файлов в ОС. Вы
открываете, читаете и пишете в них, затем закрываете. Единственная вещь,
которая делает жизнь немного более сложной - это то, что в отличие от работы с
файлами, у вас появится трудности с работой сокетов (например, не захочет
закрываться)

Познакомимся с терминологией прежде, чем мы пойдём дальше.

*Сокет                Уникальный идентификатор, используемый приложением для
коммуникации.

*Локальный порт       Число, которое идентифицирует нужное приложение на
локальном компьютере. Порты - способ, позволяющих множествам приложений
общаться с другими компьютерами, благодаря чему нет путаницы в передаваемых
данных (Техническое определение 'мультиплексные'). Число порта - 16 бит.

*Удалённый порт       Число, которое идентифицирует приложение на удалённом
компьютере, к которому мы обращаемся. На удалённом компьютере - это 'локальный
порт'. Число порта - 16 бит.

*Адрес IP             Это 32 битное число, которое идентифицирует удалённый PC,
с которым мы общаемся.

*Пассивный режим      Это режим, в котором сокет открыт, а локальный PC ждёт
соединения.

*Активный режим       Это режим, в котором сокет открыт, а локальный PC пытается
соединиться с удалённым PC.

Соединяясь с сокетом на удаленном PC, вы должны не только определить IP адрес,
но и полностью квалифицировать его, т.е. определить IP адрес и число порта.
Иначе стек на удалённом PC не будет знать, какому приложению предназначаются
посланные данные. Вот небольшой пример:

192.168.1.10:80     ;Мы присоединяемся к компьютеру с IP адресом 192.168.1.10 к
80 порту.

Числа порта являются важными. Некоторые 'известны' и обеспечивают доступ к
общим приложениям. Например, порт 80 используется серверами гипертекстового
транспортного протокола(HTTP). Таким путём я могу соединиться с вебсервером на
нужном компьютере без необходимости узнавать прослушиваемый приложением номер
порта.

Как вы знаете, есть два режима: Пассивный и Активный. Вебсервер открыл
пассивный сокет, поскольку он ждет входящих запросов на подключение.
Web-броузер открыл активный сокет, потому что он пытается соединиться с
указанным удалённым компьютером.

Доступ к программированию интерфейса
====================================
Разработчик обращается к функциям стека через прерывание 0x40, функции 53. К
некоторым функциям можно обратиться через функцию 52, но они главным образом
предназначены для конфигурации стека.
Вот функций, которые вы можете использовать:

Получаем локальный IP адрес
---------------------------
eax = 52
ebx = 1

IP адрес возвратился в eax (в виде байтов, из которых состоит Интернет адрес)

Запись для расположения в стеке входной очереди
-----------------------------------------------
eax = 52
ebx = 6
edx = число байтов для записи
esi = указатель на данные (в прикладном пространстве)

По возвращению, в eax содержится 0, если OK, или 0xFFFFFFFF, если ошибка.
Этот интерфейс - только для медленных сетевых драйверов (PPP, SLIP)

Чтение данных из сетевой очереди вывода
---------------------------------------
eax = 52
ebx = 8
esi = указатель на данные (в прикладном пространстве)

По возвращению, eax считает число байтов переданным.
Этот интерфейс -  только для медленных сетевых драйверов (PPP, SLIP)

Открываем UDP сокет
-------------------
eax = 53
ebx = 0
ecx = локальный порт
edx = удаленный порт
esi = удаленный ip адрес (в виде байтов, из которых состоит Интернет адрес)

Номер сокета возвращён в eax.
Возвращаемое значение 0xFFFFFFFF означает, что сокеты не открылись.

Открываем TCP сокет
-------------------
eax = 53
ebx = 5
ecx = локальный порт
edx = удаленный порт
esi = удаленный ip адрес (в виде байтов, из которых состоит Интернет адрес)
edi = режим: SOCKET_PASSIVE или SOCKET_ACTIVE (определён в stack.inc)

Номер сокета возвращается в eax.
Возвращаемое значение 0xFFFFFFFF означает, что сокеты не открылись.

Закрытие сокета (Только UDP)
----------------------------
eax = 53
ebx = 1
ecx = номер сокета

По возвращению, в eax содержится 0, если OK, или 0xFFFFFFFF, если ошибка.

Закрытие сокета (Только TCP)
----------------------------
eax = 53
ebx = 8
ecx = число сокета

По возвращению, в eax содержится 0, если OK, или 0xFFFFFFFF, если ошибка.

Опрос сокета
-------------
eax = 53
ebx = 2
ecx = номер сокета

По возвращению, eax сохраняет число байтов в возвращённом буфере.

Чтение данных с сокета
----------------------
eax = 53
ebx = 3
ecx = число сокета

По возвращению, eax содержит число сохранённых байт, bl содержит байт данных.

Запись в сокет (Только UDP)
---------------------------
eax = 53
ebx = 4
ecx = число сокета
edx = число байтов для записи
esi = указатель на данные (в прикладном пространстве)

По возвращению, в eax содержится 0, если OK, или 0xFFFFFFFF, если ошибка.

Возвращение состояния сокета (Только TCP)
-----------------------------------------
eax = 53
ebx = 6
ecx = номер сокета

По возвращению, в eax содержится состояние TCP сокетов.

Эта функция может использоваться, чтобы определить, когда сокет фактически
соединился с другим сокетом. Вообще, данные не могут быть записаны в сокет,
пока подключение не установлено (TCB_ESTABLISHED). Состояния сокетов определены
в файле stack.inc, как TCB_

Запись в сокет (Только TCP)
---------------------------
eax = 53
ebx = 7
ecx = номер сокета
edx = число байт, нужных для записи
esi = указатель на данные (в прикладном пространстве)

По возвращению, в eax содержится 0, если OK, или 0xFFFFFFFF, если ошибка.

Проверка номера порта
---------------------
eax = 53
ebx = 9
ecx = номер порта

Эта функция используется, чтобы определить, используется ли номер порта какими
- либо сокетами. Локальный номер порта обычно уникален.

По возвращению, eax = - 1 для номера порта, который используется, иначе
возвращается 0.


Открытие TCP сокета в Колибри
=============================

Есть два способа открытия сокета - Пассивный или Активный.

При Пассивном подключении, приложение 'слушает' входящие запросы от удаленных
приложений. Обычно вы это делаете, осуществляя операцию клиент - сервер. Она
позволяет любому другому приложению соединяться с данным. Для этого нужно
определить 'известный' номер локального порта (80 для Веб-сервера), поставить
удаленный IP и удаленное номер порта равным 0(указывает, что любое удаленное
приложение может соединиться).

Как только сокет будет открыт, придётся ждать входящего подключения перед
выполнением чего - либо. Это может быть проверкой состояния разъема для
TCB_ESTABLISHED или ожиданием данных в получающемся буфере.

На Активном подключении вы соединяетесь с указанным удаленным портом. Удаленный
IP и удаленные параметры порта должны быть переведены в ненулевые значениями
(иначе, с чем соединятся?). Также, определите уникальный  номер локального
порта, так чтобы удаленное приложение могло найти нужную программу и установить
с ней соединение. Ведь, могут быть несколько программ на вашей машине,
подключенные к одному и тому же удалённому компьютеру.
Ниже написано, как найти уникальный номер порта.

Как находить неиспользованный номер локального порта
====================================================

Создавая активное подключение с удаленным сокетом, у вас может появиться
желание выбрать уникальный номер локального порта. Обычно, номера локального
порта начинаются с 1000. Следующий код может использоваться, чтобы получить
неиспользованный номер порта до создания сокета.

   mov    ecx, 1000         ; Определяем локальный порт, начинаем с 1000

getlp:
   inc    ecx
   push   ecx
   mov    eax, 53
   mov    ebx, 9
   int    0x40
   pop    ecx
   cmp    eax, 0            ; этот локальный порт используется?
   jz     getlp             ; да - продолжаем перебирать

   ; ecx содержит номер свободного локального порта



Запись данных в сокет
=====================

Есть две функции, зависящие от того, был ли разъем открыт для протокола TCP или
UDP. параметры запроса - то же самое как бы то ни было. Когда сокет открывается
для TCP, используйте функцию состояния, чтобы опросить для подключения - данные
не могут быть переданы сокету, пока другой не соединился с этим. Состояние
сокета - TCB_ESTABLISHED.

Когда вы посылаете данные, происходит создание и отправка одного IP пакета. А
это значит, что пользовательское приложение отвечает за размер передаваемых
пакетов. Сохраняется менее чем 768 байтов размера пакета. Если вы пишете
оконченную программу (такую, как telnet), то можете захотеть отправлять пакет
за каждое (неэффективное) нажатие клавиши. Можно использовать таймер, чтобы
отправлять данные периодически (скажем, каждую секунду).

Чтение данных из сокета
=======================

Есть одна функция для чтения данных из сокета, возвращающая данные в буфер. Эта
функция одновременно восстанавливает один байт. Вы можете использовать функцию
опроса, чтобы проверить получающийся буфер на данные.

Закрытие сокета
================

Просто вызовите соответствующую функцию (для TCP или UDP, соответственно).
Закрывая TCP сокет, не забудьте, что на другой конце соединения, сокет может
продолжить отправлять данные, так что он остаётся активным в течение нескольких
секунд после вашего запроса.



Если у вас есть вопросы или предложения по улучшению этого документа, то
пошлите мне письмо на mikeh@oceanfree.net.
Перевёл документ Hex.
Если есть вопросы или предложения по содержанию, то просьба написать мне на
mestack@yandex.ru или на наш форум: http://meos.sysbin.com
